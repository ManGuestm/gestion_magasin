// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'database.dart';

// ignore_for_file: type=lint
class $SocTable extends Soc with TableInfo<$SocTable, SocData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SocTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _refMeta = const VerificationMeta('ref');
  @override
  late final GeneratedColumn<String> ref = GeneratedColumn<String>(
      'ref', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _rsocMeta = const VerificationMeta('rsoc');
  @override
  late final GeneratedColumn<String> rsoc = GeneratedColumn<String>(
      'rsoc', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _activitesMeta =
      const VerificationMeta('activites');
  @override
  late final GeneratedColumn<String> activites = GeneratedColumn<String>(
      'activites', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _adrMeta = const VerificationMeta('adr');
  @override
  late final GeneratedColumn<String> adr = GeneratedColumn<String>(
      'adr', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 200),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _logoMeta = const VerificationMeta('logo');
  @override
  late final GeneratedColumn<String> logo = GeneratedColumn<String>(
      'logo', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 200),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _capitalMeta =
      const VerificationMeta('capital');
  @override
  late final GeneratedColumn<double> capital = GeneratedColumn<double>(
      'capital', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _rcsMeta = const VerificationMeta('rcs');
  @override
  late final GeneratedColumn<String> rcs = GeneratedColumn<String>(
      'rcs', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _nifMeta = const VerificationMeta('nif');
  @override
  late final GeneratedColumn<String> nif = GeneratedColumn<String>(
      'nif', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _statMeta = const VerificationMeta('stat');
  @override
  late final GeneratedColumn<String> stat = GeneratedColumn<String>(
      'stat', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _telMeta = const VerificationMeta('tel');
  @override
  late final GeneratedColumn<String> tel = GeneratedColumn<String>(
      'tel', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _portMeta = const VerificationMeta('port');
  @override
  late final GeneratedColumn<String> port = GeneratedColumn<String>(
      'port', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _emailMeta = const VerificationMeta('email');
  @override
  late final GeneratedColumn<String> email = GeneratedColumn<String>(
      'email', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _siteMeta = const VerificationMeta('site');
  @override
  late final GeneratedColumn<String> site = GeneratedColumn<String>(
      'site', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _faxMeta = const VerificationMeta('fax');
  @override
  late final GeneratedColumn<String> fax = GeneratedColumn<String>(
      'fax', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _telexMeta = const VerificationMeta('telex');
  @override
  late final GeneratedColumn<String> telex = GeneratedColumn<String>(
      'telex', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _tvaMeta = const VerificationMeta('tva');
  @override
  late final GeneratedColumn<double> tva = GeneratedColumn<double>(
      'tva', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _tMeta = const VerificationMeta('t');
  @override
  late final GeneratedColumn<double> t = GeneratedColumn<double>(
      't', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _valMeta = const VerificationMeta('val');
  @override
  late final GeneratedColumn<String> val = GeneratedColumn<String>(
      'val', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _cifMeta = const VerificationMeta('cif');
  @override
  late final GeneratedColumn<String> cif = GeneratedColumn<String>(
      'cif', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        ref,
        rsoc,
        activites,
        adr,
        logo,
        capital,
        rcs,
        nif,
        stat,
        tel,
        port,
        email,
        site,
        fax,
        telex,
        tva,
        t,
        val,
        cif
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'soc';
  @override
  VerificationContext validateIntegrity(Insertable<SocData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('ref')) {
      context.handle(
          _refMeta, ref.isAcceptableOrUnknown(data['ref']!, _refMeta));
    } else if (isInserting) {
      context.missing(_refMeta);
    }
    if (data.containsKey('rsoc')) {
      context.handle(
          _rsocMeta, rsoc.isAcceptableOrUnknown(data['rsoc']!, _rsocMeta));
    }
    if (data.containsKey('activites')) {
      context.handle(_activitesMeta,
          activites.isAcceptableOrUnknown(data['activites']!, _activitesMeta));
    }
    if (data.containsKey('adr')) {
      context.handle(
          _adrMeta, adr.isAcceptableOrUnknown(data['adr']!, _adrMeta));
    }
    if (data.containsKey('logo')) {
      context.handle(
          _logoMeta, logo.isAcceptableOrUnknown(data['logo']!, _logoMeta));
    }
    if (data.containsKey('capital')) {
      context.handle(_capitalMeta,
          capital.isAcceptableOrUnknown(data['capital']!, _capitalMeta));
    }
    if (data.containsKey('rcs')) {
      context.handle(
          _rcsMeta, rcs.isAcceptableOrUnknown(data['rcs']!, _rcsMeta));
    }
    if (data.containsKey('nif')) {
      context.handle(
          _nifMeta, nif.isAcceptableOrUnknown(data['nif']!, _nifMeta));
    }
    if (data.containsKey('stat')) {
      context.handle(
          _statMeta, stat.isAcceptableOrUnknown(data['stat']!, _statMeta));
    }
    if (data.containsKey('tel')) {
      context.handle(
          _telMeta, tel.isAcceptableOrUnknown(data['tel']!, _telMeta));
    }
    if (data.containsKey('port')) {
      context.handle(
          _portMeta, port.isAcceptableOrUnknown(data['port']!, _portMeta));
    }
    if (data.containsKey('email')) {
      context.handle(
          _emailMeta, email.isAcceptableOrUnknown(data['email']!, _emailMeta));
    }
    if (data.containsKey('site')) {
      context.handle(
          _siteMeta, site.isAcceptableOrUnknown(data['site']!, _siteMeta));
    }
    if (data.containsKey('fax')) {
      context.handle(
          _faxMeta, fax.isAcceptableOrUnknown(data['fax']!, _faxMeta));
    }
    if (data.containsKey('telex')) {
      context.handle(
          _telexMeta, telex.isAcceptableOrUnknown(data['telex']!, _telexMeta));
    }
    if (data.containsKey('tva')) {
      context.handle(
          _tvaMeta, tva.isAcceptableOrUnknown(data['tva']!, _tvaMeta));
    }
    if (data.containsKey('t')) {
      context.handle(_tMeta, t.isAcceptableOrUnknown(data['t']!, _tMeta));
    }
    if (data.containsKey('val')) {
      context.handle(
          _valMeta, val.isAcceptableOrUnknown(data['val']!, _valMeta));
    }
    if (data.containsKey('cif')) {
      context.handle(
          _cifMeta, cif.isAcceptableOrUnknown(data['cif']!, _cifMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {ref};
  @override
  SocData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SocData(
      ref: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}ref'])!,
      rsoc: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}rsoc']),
      activites: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}activites']),
      adr: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}adr']),
      logo: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}logo']),
      capital: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}capital']),
      rcs: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}rcs']),
      nif: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}nif']),
      stat: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}stat']),
      tel: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tel']),
      port: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}port']),
      email: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}email']),
      site: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}site']),
      fax: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}fax']),
      telex: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}telex']),
      tva: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}tva']),
      t: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}t']),
      val: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}val']),
      cif: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}cif']),
    );
  }

  @override
  $SocTable createAlias(String alias) {
    return $SocTable(attachedDatabase, alias);
  }
}

class SocData extends DataClass implements Insertable<SocData> {
  final String ref;
  final String? rsoc;
  final String? activites;
  final String? adr;
  final String? logo;
  final double? capital;
  final String? rcs;
  final String? nif;
  final String? stat;
  final String? tel;
  final String? port;
  final String? email;
  final String? site;
  final String? fax;
  final String? telex;
  final double? tva;
  final double? t;
  final String? val;
  final String? cif;
  const SocData(
      {required this.ref,
      this.rsoc,
      this.activites,
      this.adr,
      this.logo,
      this.capital,
      this.rcs,
      this.nif,
      this.stat,
      this.tel,
      this.port,
      this.email,
      this.site,
      this.fax,
      this.telex,
      this.tva,
      this.t,
      this.val,
      this.cif});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['ref'] = Variable<String>(ref);
    if (!nullToAbsent || rsoc != null) {
      map['rsoc'] = Variable<String>(rsoc);
    }
    if (!nullToAbsent || activites != null) {
      map['activites'] = Variable<String>(activites);
    }
    if (!nullToAbsent || adr != null) {
      map['adr'] = Variable<String>(adr);
    }
    if (!nullToAbsent || logo != null) {
      map['logo'] = Variable<String>(logo);
    }
    if (!nullToAbsent || capital != null) {
      map['capital'] = Variable<double>(capital);
    }
    if (!nullToAbsent || rcs != null) {
      map['rcs'] = Variable<String>(rcs);
    }
    if (!nullToAbsent || nif != null) {
      map['nif'] = Variable<String>(nif);
    }
    if (!nullToAbsent || stat != null) {
      map['stat'] = Variable<String>(stat);
    }
    if (!nullToAbsent || tel != null) {
      map['tel'] = Variable<String>(tel);
    }
    if (!nullToAbsent || port != null) {
      map['port'] = Variable<String>(port);
    }
    if (!nullToAbsent || email != null) {
      map['email'] = Variable<String>(email);
    }
    if (!nullToAbsent || site != null) {
      map['site'] = Variable<String>(site);
    }
    if (!nullToAbsent || fax != null) {
      map['fax'] = Variable<String>(fax);
    }
    if (!nullToAbsent || telex != null) {
      map['telex'] = Variable<String>(telex);
    }
    if (!nullToAbsent || tva != null) {
      map['tva'] = Variable<double>(tva);
    }
    if (!nullToAbsent || t != null) {
      map['t'] = Variable<double>(t);
    }
    if (!nullToAbsent || val != null) {
      map['val'] = Variable<String>(val);
    }
    if (!nullToAbsent || cif != null) {
      map['cif'] = Variable<String>(cif);
    }
    return map;
  }

  SocCompanion toCompanion(bool nullToAbsent) {
    return SocCompanion(
      ref: Value(ref),
      rsoc: rsoc == null && nullToAbsent ? const Value.absent() : Value(rsoc),
      activites: activites == null && nullToAbsent
          ? const Value.absent()
          : Value(activites),
      adr: adr == null && nullToAbsent ? const Value.absent() : Value(adr),
      logo: logo == null && nullToAbsent ? const Value.absent() : Value(logo),
      capital: capital == null && nullToAbsent
          ? const Value.absent()
          : Value(capital),
      rcs: rcs == null && nullToAbsent ? const Value.absent() : Value(rcs),
      nif: nif == null && nullToAbsent ? const Value.absent() : Value(nif),
      stat: stat == null && nullToAbsent ? const Value.absent() : Value(stat),
      tel: tel == null && nullToAbsent ? const Value.absent() : Value(tel),
      port: port == null && nullToAbsent ? const Value.absent() : Value(port),
      email:
          email == null && nullToAbsent ? const Value.absent() : Value(email),
      site: site == null && nullToAbsent ? const Value.absent() : Value(site),
      fax: fax == null && nullToAbsent ? const Value.absent() : Value(fax),
      telex:
          telex == null && nullToAbsent ? const Value.absent() : Value(telex),
      tva: tva == null && nullToAbsent ? const Value.absent() : Value(tva),
      t: t == null && nullToAbsent ? const Value.absent() : Value(t),
      val: val == null && nullToAbsent ? const Value.absent() : Value(val),
      cif: cif == null && nullToAbsent ? const Value.absent() : Value(cif),
    );
  }

  factory SocData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SocData(
      ref: serializer.fromJson<String>(json['ref']),
      rsoc: serializer.fromJson<String?>(json['rsoc']),
      activites: serializer.fromJson<String?>(json['activites']),
      adr: serializer.fromJson<String?>(json['adr']),
      logo: serializer.fromJson<String?>(json['logo']),
      capital: serializer.fromJson<double?>(json['capital']),
      rcs: serializer.fromJson<String?>(json['rcs']),
      nif: serializer.fromJson<String?>(json['nif']),
      stat: serializer.fromJson<String?>(json['stat']),
      tel: serializer.fromJson<String?>(json['tel']),
      port: serializer.fromJson<String?>(json['port']),
      email: serializer.fromJson<String?>(json['email']),
      site: serializer.fromJson<String?>(json['site']),
      fax: serializer.fromJson<String?>(json['fax']),
      telex: serializer.fromJson<String?>(json['telex']),
      tva: serializer.fromJson<double?>(json['tva']),
      t: serializer.fromJson<double?>(json['t']),
      val: serializer.fromJson<String?>(json['val']),
      cif: serializer.fromJson<String?>(json['cif']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'ref': serializer.toJson<String>(ref),
      'rsoc': serializer.toJson<String?>(rsoc),
      'activites': serializer.toJson<String?>(activites),
      'adr': serializer.toJson<String?>(adr),
      'logo': serializer.toJson<String?>(logo),
      'capital': serializer.toJson<double?>(capital),
      'rcs': serializer.toJson<String?>(rcs),
      'nif': serializer.toJson<String?>(nif),
      'stat': serializer.toJson<String?>(stat),
      'tel': serializer.toJson<String?>(tel),
      'port': serializer.toJson<String?>(port),
      'email': serializer.toJson<String?>(email),
      'site': serializer.toJson<String?>(site),
      'fax': serializer.toJson<String?>(fax),
      'telex': serializer.toJson<String?>(telex),
      'tva': serializer.toJson<double?>(tva),
      't': serializer.toJson<double?>(t),
      'val': serializer.toJson<String?>(val),
      'cif': serializer.toJson<String?>(cif),
    };
  }

  SocData copyWith(
          {String? ref,
          Value<String?> rsoc = const Value.absent(),
          Value<String?> activites = const Value.absent(),
          Value<String?> adr = const Value.absent(),
          Value<String?> logo = const Value.absent(),
          Value<double?> capital = const Value.absent(),
          Value<String?> rcs = const Value.absent(),
          Value<String?> nif = const Value.absent(),
          Value<String?> stat = const Value.absent(),
          Value<String?> tel = const Value.absent(),
          Value<String?> port = const Value.absent(),
          Value<String?> email = const Value.absent(),
          Value<String?> site = const Value.absent(),
          Value<String?> fax = const Value.absent(),
          Value<String?> telex = const Value.absent(),
          Value<double?> tva = const Value.absent(),
          Value<double?> t = const Value.absent(),
          Value<String?> val = const Value.absent(),
          Value<String?> cif = const Value.absent()}) =>
      SocData(
        ref: ref ?? this.ref,
        rsoc: rsoc.present ? rsoc.value : this.rsoc,
        activites: activites.present ? activites.value : this.activites,
        adr: adr.present ? adr.value : this.adr,
        logo: logo.present ? logo.value : this.logo,
        capital: capital.present ? capital.value : this.capital,
        rcs: rcs.present ? rcs.value : this.rcs,
        nif: nif.present ? nif.value : this.nif,
        stat: stat.present ? stat.value : this.stat,
        tel: tel.present ? tel.value : this.tel,
        port: port.present ? port.value : this.port,
        email: email.present ? email.value : this.email,
        site: site.present ? site.value : this.site,
        fax: fax.present ? fax.value : this.fax,
        telex: telex.present ? telex.value : this.telex,
        tva: tva.present ? tva.value : this.tva,
        t: t.present ? t.value : this.t,
        val: val.present ? val.value : this.val,
        cif: cif.present ? cif.value : this.cif,
      );
  SocData copyWithCompanion(SocCompanion data) {
    return SocData(
      ref: data.ref.present ? data.ref.value : this.ref,
      rsoc: data.rsoc.present ? data.rsoc.value : this.rsoc,
      activites: data.activites.present ? data.activites.value : this.activites,
      adr: data.adr.present ? data.adr.value : this.adr,
      logo: data.logo.present ? data.logo.value : this.logo,
      capital: data.capital.present ? data.capital.value : this.capital,
      rcs: data.rcs.present ? data.rcs.value : this.rcs,
      nif: data.nif.present ? data.nif.value : this.nif,
      stat: data.stat.present ? data.stat.value : this.stat,
      tel: data.tel.present ? data.tel.value : this.tel,
      port: data.port.present ? data.port.value : this.port,
      email: data.email.present ? data.email.value : this.email,
      site: data.site.present ? data.site.value : this.site,
      fax: data.fax.present ? data.fax.value : this.fax,
      telex: data.telex.present ? data.telex.value : this.telex,
      tva: data.tva.present ? data.tva.value : this.tva,
      t: data.t.present ? data.t.value : this.t,
      val: data.val.present ? data.val.value : this.val,
      cif: data.cif.present ? data.cif.value : this.cif,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SocData(')
          ..write('ref: $ref, ')
          ..write('rsoc: $rsoc, ')
          ..write('activites: $activites, ')
          ..write('adr: $adr, ')
          ..write('logo: $logo, ')
          ..write('capital: $capital, ')
          ..write('rcs: $rcs, ')
          ..write('nif: $nif, ')
          ..write('stat: $stat, ')
          ..write('tel: $tel, ')
          ..write('port: $port, ')
          ..write('email: $email, ')
          ..write('site: $site, ')
          ..write('fax: $fax, ')
          ..write('telex: $telex, ')
          ..write('tva: $tva, ')
          ..write('t: $t, ')
          ..write('val: $val, ')
          ..write('cif: $cif')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(ref, rsoc, activites, adr, logo, capital, rcs,
      nif, stat, tel, port, email, site, fax, telex, tva, t, val, cif);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SocData &&
          other.ref == this.ref &&
          other.rsoc == this.rsoc &&
          other.activites == this.activites &&
          other.adr == this.adr &&
          other.logo == this.logo &&
          other.capital == this.capital &&
          other.rcs == this.rcs &&
          other.nif == this.nif &&
          other.stat == this.stat &&
          other.tel == this.tel &&
          other.port == this.port &&
          other.email == this.email &&
          other.site == this.site &&
          other.fax == this.fax &&
          other.telex == this.telex &&
          other.tva == this.tva &&
          other.t == this.t &&
          other.val == this.val &&
          other.cif == this.cif);
}

class SocCompanion extends UpdateCompanion<SocData> {
  final Value<String> ref;
  final Value<String?> rsoc;
  final Value<String?> activites;
  final Value<String?> adr;
  final Value<String?> logo;
  final Value<double?> capital;
  final Value<String?> rcs;
  final Value<String?> nif;
  final Value<String?> stat;
  final Value<String?> tel;
  final Value<String?> port;
  final Value<String?> email;
  final Value<String?> site;
  final Value<String?> fax;
  final Value<String?> telex;
  final Value<double?> tva;
  final Value<double?> t;
  final Value<String?> val;
  final Value<String?> cif;
  final Value<int> rowid;
  const SocCompanion({
    this.ref = const Value.absent(),
    this.rsoc = const Value.absent(),
    this.activites = const Value.absent(),
    this.adr = const Value.absent(),
    this.logo = const Value.absent(),
    this.capital = const Value.absent(),
    this.rcs = const Value.absent(),
    this.nif = const Value.absent(),
    this.stat = const Value.absent(),
    this.tel = const Value.absent(),
    this.port = const Value.absent(),
    this.email = const Value.absent(),
    this.site = const Value.absent(),
    this.fax = const Value.absent(),
    this.telex = const Value.absent(),
    this.tva = const Value.absent(),
    this.t = const Value.absent(),
    this.val = const Value.absent(),
    this.cif = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SocCompanion.insert({
    required String ref,
    this.rsoc = const Value.absent(),
    this.activites = const Value.absent(),
    this.adr = const Value.absent(),
    this.logo = const Value.absent(),
    this.capital = const Value.absent(),
    this.rcs = const Value.absent(),
    this.nif = const Value.absent(),
    this.stat = const Value.absent(),
    this.tel = const Value.absent(),
    this.port = const Value.absent(),
    this.email = const Value.absent(),
    this.site = const Value.absent(),
    this.fax = const Value.absent(),
    this.telex = const Value.absent(),
    this.tva = const Value.absent(),
    this.t = const Value.absent(),
    this.val = const Value.absent(),
    this.cif = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : ref = Value(ref);
  static Insertable<SocData> custom({
    Expression<String>? ref,
    Expression<String>? rsoc,
    Expression<String>? activites,
    Expression<String>? adr,
    Expression<String>? logo,
    Expression<double>? capital,
    Expression<String>? rcs,
    Expression<String>? nif,
    Expression<String>? stat,
    Expression<String>? tel,
    Expression<String>? port,
    Expression<String>? email,
    Expression<String>? site,
    Expression<String>? fax,
    Expression<String>? telex,
    Expression<double>? tva,
    Expression<double>? t,
    Expression<String>? val,
    Expression<String>? cif,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (ref != null) 'ref': ref,
      if (rsoc != null) 'rsoc': rsoc,
      if (activites != null) 'activites': activites,
      if (adr != null) 'adr': adr,
      if (logo != null) 'logo': logo,
      if (capital != null) 'capital': capital,
      if (rcs != null) 'rcs': rcs,
      if (nif != null) 'nif': nif,
      if (stat != null) 'stat': stat,
      if (tel != null) 'tel': tel,
      if (port != null) 'port': port,
      if (email != null) 'email': email,
      if (site != null) 'site': site,
      if (fax != null) 'fax': fax,
      if (telex != null) 'telex': telex,
      if (tva != null) 'tva': tva,
      if (t != null) 't': t,
      if (val != null) 'val': val,
      if (cif != null) 'cif': cif,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SocCompanion copyWith(
      {Value<String>? ref,
      Value<String?>? rsoc,
      Value<String?>? activites,
      Value<String?>? adr,
      Value<String?>? logo,
      Value<double?>? capital,
      Value<String?>? rcs,
      Value<String?>? nif,
      Value<String?>? stat,
      Value<String?>? tel,
      Value<String?>? port,
      Value<String?>? email,
      Value<String?>? site,
      Value<String?>? fax,
      Value<String?>? telex,
      Value<double?>? tva,
      Value<double?>? t,
      Value<String?>? val,
      Value<String?>? cif,
      Value<int>? rowid}) {
    return SocCompanion(
      ref: ref ?? this.ref,
      rsoc: rsoc ?? this.rsoc,
      activites: activites ?? this.activites,
      adr: adr ?? this.adr,
      logo: logo ?? this.logo,
      capital: capital ?? this.capital,
      rcs: rcs ?? this.rcs,
      nif: nif ?? this.nif,
      stat: stat ?? this.stat,
      tel: tel ?? this.tel,
      port: port ?? this.port,
      email: email ?? this.email,
      site: site ?? this.site,
      fax: fax ?? this.fax,
      telex: telex ?? this.telex,
      tva: tva ?? this.tva,
      t: t ?? this.t,
      val: val ?? this.val,
      cif: cif ?? this.cif,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (ref.present) {
      map['ref'] = Variable<String>(ref.value);
    }
    if (rsoc.present) {
      map['rsoc'] = Variable<String>(rsoc.value);
    }
    if (activites.present) {
      map['activites'] = Variable<String>(activites.value);
    }
    if (adr.present) {
      map['adr'] = Variable<String>(adr.value);
    }
    if (logo.present) {
      map['logo'] = Variable<String>(logo.value);
    }
    if (capital.present) {
      map['capital'] = Variable<double>(capital.value);
    }
    if (rcs.present) {
      map['rcs'] = Variable<String>(rcs.value);
    }
    if (nif.present) {
      map['nif'] = Variable<String>(nif.value);
    }
    if (stat.present) {
      map['stat'] = Variable<String>(stat.value);
    }
    if (tel.present) {
      map['tel'] = Variable<String>(tel.value);
    }
    if (port.present) {
      map['port'] = Variable<String>(port.value);
    }
    if (email.present) {
      map['email'] = Variable<String>(email.value);
    }
    if (site.present) {
      map['site'] = Variable<String>(site.value);
    }
    if (fax.present) {
      map['fax'] = Variable<String>(fax.value);
    }
    if (telex.present) {
      map['telex'] = Variable<String>(telex.value);
    }
    if (tva.present) {
      map['tva'] = Variable<double>(tva.value);
    }
    if (t.present) {
      map['t'] = Variable<double>(t.value);
    }
    if (val.present) {
      map['val'] = Variable<String>(val.value);
    }
    if (cif.present) {
      map['cif'] = Variable<String>(cif.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SocCompanion(')
          ..write('ref: $ref, ')
          ..write('rsoc: $rsoc, ')
          ..write('activites: $activites, ')
          ..write('adr: $adr, ')
          ..write('logo: $logo, ')
          ..write('capital: $capital, ')
          ..write('rcs: $rcs, ')
          ..write('nif: $nif, ')
          ..write('stat: $stat, ')
          ..write('tel: $tel, ')
          ..write('port: $port, ')
          ..write('email: $email, ')
          ..write('site: $site, ')
          ..write('fax: $fax, ')
          ..write('telex: $telex, ')
          ..write('tva: $tva, ')
          ..write('t: $t, ')
          ..write('val: $val, ')
          ..write('cif: $cif, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $DepotsTable extends Depots with TableInfo<$DepotsTable, Depot> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DepotsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _depotsMeta = const VerificationMeta('depots');
  @override
  late final GeneratedColumn<String> depots = GeneratedColumn<String>(
      'depots', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [depots];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'depots';
  @override
  VerificationContext validateIntegrity(Insertable<Depot> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('depots')) {
      context.handle(_depotsMeta,
          depots.isAcceptableOrUnknown(data['depots']!, _depotsMeta));
    } else if (isInserting) {
      context.missing(_depotsMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {depots};
  @override
  Depot map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Depot(
      depots: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}depots'])!,
    );
  }

  @override
  $DepotsTable createAlias(String alias) {
    return $DepotsTable(attachedDatabase, alias);
  }
}

class Depot extends DataClass implements Insertable<Depot> {
  final String depots;
  const Depot({required this.depots});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['depots'] = Variable<String>(depots);
    return map;
  }

  DepotsCompanion toCompanion(bool nullToAbsent) {
    return DepotsCompanion(
      depots: Value(depots),
    );
  }

  factory Depot.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Depot(
      depots: serializer.fromJson<String>(json['depots']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'depots': serializer.toJson<String>(depots),
    };
  }

  Depot copyWith({String? depots}) => Depot(
        depots: depots ?? this.depots,
      );
  Depot copyWithCompanion(DepotsCompanion data) {
    return Depot(
      depots: data.depots.present ? data.depots.value : this.depots,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Depot(')
          ..write('depots: $depots')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => depots.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) || (other is Depot && other.depots == this.depots);
}

class DepotsCompanion extends UpdateCompanion<Depot> {
  final Value<String> depots;
  final Value<int> rowid;
  const DepotsCompanion({
    this.depots = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  DepotsCompanion.insert({
    required String depots,
    this.rowid = const Value.absent(),
  }) : depots = Value(depots);
  static Insertable<Depot> custom({
    Expression<String>? depots,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (depots != null) 'depots': depots,
      if (rowid != null) 'rowid': rowid,
    });
  }

  DepotsCompanion copyWith({Value<String>? depots, Value<int>? rowid}) {
    return DepotsCompanion(
      depots: depots ?? this.depots,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (depots.present) {
      map['depots'] = Variable<String>(depots.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DepotsCompanion(')
          ..write('depots: $depots, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ArticlesTable extends Articles with TableInfo<$ArticlesTable, Article> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ArticlesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _designationMeta =
      const VerificationMeta('designation');
  @override
  late final GeneratedColumn<String> designation = GeneratedColumn<String>(
      'designation', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _u1Meta = const VerificationMeta('u1');
  @override
  late final GeneratedColumn<String> u1 = GeneratedColumn<String>(
      'u1', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _u2Meta = const VerificationMeta('u2');
  @override
  late final GeneratedColumn<String> u2 = GeneratedColumn<String>(
      'u2', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _tu2u1Meta = const VerificationMeta('tu2u1');
  @override
  late final GeneratedColumn<double> tu2u1 = GeneratedColumn<double>(
      'tu2u1', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _u3Meta = const VerificationMeta('u3');
  @override
  late final GeneratedColumn<String> u3 = GeneratedColumn<String>(
      'u3', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _tu3u2Meta = const VerificationMeta('tu3u2');
  @override
  late final GeneratedColumn<double> tu3u2 = GeneratedColumn<double>(
      'tu3u2', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _pvu1Meta = const VerificationMeta('pvu1');
  @override
  late final GeneratedColumn<double> pvu1 = GeneratedColumn<double>(
      'pvu1', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _pvu2Meta = const VerificationMeta('pvu2');
  @override
  late final GeneratedColumn<double> pvu2 = GeneratedColumn<double>(
      'pvu2', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _pvu3Meta = const VerificationMeta('pvu3');
  @override
  late final GeneratedColumn<double> pvu3 = GeneratedColumn<double>(
      'pvu3', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _stocksu1Meta =
      const VerificationMeta('stocksu1');
  @override
  late final GeneratedColumn<double> stocksu1 = GeneratedColumn<double>(
      'stocksu1', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _stocksu2Meta =
      const VerificationMeta('stocksu2');
  @override
  late final GeneratedColumn<double> stocksu2 = GeneratedColumn<double>(
      'stocksu2', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _stocksu3Meta =
      const VerificationMeta('stocksu3');
  @override
  late final GeneratedColumn<double> stocksu3 = GeneratedColumn<double>(
      'stocksu3', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _secMeta = const VerificationMeta('sec');
  @override
  late final GeneratedColumn<String> sec = GeneratedColumn<String>(
      'sec', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _usecMeta = const VerificationMeta('usec');
  @override
  late final GeneratedColumn<double> usec = GeneratedColumn<double>(
      'usec', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _cmupMeta = const VerificationMeta('cmup');
  @override
  late final GeneratedColumn<double> cmup = GeneratedColumn<double>(
      'cmup', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _depMeta = const VerificationMeta('dep');
  @override
  late final GeneratedColumn<String> dep = GeneratedColumn<String>(
      'dep', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _actionMeta = const VerificationMeta('action');
  @override
  late final GeneratedColumn<String> action = GeneratedColumn<String>(
      'action', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _categorieMeta =
      const VerificationMeta('categorie');
  @override
  late final GeneratedColumn<String> categorie = GeneratedColumn<String>(
      'categorie', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _classificationMeta =
      const VerificationMeta('classification');
  @override
  late final GeneratedColumn<String> classification = GeneratedColumn<String>(
      'classification', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _embMeta = const VerificationMeta('emb');
  @override
  late final GeneratedColumn<String> emb = GeneratedColumn<String>(
      'emb', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        designation,
        u1,
        u2,
        tu2u1,
        u3,
        tu3u2,
        pvu1,
        pvu2,
        pvu3,
        stocksu1,
        stocksu2,
        stocksu3,
        sec,
        usec,
        cmup,
        dep,
        action,
        categorie,
        classification,
        emb
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'articles';
  @override
  VerificationContext validateIntegrity(Insertable<Article> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('designation')) {
      context.handle(
          _designationMeta,
          designation.isAcceptableOrUnknown(
              data['designation']!, _designationMeta));
    } else if (isInserting) {
      context.missing(_designationMeta);
    }
    if (data.containsKey('u1')) {
      context.handle(_u1Meta, u1.isAcceptableOrUnknown(data['u1']!, _u1Meta));
    }
    if (data.containsKey('u2')) {
      context.handle(_u2Meta, u2.isAcceptableOrUnknown(data['u2']!, _u2Meta));
    }
    if (data.containsKey('tu2u1')) {
      context.handle(
          _tu2u1Meta, tu2u1.isAcceptableOrUnknown(data['tu2u1']!, _tu2u1Meta));
    }
    if (data.containsKey('u3')) {
      context.handle(_u3Meta, u3.isAcceptableOrUnknown(data['u3']!, _u3Meta));
    }
    if (data.containsKey('tu3u2')) {
      context.handle(
          _tu3u2Meta, tu3u2.isAcceptableOrUnknown(data['tu3u2']!, _tu3u2Meta));
    }
    if (data.containsKey('pvu1')) {
      context.handle(
          _pvu1Meta, pvu1.isAcceptableOrUnknown(data['pvu1']!, _pvu1Meta));
    }
    if (data.containsKey('pvu2')) {
      context.handle(
          _pvu2Meta, pvu2.isAcceptableOrUnknown(data['pvu2']!, _pvu2Meta));
    }
    if (data.containsKey('pvu3')) {
      context.handle(
          _pvu3Meta, pvu3.isAcceptableOrUnknown(data['pvu3']!, _pvu3Meta));
    }
    if (data.containsKey('stocksu1')) {
      context.handle(_stocksu1Meta,
          stocksu1.isAcceptableOrUnknown(data['stocksu1']!, _stocksu1Meta));
    }
    if (data.containsKey('stocksu2')) {
      context.handle(_stocksu2Meta,
          stocksu2.isAcceptableOrUnknown(data['stocksu2']!, _stocksu2Meta));
    }
    if (data.containsKey('stocksu3')) {
      context.handle(_stocksu3Meta,
          stocksu3.isAcceptableOrUnknown(data['stocksu3']!, _stocksu3Meta));
    }
    if (data.containsKey('sec')) {
      context.handle(
          _secMeta, sec.isAcceptableOrUnknown(data['sec']!, _secMeta));
    }
    if (data.containsKey('usec')) {
      context.handle(
          _usecMeta, usec.isAcceptableOrUnknown(data['usec']!, _usecMeta));
    }
    if (data.containsKey('cmup')) {
      context.handle(
          _cmupMeta, cmup.isAcceptableOrUnknown(data['cmup']!, _cmupMeta));
    }
    if (data.containsKey('dep')) {
      context.handle(
          _depMeta, dep.isAcceptableOrUnknown(data['dep']!, _depMeta));
    }
    if (data.containsKey('action')) {
      context.handle(_actionMeta,
          action.isAcceptableOrUnknown(data['action']!, _actionMeta));
    }
    if (data.containsKey('categorie')) {
      context.handle(_categorieMeta,
          categorie.isAcceptableOrUnknown(data['categorie']!, _categorieMeta));
    }
    if (data.containsKey('classification')) {
      context.handle(
          _classificationMeta,
          classification.isAcceptableOrUnknown(
              data['classification']!, _classificationMeta));
    }
    if (data.containsKey('emb')) {
      context.handle(
          _embMeta, emb.isAcceptableOrUnknown(data['emb']!, _embMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {designation};
  @override
  Article map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Article(
      designation: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}designation'])!,
      u1: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}u1']),
      u2: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}u2']),
      tu2u1: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}tu2u1']),
      u3: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}u3']),
      tu3u2: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}tu3u2']),
      pvu1: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}pvu1']),
      pvu2: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}pvu2']),
      pvu3: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}pvu3']),
      stocksu1: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}stocksu1']),
      stocksu2: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}stocksu2']),
      stocksu3: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}stocksu3']),
      sec: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}sec']),
      usec: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}usec']),
      cmup: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}cmup']),
      dep: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}dep']),
      action: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}action']),
      categorie: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}categorie']),
      classification: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}classification']),
      emb: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}emb']),
    );
  }

  @override
  $ArticlesTable createAlias(String alias) {
    return $ArticlesTable(attachedDatabase, alias);
  }
}

class Article extends DataClass implements Insertable<Article> {
  final String designation;
  final String? u1;
  final String? u2;
  final double? tu2u1;
  final String? u3;
  final double? tu3u2;
  final double? pvu1;
  final double? pvu2;
  final double? pvu3;
  final double? stocksu1;
  final double? stocksu2;
  final double? stocksu3;
  final String? sec;
  final double? usec;
  final double? cmup;
  final String? dep;
  final String? action;
  final String? categorie;
  final String? classification;
  final String? emb;
  const Article(
      {required this.designation,
      this.u1,
      this.u2,
      this.tu2u1,
      this.u3,
      this.tu3u2,
      this.pvu1,
      this.pvu2,
      this.pvu3,
      this.stocksu1,
      this.stocksu2,
      this.stocksu3,
      this.sec,
      this.usec,
      this.cmup,
      this.dep,
      this.action,
      this.categorie,
      this.classification,
      this.emb});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['designation'] = Variable<String>(designation);
    if (!nullToAbsent || u1 != null) {
      map['u1'] = Variable<String>(u1);
    }
    if (!nullToAbsent || u2 != null) {
      map['u2'] = Variable<String>(u2);
    }
    if (!nullToAbsent || tu2u1 != null) {
      map['tu2u1'] = Variable<double>(tu2u1);
    }
    if (!nullToAbsent || u3 != null) {
      map['u3'] = Variable<String>(u3);
    }
    if (!nullToAbsent || tu3u2 != null) {
      map['tu3u2'] = Variable<double>(tu3u2);
    }
    if (!nullToAbsent || pvu1 != null) {
      map['pvu1'] = Variable<double>(pvu1);
    }
    if (!nullToAbsent || pvu2 != null) {
      map['pvu2'] = Variable<double>(pvu2);
    }
    if (!nullToAbsent || pvu3 != null) {
      map['pvu3'] = Variable<double>(pvu3);
    }
    if (!nullToAbsent || stocksu1 != null) {
      map['stocksu1'] = Variable<double>(stocksu1);
    }
    if (!nullToAbsent || stocksu2 != null) {
      map['stocksu2'] = Variable<double>(stocksu2);
    }
    if (!nullToAbsent || stocksu3 != null) {
      map['stocksu3'] = Variable<double>(stocksu3);
    }
    if (!nullToAbsent || sec != null) {
      map['sec'] = Variable<String>(sec);
    }
    if (!nullToAbsent || usec != null) {
      map['usec'] = Variable<double>(usec);
    }
    if (!nullToAbsent || cmup != null) {
      map['cmup'] = Variable<double>(cmup);
    }
    if (!nullToAbsent || dep != null) {
      map['dep'] = Variable<String>(dep);
    }
    if (!nullToAbsent || action != null) {
      map['action'] = Variable<String>(action);
    }
    if (!nullToAbsent || categorie != null) {
      map['categorie'] = Variable<String>(categorie);
    }
    if (!nullToAbsent || classification != null) {
      map['classification'] = Variable<String>(classification);
    }
    if (!nullToAbsent || emb != null) {
      map['emb'] = Variable<String>(emb);
    }
    return map;
  }

  ArticlesCompanion toCompanion(bool nullToAbsent) {
    return ArticlesCompanion(
      designation: Value(designation),
      u1: u1 == null && nullToAbsent ? const Value.absent() : Value(u1),
      u2: u2 == null && nullToAbsent ? const Value.absent() : Value(u2),
      tu2u1:
          tu2u1 == null && nullToAbsent ? const Value.absent() : Value(tu2u1),
      u3: u3 == null && nullToAbsent ? const Value.absent() : Value(u3),
      tu3u2:
          tu3u2 == null && nullToAbsent ? const Value.absent() : Value(tu3u2),
      pvu1: pvu1 == null && nullToAbsent ? const Value.absent() : Value(pvu1),
      pvu2: pvu2 == null && nullToAbsent ? const Value.absent() : Value(pvu2),
      pvu3: pvu3 == null && nullToAbsent ? const Value.absent() : Value(pvu3),
      stocksu1: stocksu1 == null && nullToAbsent
          ? const Value.absent()
          : Value(stocksu1),
      stocksu2: stocksu2 == null && nullToAbsent
          ? const Value.absent()
          : Value(stocksu2),
      stocksu3: stocksu3 == null && nullToAbsent
          ? const Value.absent()
          : Value(stocksu3),
      sec: sec == null && nullToAbsent ? const Value.absent() : Value(sec),
      usec: usec == null && nullToAbsent ? const Value.absent() : Value(usec),
      cmup: cmup == null && nullToAbsent ? const Value.absent() : Value(cmup),
      dep: dep == null && nullToAbsent ? const Value.absent() : Value(dep),
      action:
          action == null && nullToAbsent ? const Value.absent() : Value(action),
      categorie: categorie == null && nullToAbsent
          ? const Value.absent()
          : Value(categorie),
      classification: classification == null && nullToAbsent
          ? const Value.absent()
          : Value(classification),
      emb: emb == null && nullToAbsent ? const Value.absent() : Value(emb),
    );
  }

  factory Article.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Article(
      designation: serializer.fromJson<String>(json['designation']),
      u1: serializer.fromJson<String?>(json['u1']),
      u2: serializer.fromJson<String?>(json['u2']),
      tu2u1: serializer.fromJson<double?>(json['tu2u1']),
      u3: serializer.fromJson<String?>(json['u3']),
      tu3u2: serializer.fromJson<double?>(json['tu3u2']),
      pvu1: serializer.fromJson<double?>(json['pvu1']),
      pvu2: serializer.fromJson<double?>(json['pvu2']),
      pvu3: serializer.fromJson<double?>(json['pvu3']),
      stocksu1: serializer.fromJson<double?>(json['stocksu1']),
      stocksu2: serializer.fromJson<double?>(json['stocksu2']),
      stocksu3: serializer.fromJson<double?>(json['stocksu3']),
      sec: serializer.fromJson<String?>(json['sec']),
      usec: serializer.fromJson<double?>(json['usec']),
      cmup: serializer.fromJson<double?>(json['cmup']),
      dep: serializer.fromJson<String?>(json['dep']),
      action: serializer.fromJson<String?>(json['action']),
      categorie: serializer.fromJson<String?>(json['categorie']),
      classification: serializer.fromJson<String?>(json['classification']),
      emb: serializer.fromJson<String?>(json['emb']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'designation': serializer.toJson<String>(designation),
      'u1': serializer.toJson<String?>(u1),
      'u2': serializer.toJson<String?>(u2),
      'tu2u1': serializer.toJson<double?>(tu2u1),
      'u3': serializer.toJson<String?>(u3),
      'tu3u2': serializer.toJson<double?>(tu3u2),
      'pvu1': serializer.toJson<double?>(pvu1),
      'pvu2': serializer.toJson<double?>(pvu2),
      'pvu3': serializer.toJson<double?>(pvu3),
      'stocksu1': serializer.toJson<double?>(stocksu1),
      'stocksu2': serializer.toJson<double?>(stocksu2),
      'stocksu3': serializer.toJson<double?>(stocksu3),
      'sec': serializer.toJson<String?>(sec),
      'usec': serializer.toJson<double?>(usec),
      'cmup': serializer.toJson<double?>(cmup),
      'dep': serializer.toJson<String?>(dep),
      'action': serializer.toJson<String?>(action),
      'categorie': serializer.toJson<String?>(categorie),
      'classification': serializer.toJson<String?>(classification),
      'emb': serializer.toJson<String?>(emb),
    };
  }

  Article copyWith(
          {String? designation,
          Value<String?> u1 = const Value.absent(),
          Value<String?> u2 = const Value.absent(),
          Value<double?> tu2u1 = const Value.absent(),
          Value<String?> u3 = const Value.absent(),
          Value<double?> tu3u2 = const Value.absent(),
          Value<double?> pvu1 = const Value.absent(),
          Value<double?> pvu2 = const Value.absent(),
          Value<double?> pvu3 = const Value.absent(),
          Value<double?> stocksu1 = const Value.absent(),
          Value<double?> stocksu2 = const Value.absent(),
          Value<double?> stocksu3 = const Value.absent(),
          Value<String?> sec = const Value.absent(),
          Value<double?> usec = const Value.absent(),
          Value<double?> cmup = const Value.absent(),
          Value<String?> dep = const Value.absent(),
          Value<String?> action = const Value.absent(),
          Value<String?> categorie = const Value.absent(),
          Value<String?> classification = const Value.absent(),
          Value<String?> emb = const Value.absent()}) =>
      Article(
        designation: designation ?? this.designation,
        u1: u1.present ? u1.value : this.u1,
        u2: u2.present ? u2.value : this.u2,
        tu2u1: tu2u1.present ? tu2u1.value : this.tu2u1,
        u3: u3.present ? u3.value : this.u3,
        tu3u2: tu3u2.present ? tu3u2.value : this.tu3u2,
        pvu1: pvu1.present ? pvu1.value : this.pvu1,
        pvu2: pvu2.present ? pvu2.value : this.pvu2,
        pvu3: pvu3.present ? pvu3.value : this.pvu3,
        stocksu1: stocksu1.present ? stocksu1.value : this.stocksu1,
        stocksu2: stocksu2.present ? stocksu2.value : this.stocksu2,
        stocksu3: stocksu3.present ? stocksu3.value : this.stocksu3,
        sec: sec.present ? sec.value : this.sec,
        usec: usec.present ? usec.value : this.usec,
        cmup: cmup.present ? cmup.value : this.cmup,
        dep: dep.present ? dep.value : this.dep,
        action: action.present ? action.value : this.action,
        categorie: categorie.present ? categorie.value : this.categorie,
        classification:
            classification.present ? classification.value : this.classification,
        emb: emb.present ? emb.value : this.emb,
      );
  Article copyWithCompanion(ArticlesCompanion data) {
    return Article(
      designation:
          data.designation.present ? data.designation.value : this.designation,
      u1: data.u1.present ? data.u1.value : this.u1,
      u2: data.u2.present ? data.u2.value : this.u2,
      tu2u1: data.tu2u1.present ? data.tu2u1.value : this.tu2u1,
      u3: data.u3.present ? data.u3.value : this.u3,
      tu3u2: data.tu3u2.present ? data.tu3u2.value : this.tu3u2,
      pvu1: data.pvu1.present ? data.pvu1.value : this.pvu1,
      pvu2: data.pvu2.present ? data.pvu2.value : this.pvu2,
      pvu3: data.pvu3.present ? data.pvu3.value : this.pvu3,
      stocksu1: data.stocksu1.present ? data.stocksu1.value : this.stocksu1,
      stocksu2: data.stocksu2.present ? data.stocksu2.value : this.stocksu2,
      stocksu3: data.stocksu3.present ? data.stocksu3.value : this.stocksu3,
      sec: data.sec.present ? data.sec.value : this.sec,
      usec: data.usec.present ? data.usec.value : this.usec,
      cmup: data.cmup.present ? data.cmup.value : this.cmup,
      dep: data.dep.present ? data.dep.value : this.dep,
      action: data.action.present ? data.action.value : this.action,
      categorie: data.categorie.present ? data.categorie.value : this.categorie,
      classification: data.classification.present
          ? data.classification.value
          : this.classification,
      emb: data.emb.present ? data.emb.value : this.emb,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Article(')
          ..write('designation: $designation, ')
          ..write('u1: $u1, ')
          ..write('u2: $u2, ')
          ..write('tu2u1: $tu2u1, ')
          ..write('u3: $u3, ')
          ..write('tu3u2: $tu3u2, ')
          ..write('pvu1: $pvu1, ')
          ..write('pvu2: $pvu2, ')
          ..write('pvu3: $pvu3, ')
          ..write('stocksu1: $stocksu1, ')
          ..write('stocksu2: $stocksu2, ')
          ..write('stocksu3: $stocksu3, ')
          ..write('sec: $sec, ')
          ..write('usec: $usec, ')
          ..write('cmup: $cmup, ')
          ..write('dep: $dep, ')
          ..write('action: $action, ')
          ..write('categorie: $categorie, ')
          ..write('classification: $classification, ')
          ..write('emb: $emb')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      designation,
      u1,
      u2,
      tu2u1,
      u3,
      tu3u2,
      pvu1,
      pvu2,
      pvu3,
      stocksu1,
      stocksu2,
      stocksu3,
      sec,
      usec,
      cmup,
      dep,
      action,
      categorie,
      classification,
      emb);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Article &&
          other.designation == this.designation &&
          other.u1 == this.u1 &&
          other.u2 == this.u2 &&
          other.tu2u1 == this.tu2u1 &&
          other.u3 == this.u3 &&
          other.tu3u2 == this.tu3u2 &&
          other.pvu1 == this.pvu1 &&
          other.pvu2 == this.pvu2 &&
          other.pvu3 == this.pvu3 &&
          other.stocksu1 == this.stocksu1 &&
          other.stocksu2 == this.stocksu2 &&
          other.stocksu3 == this.stocksu3 &&
          other.sec == this.sec &&
          other.usec == this.usec &&
          other.cmup == this.cmup &&
          other.dep == this.dep &&
          other.action == this.action &&
          other.categorie == this.categorie &&
          other.classification == this.classification &&
          other.emb == this.emb);
}

class ArticlesCompanion extends UpdateCompanion<Article> {
  final Value<String> designation;
  final Value<String?> u1;
  final Value<String?> u2;
  final Value<double?> tu2u1;
  final Value<String?> u3;
  final Value<double?> tu3u2;
  final Value<double?> pvu1;
  final Value<double?> pvu2;
  final Value<double?> pvu3;
  final Value<double?> stocksu1;
  final Value<double?> stocksu2;
  final Value<double?> stocksu3;
  final Value<String?> sec;
  final Value<double?> usec;
  final Value<double?> cmup;
  final Value<String?> dep;
  final Value<String?> action;
  final Value<String?> categorie;
  final Value<String?> classification;
  final Value<String?> emb;
  final Value<int> rowid;
  const ArticlesCompanion({
    this.designation = const Value.absent(),
    this.u1 = const Value.absent(),
    this.u2 = const Value.absent(),
    this.tu2u1 = const Value.absent(),
    this.u3 = const Value.absent(),
    this.tu3u2 = const Value.absent(),
    this.pvu1 = const Value.absent(),
    this.pvu2 = const Value.absent(),
    this.pvu3 = const Value.absent(),
    this.stocksu1 = const Value.absent(),
    this.stocksu2 = const Value.absent(),
    this.stocksu3 = const Value.absent(),
    this.sec = const Value.absent(),
    this.usec = const Value.absent(),
    this.cmup = const Value.absent(),
    this.dep = const Value.absent(),
    this.action = const Value.absent(),
    this.categorie = const Value.absent(),
    this.classification = const Value.absent(),
    this.emb = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ArticlesCompanion.insert({
    required String designation,
    this.u1 = const Value.absent(),
    this.u2 = const Value.absent(),
    this.tu2u1 = const Value.absent(),
    this.u3 = const Value.absent(),
    this.tu3u2 = const Value.absent(),
    this.pvu1 = const Value.absent(),
    this.pvu2 = const Value.absent(),
    this.pvu3 = const Value.absent(),
    this.stocksu1 = const Value.absent(),
    this.stocksu2 = const Value.absent(),
    this.stocksu3 = const Value.absent(),
    this.sec = const Value.absent(),
    this.usec = const Value.absent(),
    this.cmup = const Value.absent(),
    this.dep = const Value.absent(),
    this.action = const Value.absent(),
    this.categorie = const Value.absent(),
    this.classification = const Value.absent(),
    this.emb = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : designation = Value(designation);
  static Insertable<Article> custom({
    Expression<String>? designation,
    Expression<String>? u1,
    Expression<String>? u2,
    Expression<double>? tu2u1,
    Expression<String>? u3,
    Expression<double>? tu3u2,
    Expression<double>? pvu1,
    Expression<double>? pvu2,
    Expression<double>? pvu3,
    Expression<double>? stocksu1,
    Expression<double>? stocksu2,
    Expression<double>? stocksu3,
    Expression<String>? sec,
    Expression<double>? usec,
    Expression<double>? cmup,
    Expression<String>? dep,
    Expression<String>? action,
    Expression<String>? categorie,
    Expression<String>? classification,
    Expression<String>? emb,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (designation != null) 'designation': designation,
      if (u1 != null) 'u1': u1,
      if (u2 != null) 'u2': u2,
      if (tu2u1 != null) 'tu2u1': tu2u1,
      if (u3 != null) 'u3': u3,
      if (tu3u2 != null) 'tu3u2': tu3u2,
      if (pvu1 != null) 'pvu1': pvu1,
      if (pvu2 != null) 'pvu2': pvu2,
      if (pvu3 != null) 'pvu3': pvu3,
      if (stocksu1 != null) 'stocksu1': stocksu1,
      if (stocksu2 != null) 'stocksu2': stocksu2,
      if (stocksu3 != null) 'stocksu3': stocksu3,
      if (sec != null) 'sec': sec,
      if (usec != null) 'usec': usec,
      if (cmup != null) 'cmup': cmup,
      if (dep != null) 'dep': dep,
      if (action != null) 'action': action,
      if (categorie != null) 'categorie': categorie,
      if (classification != null) 'classification': classification,
      if (emb != null) 'emb': emb,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ArticlesCompanion copyWith(
      {Value<String>? designation,
      Value<String?>? u1,
      Value<String?>? u2,
      Value<double?>? tu2u1,
      Value<String?>? u3,
      Value<double?>? tu3u2,
      Value<double?>? pvu1,
      Value<double?>? pvu2,
      Value<double?>? pvu3,
      Value<double?>? stocksu1,
      Value<double?>? stocksu2,
      Value<double?>? stocksu3,
      Value<String?>? sec,
      Value<double?>? usec,
      Value<double?>? cmup,
      Value<String?>? dep,
      Value<String?>? action,
      Value<String?>? categorie,
      Value<String?>? classification,
      Value<String?>? emb,
      Value<int>? rowid}) {
    return ArticlesCompanion(
      designation: designation ?? this.designation,
      u1: u1 ?? this.u1,
      u2: u2 ?? this.u2,
      tu2u1: tu2u1 ?? this.tu2u1,
      u3: u3 ?? this.u3,
      tu3u2: tu3u2 ?? this.tu3u2,
      pvu1: pvu1 ?? this.pvu1,
      pvu2: pvu2 ?? this.pvu2,
      pvu3: pvu3 ?? this.pvu3,
      stocksu1: stocksu1 ?? this.stocksu1,
      stocksu2: stocksu2 ?? this.stocksu2,
      stocksu3: stocksu3 ?? this.stocksu3,
      sec: sec ?? this.sec,
      usec: usec ?? this.usec,
      cmup: cmup ?? this.cmup,
      dep: dep ?? this.dep,
      action: action ?? this.action,
      categorie: categorie ?? this.categorie,
      classification: classification ?? this.classification,
      emb: emb ?? this.emb,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (designation.present) {
      map['designation'] = Variable<String>(designation.value);
    }
    if (u1.present) {
      map['u1'] = Variable<String>(u1.value);
    }
    if (u2.present) {
      map['u2'] = Variable<String>(u2.value);
    }
    if (tu2u1.present) {
      map['tu2u1'] = Variable<double>(tu2u1.value);
    }
    if (u3.present) {
      map['u3'] = Variable<String>(u3.value);
    }
    if (tu3u2.present) {
      map['tu3u2'] = Variable<double>(tu3u2.value);
    }
    if (pvu1.present) {
      map['pvu1'] = Variable<double>(pvu1.value);
    }
    if (pvu2.present) {
      map['pvu2'] = Variable<double>(pvu2.value);
    }
    if (pvu3.present) {
      map['pvu3'] = Variable<double>(pvu3.value);
    }
    if (stocksu1.present) {
      map['stocksu1'] = Variable<double>(stocksu1.value);
    }
    if (stocksu2.present) {
      map['stocksu2'] = Variable<double>(stocksu2.value);
    }
    if (stocksu3.present) {
      map['stocksu3'] = Variable<double>(stocksu3.value);
    }
    if (sec.present) {
      map['sec'] = Variable<String>(sec.value);
    }
    if (usec.present) {
      map['usec'] = Variable<double>(usec.value);
    }
    if (cmup.present) {
      map['cmup'] = Variable<double>(cmup.value);
    }
    if (dep.present) {
      map['dep'] = Variable<String>(dep.value);
    }
    if (action.present) {
      map['action'] = Variable<String>(action.value);
    }
    if (categorie.present) {
      map['categorie'] = Variable<String>(categorie.value);
    }
    if (classification.present) {
      map['classification'] = Variable<String>(classification.value);
    }
    if (emb.present) {
      map['emb'] = Variable<String>(emb.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ArticlesCompanion(')
          ..write('designation: $designation, ')
          ..write('u1: $u1, ')
          ..write('u2: $u2, ')
          ..write('tu2u1: $tu2u1, ')
          ..write('u3: $u3, ')
          ..write('tu3u2: $tu3u2, ')
          ..write('pvu1: $pvu1, ')
          ..write('pvu2: $pvu2, ')
          ..write('pvu3: $pvu3, ')
          ..write('stocksu1: $stocksu1, ')
          ..write('stocksu2: $stocksu2, ')
          ..write('stocksu3: $stocksu3, ')
          ..write('sec: $sec, ')
          ..write('usec: $usec, ')
          ..write('cmup: $cmup, ')
          ..write('dep: $dep, ')
          ..write('action: $action, ')
          ..write('categorie: $categorie, ')
          ..write('classification: $classification, ')
          ..write('emb: $emb, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $CltTable extends Clt with TableInfo<$CltTable, CltData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CltTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _rsocMeta = const VerificationMeta('rsoc');
  @override
  late final GeneratedColumn<String> rsoc = GeneratedColumn<String>(
      'rsoc', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _adrMeta = const VerificationMeta('adr');
  @override
  late final GeneratedColumn<String> adr = GeneratedColumn<String>(
      'adr', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 200),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _capitalMeta =
      const VerificationMeta('capital');
  @override
  late final GeneratedColumn<double> capital = GeneratedColumn<double>(
      'capital', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _rcsMeta = const VerificationMeta('rcs');
  @override
  late final GeneratedColumn<String> rcs = GeneratedColumn<String>(
      'rcs', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _nifMeta = const VerificationMeta('nif');
  @override
  late final GeneratedColumn<String> nif = GeneratedColumn<String>(
      'nif', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _statMeta = const VerificationMeta('stat');
  @override
  late final GeneratedColumn<String> stat = GeneratedColumn<String>(
      'stat', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _telMeta = const VerificationMeta('tel');
  @override
  late final GeneratedColumn<String> tel = GeneratedColumn<String>(
      'tel', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _portMeta = const VerificationMeta('port');
  @override
  late final GeneratedColumn<String> port = GeneratedColumn<String>(
      'port', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _emailMeta = const VerificationMeta('email');
  @override
  late final GeneratedColumn<String> email = GeneratedColumn<String>(
      'email', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _siteMeta = const VerificationMeta('site');
  @override
  late final GeneratedColumn<String> site = GeneratedColumn<String>(
      'site', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _faxMeta = const VerificationMeta('fax');
  @override
  late final GeneratedColumn<String> fax = GeneratedColumn<String>(
      'fax', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _telexMeta = const VerificationMeta('telex');
  @override
  late final GeneratedColumn<String> telex = GeneratedColumn<String>(
      'telex', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _soldesMeta = const VerificationMeta('soldes');
  @override
  late final GeneratedColumn<double> soldes = GeneratedColumn<double>(
      'soldes', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _datedernopMeta =
      const VerificationMeta('datedernop');
  @override
  late final GeneratedColumn<DateTime> datedernop = GeneratedColumn<DateTime>(
      'datedernop', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _delaiMeta = const VerificationMeta('delai');
  @override
  late final GeneratedColumn<int> delai = GeneratedColumn<int>(
      'delai', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _soldesaMeta =
      const VerificationMeta('soldesa');
  @override
  late final GeneratedColumn<double> soldesa = GeneratedColumn<double>(
      'soldesa', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _actionMeta = const VerificationMeta('action');
  @override
  late final GeneratedColumn<String> action = GeneratedColumn<String>(
      'action', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _commercialMeta =
      const VerificationMeta('commercial');
  @override
  late final GeneratedColumn<String> commercial = GeneratedColumn<String>(
      'commercial', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _plafonMeta = const VerificationMeta('plafon');
  @override
  late final GeneratedColumn<double> plafon = GeneratedColumn<double>(
      'plafon', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _tauxMeta = const VerificationMeta('taux');
  @override
  late final GeneratedColumn<double> taux = GeneratedColumn<double>(
      'taux', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _categorieMeta =
      const VerificationMeta('categorie');
  @override
  late final GeneratedColumn<String> categorie = GeneratedColumn<String>(
      'categorie', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _plafonblMeta =
      const VerificationMeta('plafonbl');
  @override
  late final GeneratedColumn<double> plafonbl = GeneratedColumn<double>(
      'plafonbl', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        rsoc,
        adr,
        capital,
        rcs,
        nif,
        stat,
        tel,
        port,
        email,
        site,
        fax,
        telex,
        soldes,
        datedernop,
        delai,
        soldesa,
        action,
        commercial,
        plafon,
        taux,
        categorie,
        plafonbl
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'clt';
  @override
  VerificationContext validateIntegrity(Insertable<CltData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('rsoc')) {
      context.handle(
          _rsocMeta, rsoc.isAcceptableOrUnknown(data['rsoc']!, _rsocMeta));
    } else if (isInserting) {
      context.missing(_rsocMeta);
    }
    if (data.containsKey('adr')) {
      context.handle(
          _adrMeta, adr.isAcceptableOrUnknown(data['adr']!, _adrMeta));
    }
    if (data.containsKey('capital')) {
      context.handle(_capitalMeta,
          capital.isAcceptableOrUnknown(data['capital']!, _capitalMeta));
    }
    if (data.containsKey('rcs')) {
      context.handle(
          _rcsMeta, rcs.isAcceptableOrUnknown(data['rcs']!, _rcsMeta));
    }
    if (data.containsKey('nif')) {
      context.handle(
          _nifMeta, nif.isAcceptableOrUnknown(data['nif']!, _nifMeta));
    }
    if (data.containsKey('stat')) {
      context.handle(
          _statMeta, stat.isAcceptableOrUnknown(data['stat']!, _statMeta));
    }
    if (data.containsKey('tel')) {
      context.handle(
          _telMeta, tel.isAcceptableOrUnknown(data['tel']!, _telMeta));
    }
    if (data.containsKey('port')) {
      context.handle(
          _portMeta, port.isAcceptableOrUnknown(data['port']!, _portMeta));
    }
    if (data.containsKey('email')) {
      context.handle(
          _emailMeta, email.isAcceptableOrUnknown(data['email']!, _emailMeta));
    }
    if (data.containsKey('site')) {
      context.handle(
          _siteMeta, site.isAcceptableOrUnknown(data['site']!, _siteMeta));
    }
    if (data.containsKey('fax')) {
      context.handle(
          _faxMeta, fax.isAcceptableOrUnknown(data['fax']!, _faxMeta));
    }
    if (data.containsKey('telex')) {
      context.handle(
          _telexMeta, telex.isAcceptableOrUnknown(data['telex']!, _telexMeta));
    }
    if (data.containsKey('soldes')) {
      context.handle(_soldesMeta,
          soldes.isAcceptableOrUnknown(data['soldes']!, _soldesMeta));
    }
    if (data.containsKey('datedernop')) {
      context.handle(
          _datedernopMeta,
          datedernop.isAcceptableOrUnknown(
              data['datedernop']!, _datedernopMeta));
    }
    if (data.containsKey('delai')) {
      context.handle(
          _delaiMeta, delai.isAcceptableOrUnknown(data['delai']!, _delaiMeta));
    }
    if (data.containsKey('soldesa')) {
      context.handle(_soldesaMeta,
          soldesa.isAcceptableOrUnknown(data['soldesa']!, _soldesaMeta));
    }
    if (data.containsKey('action')) {
      context.handle(_actionMeta,
          action.isAcceptableOrUnknown(data['action']!, _actionMeta));
    }
    if (data.containsKey('commercial')) {
      context.handle(
          _commercialMeta,
          commercial.isAcceptableOrUnknown(
              data['commercial']!, _commercialMeta));
    }
    if (data.containsKey('plafon')) {
      context.handle(_plafonMeta,
          plafon.isAcceptableOrUnknown(data['plafon']!, _plafonMeta));
    }
    if (data.containsKey('taux')) {
      context.handle(
          _tauxMeta, taux.isAcceptableOrUnknown(data['taux']!, _tauxMeta));
    }
    if (data.containsKey('categorie')) {
      context.handle(_categorieMeta,
          categorie.isAcceptableOrUnknown(data['categorie']!, _categorieMeta));
    }
    if (data.containsKey('plafonbl')) {
      context.handle(_plafonblMeta,
          plafonbl.isAcceptableOrUnknown(data['plafonbl']!, _plafonblMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {rsoc};
  @override
  CltData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CltData(
      rsoc: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}rsoc'])!,
      adr: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}adr']),
      capital: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}capital']),
      rcs: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}rcs']),
      nif: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}nif']),
      stat: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}stat']),
      tel: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tel']),
      port: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}port']),
      email: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}email']),
      site: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}site']),
      fax: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}fax']),
      telex: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}telex']),
      soldes: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}soldes']),
      datedernop: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}datedernop']),
      delai: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}delai']),
      soldesa: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}soldesa']),
      action: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}action']),
      commercial: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}commercial']),
      plafon: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}plafon']),
      taux: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}taux']),
      categorie: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}categorie']),
      plafonbl: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}plafonbl']),
    );
  }

  @override
  $CltTable createAlias(String alias) {
    return $CltTable(attachedDatabase, alias);
  }
}

class CltData extends DataClass implements Insertable<CltData> {
  final String rsoc;
  final String? adr;
  final double? capital;
  final String? rcs;
  final String? nif;
  final String? stat;
  final String? tel;
  final String? port;
  final String? email;
  final String? site;
  final String? fax;
  final String? telex;
  final double? soldes;
  final DateTime? datedernop;
  final int? delai;
  final double? soldesa;
  final String? action;
  final String? commercial;
  final double? plafon;
  final double? taux;
  final String? categorie;
  final double? plafonbl;
  const CltData(
      {required this.rsoc,
      this.adr,
      this.capital,
      this.rcs,
      this.nif,
      this.stat,
      this.tel,
      this.port,
      this.email,
      this.site,
      this.fax,
      this.telex,
      this.soldes,
      this.datedernop,
      this.delai,
      this.soldesa,
      this.action,
      this.commercial,
      this.plafon,
      this.taux,
      this.categorie,
      this.plafonbl});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['rsoc'] = Variable<String>(rsoc);
    if (!nullToAbsent || adr != null) {
      map['adr'] = Variable<String>(adr);
    }
    if (!nullToAbsent || capital != null) {
      map['capital'] = Variable<double>(capital);
    }
    if (!nullToAbsent || rcs != null) {
      map['rcs'] = Variable<String>(rcs);
    }
    if (!nullToAbsent || nif != null) {
      map['nif'] = Variable<String>(nif);
    }
    if (!nullToAbsent || stat != null) {
      map['stat'] = Variable<String>(stat);
    }
    if (!nullToAbsent || tel != null) {
      map['tel'] = Variable<String>(tel);
    }
    if (!nullToAbsent || port != null) {
      map['port'] = Variable<String>(port);
    }
    if (!nullToAbsent || email != null) {
      map['email'] = Variable<String>(email);
    }
    if (!nullToAbsent || site != null) {
      map['site'] = Variable<String>(site);
    }
    if (!nullToAbsent || fax != null) {
      map['fax'] = Variable<String>(fax);
    }
    if (!nullToAbsent || telex != null) {
      map['telex'] = Variable<String>(telex);
    }
    if (!nullToAbsent || soldes != null) {
      map['soldes'] = Variable<double>(soldes);
    }
    if (!nullToAbsent || datedernop != null) {
      map['datedernop'] = Variable<DateTime>(datedernop);
    }
    if (!nullToAbsent || delai != null) {
      map['delai'] = Variable<int>(delai);
    }
    if (!nullToAbsent || soldesa != null) {
      map['soldesa'] = Variable<double>(soldesa);
    }
    if (!nullToAbsent || action != null) {
      map['action'] = Variable<String>(action);
    }
    if (!nullToAbsent || commercial != null) {
      map['commercial'] = Variable<String>(commercial);
    }
    if (!nullToAbsent || plafon != null) {
      map['plafon'] = Variable<double>(plafon);
    }
    if (!nullToAbsent || taux != null) {
      map['taux'] = Variable<double>(taux);
    }
    if (!nullToAbsent || categorie != null) {
      map['categorie'] = Variable<String>(categorie);
    }
    if (!nullToAbsent || plafonbl != null) {
      map['plafonbl'] = Variable<double>(plafonbl);
    }
    return map;
  }

  CltCompanion toCompanion(bool nullToAbsent) {
    return CltCompanion(
      rsoc: Value(rsoc),
      adr: adr == null && nullToAbsent ? const Value.absent() : Value(adr),
      capital: capital == null && nullToAbsent
          ? const Value.absent()
          : Value(capital),
      rcs: rcs == null && nullToAbsent ? const Value.absent() : Value(rcs),
      nif: nif == null && nullToAbsent ? const Value.absent() : Value(nif),
      stat: stat == null && nullToAbsent ? const Value.absent() : Value(stat),
      tel: tel == null && nullToAbsent ? const Value.absent() : Value(tel),
      port: port == null && nullToAbsent ? const Value.absent() : Value(port),
      email:
          email == null && nullToAbsent ? const Value.absent() : Value(email),
      site: site == null && nullToAbsent ? const Value.absent() : Value(site),
      fax: fax == null && nullToAbsent ? const Value.absent() : Value(fax),
      telex:
          telex == null && nullToAbsent ? const Value.absent() : Value(telex),
      soldes:
          soldes == null && nullToAbsent ? const Value.absent() : Value(soldes),
      datedernop: datedernop == null && nullToAbsent
          ? const Value.absent()
          : Value(datedernop),
      delai:
          delai == null && nullToAbsent ? const Value.absent() : Value(delai),
      soldesa: soldesa == null && nullToAbsent
          ? const Value.absent()
          : Value(soldesa),
      action:
          action == null && nullToAbsent ? const Value.absent() : Value(action),
      commercial: commercial == null && nullToAbsent
          ? const Value.absent()
          : Value(commercial),
      plafon:
          plafon == null && nullToAbsent ? const Value.absent() : Value(plafon),
      taux: taux == null && nullToAbsent ? const Value.absent() : Value(taux),
      categorie: categorie == null && nullToAbsent
          ? const Value.absent()
          : Value(categorie),
      plafonbl: plafonbl == null && nullToAbsent
          ? const Value.absent()
          : Value(plafonbl),
    );
  }

  factory CltData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CltData(
      rsoc: serializer.fromJson<String>(json['rsoc']),
      adr: serializer.fromJson<String?>(json['adr']),
      capital: serializer.fromJson<double?>(json['capital']),
      rcs: serializer.fromJson<String?>(json['rcs']),
      nif: serializer.fromJson<String?>(json['nif']),
      stat: serializer.fromJson<String?>(json['stat']),
      tel: serializer.fromJson<String?>(json['tel']),
      port: serializer.fromJson<String?>(json['port']),
      email: serializer.fromJson<String?>(json['email']),
      site: serializer.fromJson<String?>(json['site']),
      fax: serializer.fromJson<String?>(json['fax']),
      telex: serializer.fromJson<String?>(json['telex']),
      soldes: serializer.fromJson<double?>(json['soldes']),
      datedernop: serializer.fromJson<DateTime?>(json['datedernop']),
      delai: serializer.fromJson<int?>(json['delai']),
      soldesa: serializer.fromJson<double?>(json['soldesa']),
      action: serializer.fromJson<String?>(json['action']),
      commercial: serializer.fromJson<String?>(json['commercial']),
      plafon: serializer.fromJson<double?>(json['plafon']),
      taux: serializer.fromJson<double?>(json['taux']),
      categorie: serializer.fromJson<String?>(json['categorie']),
      plafonbl: serializer.fromJson<double?>(json['plafonbl']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'rsoc': serializer.toJson<String>(rsoc),
      'adr': serializer.toJson<String?>(adr),
      'capital': serializer.toJson<double?>(capital),
      'rcs': serializer.toJson<String?>(rcs),
      'nif': serializer.toJson<String?>(nif),
      'stat': serializer.toJson<String?>(stat),
      'tel': serializer.toJson<String?>(tel),
      'port': serializer.toJson<String?>(port),
      'email': serializer.toJson<String?>(email),
      'site': serializer.toJson<String?>(site),
      'fax': serializer.toJson<String?>(fax),
      'telex': serializer.toJson<String?>(telex),
      'soldes': serializer.toJson<double?>(soldes),
      'datedernop': serializer.toJson<DateTime?>(datedernop),
      'delai': serializer.toJson<int?>(delai),
      'soldesa': serializer.toJson<double?>(soldesa),
      'action': serializer.toJson<String?>(action),
      'commercial': serializer.toJson<String?>(commercial),
      'plafon': serializer.toJson<double?>(plafon),
      'taux': serializer.toJson<double?>(taux),
      'categorie': serializer.toJson<String?>(categorie),
      'plafonbl': serializer.toJson<double?>(plafonbl),
    };
  }

  CltData copyWith(
          {String? rsoc,
          Value<String?> adr = const Value.absent(),
          Value<double?> capital = const Value.absent(),
          Value<String?> rcs = const Value.absent(),
          Value<String?> nif = const Value.absent(),
          Value<String?> stat = const Value.absent(),
          Value<String?> tel = const Value.absent(),
          Value<String?> port = const Value.absent(),
          Value<String?> email = const Value.absent(),
          Value<String?> site = const Value.absent(),
          Value<String?> fax = const Value.absent(),
          Value<String?> telex = const Value.absent(),
          Value<double?> soldes = const Value.absent(),
          Value<DateTime?> datedernop = const Value.absent(),
          Value<int?> delai = const Value.absent(),
          Value<double?> soldesa = const Value.absent(),
          Value<String?> action = const Value.absent(),
          Value<String?> commercial = const Value.absent(),
          Value<double?> plafon = const Value.absent(),
          Value<double?> taux = const Value.absent(),
          Value<String?> categorie = const Value.absent(),
          Value<double?> plafonbl = const Value.absent()}) =>
      CltData(
        rsoc: rsoc ?? this.rsoc,
        adr: adr.present ? adr.value : this.adr,
        capital: capital.present ? capital.value : this.capital,
        rcs: rcs.present ? rcs.value : this.rcs,
        nif: nif.present ? nif.value : this.nif,
        stat: stat.present ? stat.value : this.stat,
        tel: tel.present ? tel.value : this.tel,
        port: port.present ? port.value : this.port,
        email: email.present ? email.value : this.email,
        site: site.present ? site.value : this.site,
        fax: fax.present ? fax.value : this.fax,
        telex: telex.present ? telex.value : this.telex,
        soldes: soldes.present ? soldes.value : this.soldes,
        datedernop: datedernop.present ? datedernop.value : this.datedernop,
        delai: delai.present ? delai.value : this.delai,
        soldesa: soldesa.present ? soldesa.value : this.soldesa,
        action: action.present ? action.value : this.action,
        commercial: commercial.present ? commercial.value : this.commercial,
        plafon: plafon.present ? plafon.value : this.plafon,
        taux: taux.present ? taux.value : this.taux,
        categorie: categorie.present ? categorie.value : this.categorie,
        plafonbl: plafonbl.present ? plafonbl.value : this.plafonbl,
      );
  CltData copyWithCompanion(CltCompanion data) {
    return CltData(
      rsoc: data.rsoc.present ? data.rsoc.value : this.rsoc,
      adr: data.adr.present ? data.adr.value : this.adr,
      capital: data.capital.present ? data.capital.value : this.capital,
      rcs: data.rcs.present ? data.rcs.value : this.rcs,
      nif: data.nif.present ? data.nif.value : this.nif,
      stat: data.stat.present ? data.stat.value : this.stat,
      tel: data.tel.present ? data.tel.value : this.tel,
      port: data.port.present ? data.port.value : this.port,
      email: data.email.present ? data.email.value : this.email,
      site: data.site.present ? data.site.value : this.site,
      fax: data.fax.present ? data.fax.value : this.fax,
      telex: data.telex.present ? data.telex.value : this.telex,
      soldes: data.soldes.present ? data.soldes.value : this.soldes,
      datedernop:
          data.datedernop.present ? data.datedernop.value : this.datedernop,
      delai: data.delai.present ? data.delai.value : this.delai,
      soldesa: data.soldesa.present ? data.soldesa.value : this.soldesa,
      action: data.action.present ? data.action.value : this.action,
      commercial:
          data.commercial.present ? data.commercial.value : this.commercial,
      plafon: data.plafon.present ? data.plafon.value : this.plafon,
      taux: data.taux.present ? data.taux.value : this.taux,
      categorie: data.categorie.present ? data.categorie.value : this.categorie,
      plafonbl: data.plafonbl.present ? data.plafonbl.value : this.plafonbl,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CltData(')
          ..write('rsoc: $rsoc, ')
          ..write('adr: $adr, ')
          ..write('capital: $capital, ')
          ..write('rcs: $rcs, ')
          ..write('nif: $nif, ')
          ..write('stat: $stat, ')
          ..write('tel: $tel, ')
          ..write('port: $port, ')
          ..write('email: $email, ')
          ..write('site: $site, ')
          ..write('fax: $fax, ')
          ..write('telex: $telex, ')
          ..write('soldes: $soldes, ')
          ..write('datedernop: $datedernop, ')
          ..write('delai: $delai, ')
          ..write('soldesa: $soldesa, ')
          ..write('action: $action, ')
          ..write('commercial: $commercial, ')
          ..write('plafon: $plafon, ')
          ..write('taux: $taux, ')
          ..write('categorie: $categorie, ')
          ..write('plafonbl: $plafonbl')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        rsoc,
        adr,
        capital,
        rcs,
        nif,
        stat,
        tel,
        port,
        email,
        site,
        fax,
        telex,
        soldes,
        datedernop,
        delai,
        soldesa,
        action,
        commercial,
        plafon,
        taux,
        categorie,
        plafonbl
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CltData &&
          other.rsoc == this.rsoc &&
          other.adr == this.adr &&
          other.capital == this.capital &&
          other.rcs == this.rcs &&
          other.nif == this.nif &&
          other.stat == this.stat &&
          other.tel == this.tel &&
          other.port == this.port &&
          other.email == this.email &&
          other.site == this.site &&
          other.fax == this.fax &&
          other.telex == this.telex &&
          other.soldes == this.soldes &&
          other.datedernop == this.datedernop &&
          other.delai == this.delai &&
          other.soldesa == this.soldesa &&
          other.action == this.action &&
          other.commercial == this.commercial &&
          other.plafon == this.plafon &&
          other.taux == this.taux &&
          other.categorie == this.categorie &&
          other.plafonbl == this.plafonbl);
}

class CltCompanion extends UpdateCompanion<CltData> {
  final Value<String> rsoc;
  final Value<String?> adr;
  final Value<double?> capital;
  final Value<String?> rcs;
  final Value<String?> nif;
  final Value<String?> stat;
  final Value<String?> tel;
  final Value<String?> port;
  final Value<String?> email;
  final Value<String?> site;
  final Value<String?> fax;
  final Value<String?> telex;
  final Value<double?> soldes;
  final Value<DateTime?> datedernop;
  final Value<int?> delai;
  final Value<double?> soldesa;
  final Value<String?> action;
  final Value<String?> commercial;
  final Value<double?> plafon;
  final Value<double?> taux;
  final Value<String?> categorie;
  final Value<double?> plafonbl;
  final Value<int> rowid;
  const CltCompanion({
    this.rsoc = const Value.absent(),
    this.adr = const Value.absent(),
    this.capital = const Value.absent(),
    this.rcs = const Value.absent(),
    this.nif = const Value.absent(),
    this.stat = const Value.absent(),
    this.tel = const Value.absent(),
    this.port = const Value.absent(),
    this.email = const Value.absent(),
    this.site = const Value.absent(),
    this.fax = const Value.absent(),
    this.telex = const Value.absent(),
    this.soldes = const Value.absent(),
    this.datedernop = const Value.absent(),
    this.delai = const Value.absent(),
    this.soldesa = const Value.absent(),
    this.action = const Value.absent(),
    this.commercial = const Value.absent(),
    this.plafon = const Value.absent(),
    this.taux = const Value.absent(),
    this.categorie = const Value.absent(),
    this.plafonbl = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  CltCompanion.insert({
    required String rsoc,
    this.adr = const Value.absent(),
    this.capital = const Value.absent(),
    this.rcs = const Value.absent(),
    this.nif = const Value.absent(),
    this.stat = const Value.absent(),
    this.tel = const Value.absent(),
    this.port = const Value.absent(),
    this.email = const Value.absent(),
    this.site = const Value.absent(),
    this.fax = const Value.absent(),
    this.telex = const Value.absent(),
    this.soldes = const Value.absent(),
    this.datedernop = const Value.absent(),
    this.delai = const Value.absent(),
    this.soldesa = const Value.absent(),
    this.action = const Value.absent(),
    this.commercial = const Value.absent(),
    this.plafon = const Value.absent(),
    this.taux = const Value.absent(),
    this.categorie = const Value.absent(),
    this.plafonbl = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : rsoc = Value(rsoc);
  static Insertable<CltData> custom({
    Expression<String>? rsoc,
    Expression<String>? adr,
    Expression<double>? capital,
    Expression<String>? rcs,
    Expression<String>? nif,
    Expression<String>? stat,
    Expression<String>? tel,
    Expression<String>? port,
    Expression<String>? email,
    Expression<String>? site,
    Expression<String>? fax,
    Expression<String>? telex,
    Expression<double>? soldes,
    Expression<DateTime>? datedernop,
    Expression<int>? delai,
    Expression<double>? soldesa,
    Expression<String>? action,
    Expression<String>? commercial,
    Expression<double>? plafon,
    Expression<double>? taux,
    Expression<String>? categorie,
    Expression<double>? plafonbl,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (rsoc != null) 'rsoc': rsoc,
      if (adr != null) 'adr': adr,
      if (capital != null) 'capital': capital,
      if (rcs != null) 'rcs': rcs,
      if (nif != null) 'nif': nif,
      if (stat != null) 'stat': stat,
      if (tel != null) 'tel': tel,
      if (port != null) 'port': port,
      if (email != null) 'email': email,
      if (site != null) 'site': site,
      if (fax != null) 'fax': fax,
      if (telex != null) 'telex': telex,
      if (soldes != null) 'soldes': soldes,
      if (datedernop != null) 'datedernop': datedernop,
      if (delai != null) 'delai': delai,
      if (soldesa != null) 'soldesa': soldesa,
      if (action != null) 'action': action,
      if (commercial != null) 'commercial': commercial,
      if (plafon != null) 'plafon': plafon,
      if (taux != null) 'taux': taux,
      if (categorie != null) 'categorie': categorie,
      if (plafonbl != null) 'plafonbl': plafonbl,
      if (rowid != null) 'rowid': rowid,
    });
  }

  CltCompanion copyWith(
      {Value<String>? rsoc,
      Value<String?>? adr,
      Value<double?>? capital,
      Value<String?>? rcs,
      Value<String?>? nif,
      Value<String?>? stat,
      Value<String?>? tel,
      Value<String?>? port,
      Value<String?>? email,
      Value<String?>? site,
      Value<String?>? fax,
      Value<String?>? telex,
      Value<double?>? soldes,
      Value<DateTime?>? datedernop,
      Value<int?>? delai,
      Value<double?>? soldesa,
      Value<String?>? action,
      Value<String?>? commercial,
      Value<double?>? plafon,
      Value<double?>? taux,
      Value<String?>? categorie,
      Value<double?>? plafonbl,
      Value<int>? rowid}) {
    return CltCompanion(
      rsoc: rsoc ?? this.rsoc,
      adr: adr ?? this.adr,
      capital: capital ?? this.capital,
      rcs: rcs ?? this.rcs,
      nif: nif ?? this.nif,
      stat: stat ?? this.stat,
      tel: tel ?? this.tel,
      port: port ?? this.port,
      email: email ?? this.email,
      site: site ?? this.site,
      fax: fax ?? this.fax,
      telex: telex ?? this.telex,
      soldes: soldes ?? this.soldes,
      datedernop: datedernop ?? this.datedernop,
      delai: delai ?? this.delai,
      soldesa: soldesa ?? this.soldesa,
      action: action ?? this.action,
      commercial: commercial ?? this.commercial,
      plafon: plafon ?? this.plafon,
      taux: taux ?? this.taux,
      categorie: categorie ?? this.categorie,
      plafonbl: plafonbl ?? this.plafonbl,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (rsoc.present) {
      map['rsoc'] = Variable<String>(rsoc.value);
    }
    if (adr.present) {
      map['adr'] = Variable<String>(adr.value);
    }
    if (capital.present) {
      map['capital'] = Variable<double>(capital.value);
    }
    if (rcs.present) {
      map['rcs'] = Variable<String>(rcs.value);
    }
    if (nif.present) {
      map['nif'] = Variable<String>(nif.value);
    }
    if (stat.present) {
      map['stat'] = Variable<String>(stat.value);
    }
    if (tel.present) {
      map['tel'] = Variable<String>(tel.value);
    }
    if (port.present) {
      map['port'] = Variable<String>(port.value);
    }
    if (email.present) {
      map['email'] = Variable<String>(email.value);
    }
    if (site.present) {
      map['site'] = Variable<String>(site.value);
    }
    if (fax.present) {
      map['fax'] = Variable<String>(fax.value);
    }
    if (telex.present) {
      map['telex'] = Variable<String>(telex.value);
    }
    if (soldes.present) {
      map['soldes'] = Variable<double>(soldes.value);
    }
    if (datedernop.present) {
      map['datedernop'] = Variable<DateTime>(datedernop.value);
    }
    if (delai.present) {
      map['delai'] = Variable<int>(delai.value);
    }
    if (soldesa.present) {
      map['soldesa'] = Variable<double>(soldesa.value);
    }
    if (action.present) {
      map['action'] = Variable<String>(action.value);
    }
    if (commercial.present) {
      map['commercial'] = Variable<String>(commercial.value);
    }
    if (plafon.present) {
      map['plafon'] = Variable<double>(plafon.value);
    }
    if (taux.present) {
      map['taux'] = Variable<double>(taux.value);
    }
    if (categorie.present) {
      map['categorie'] = Variable<String>(categorie.value);
    }
    if (plafonbl.present) {
      map['plafonbl'] = Variable<double>(plafonbl.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CltCompanion(')
          ..write('rsoc: $rsoc, ')
          ..write('adr: $adr, ')
          ..write('capital: $capital, ')
          ..write('rcs: $rcs, ')
          ..write('nif: $nif, ')
          ..write('stat: $stat, ')
          ..write('tel: $tel, ')
          ..write('port: $port, ')
          ..write('email: $email, ')
          ..write('site: $site, ')
          ..write('fax: $fax, ')
          ..write('telex: $telex, ')
          ..write('soldes: $soldes, ')
          ..write('datedernop: $datedernop, ')
          ..write('delai: $delai, ')
          ..write('soldesa: $soldesa, ')
          ..write('action: $action, ')
          ..write('commercial: $commercial, ')
          ..write('plafon: $plafon, ')
          ..write('taux: $taux, ')
          ..write('categorie: $categorie, ')
          ..write('plafonbl: $plafonbl, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $FrnsTable extends Frns with TableInfo<$FrnsTable, Frn> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FrnsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _rsocMeta = const VerificationMeta('rsoc');
  @override
  late final GeneratedColumn<String> rsoc = GeneratedColumn<String>(
      'rsoc', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _adrMeta = const VerificationMeta('adr');
  @override
  late final GeneratedColumn<String> adr = GeneratedColumn<String>(
      'adr', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 200),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _capitalMeta =
      const VerificationMeta('capital');
  @override
  late final GeneratedColumn<double> capital = GeneratedColumn<double>(
      'capital', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _rcsMeta = const VerificationMeta('rcs');
  @override
  late final GeneratedColumn<String> rcs = GeneratedColumn<String>(
      'rcs', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _nifMeta = const VerificationMeta('nif');
  @override
  late final GeneratedColumn<String> nif = GeneratedColumn<String>(
      'nif', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _statMeta = const VerificationMeta('stat');
  @override
  late final GeneratedColumn<String> stat = GeneratedColumn<String>(
      'stat', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _telMeta = const VerificationMeta('tel');
  @override
  late final GeneratedColumn<String> tel = GeneratedColumn<String>(
      'tel', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _portMeta = const VerificationMeta('port');
  @override
  late final GeneratedColumn<String> port = GeneratedColumn<String>(
      'port', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _emailMeta = const VerificationMeta('email');
  @override
  late final GeneratedColumn<String> email = GeneratedColumn<String>(
      'email', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _siteMeta = const VerificationMeta('site');
  @override
  late final GeneratedColumn<String> site = GeneratedColumn<String>(
      'site', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _faxMeta = const VerificationMeta('fax');
  @override
  late final GeneratedColumn<String> fax = GeneratedColumn<String>(
      'fax', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _telexMeta = const VerificationMeta('telex');
  @override
  late final GeneratedColumn<String> telex = GeneratedColumn<String>(
      'telex', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _soldesMeta = const VerificationMeta('soldes');
  @override
  late final GeneratedColumn<double> soldes = GeneratedColumn<double>(
      'soldes', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _datedernopMeta =
      const VerificationMeta('datedernop');
  @override
  late final GeneratedColumn<DateTime> datedernop = GeneratedColumn<DateTime>(
      'datedernop', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _delaiMeta = const VerificationMeta('delai');
  @override
  late final GeneratedColumn<int> delai = GeneratedColumn<int>(
      'delai', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _soldesaMeta =
      const VerificationMeta('soldesa');
  @override
  late final GeneratedColumn<double> soldesa = GeneratedColumn<double>(
      'soldesa', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _actionMeta = const VerificationMeta('action');
  @override
  late final GeneratedColumn<String> action = GeneratedColumn<String>(
      'action', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        rsoc,
        adr,
        capital,
        rcs,
        nif,
        stat,
        tel,
        port,
        email,
        site,
        fax,
        telex,
        soldes,
        datedernop,
        delai,
        soldesa,
        action
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'frns';
  @override
  VerificationContext validateIntegrity(Insertable<Frn> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('rsoc')) {
      context.handle(
          _rsocMeta, rsoc.isAcceptableOrUnknown(data['rsoc']!, _rsocMeta));
    } else if (isInserting) {
      context.missing(_rsocMeta);
    }
    if (data.containsKey('adr')) {
      context.handle(
          _adrMeta, adr.isAcceptableOrUnknown(data['adr']!, _adrMeta));
    }
    if (data.containsKey('capital')) {
      context.handle(_capitalMeta,
          capital.isAcceptableOrUnknown(data['capital']!, _capitalMeta));
    }
    if (data.containsKey('rcs')) {
      context.handle(
          _rcsMeta, rcs.isAcceptableOrUnknown(data['rcs']!, _rcsMeta));
    }
    if (data.containsKey('nif')) {
      context.handle(
          _nifMeta, nif.isAcceptableOrUnknown(data['nif']!, _nifMeta));
    }
    if (data.containsKey('stat')) {
      context.handle(
          _statMeta, stat.isAcceptableOrUnknown(data['stat']!, _statMeta));
    }
    if (data.containsKey('tel')) {
      context.handle(
          _telMeta, tel.isAcceptableOrUnknown(data['tel']!, _telMeta));
    }
    if (data.containsKey('port')) {
      context.handle(
          _portMeta, port.isAcceptableOrUnknown(data['port']!, _portMeta));
    }
    if (data.containsKey('email')) {
      context.handle(
          _emailMeta, email.isAcceptableOrUnknown(data['email']!, _emailMeta));
    }
    if (data.containsKey('site')) {
      context.handle(
          _siteMeta, site.isAcceptableOrUnknown(data['site']!, _siteMeta));
    }
    if (data.containsKey('fax')) {
      context.handle(
          _faxMeta, fax.isAcceptableOrUnknown(data['fax']!, _faxMeta));
    }
    if (data.containsKey('telex')) {
      context.handle(
          _telexMeta, telex.isAcceptableOrUnknown(data['telex']!, _telexMeta));
    }
    if (data.containsKey('soldes')) {
      context.handle(_soldesMeta,
          soldes.isAcceptableOrUnknown(data['soldes']!, _soldesMeta));
    }
    if (data.containsKey('datedernop')) {
      context.handle(
          _datedernopMeta,
          datedernop.isAcceptableOrUnknown(
              data['datedernop']!, _datedernopMeta));
    }
    if (data.containsKey('delai')) {
      context.handle(
          _delaiMeta, delai.isAcceptableOrUnknown(data['delai']!, _delaiMeta));
    }
    if (data.containsKey('soldesa')) {
      context.handle(_soldesaMeta,
          soldesa.isAcceptableOrUnknown(data['soldesa']!, _soldesaMeta));
    }
    if (data.containsKey('action')) {
      context.handle(_actionMeta,
          action.isAcceptableOrUnknown(data['action']!, _actionMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {rsoc};
  @override
  Frn map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Frn(
      rsoc: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}rsoc'])!,
      adr: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}adr']),
      capital: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}capital']),
      rcs: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}rcs']),
      nif: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}nif']),
      stat: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}stat']),
      tel: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tel']),
      port: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}port']),
      email: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}email']),
      site: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}site']),
      fax: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}fax']),
      telex: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}telex']),
      soldes: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}soldes']),
      datedernop: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}datedernop']),
      delai: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}delai']),
      soldesa: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}soldesa']),
      action: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}action']),
    );
  }

  @override
  $FrnsTable createAlias(String alias) {
    return $FrnsTable(attachedDatabase, alias);
  }
}

class Frn extends DataClass implements Insertable<Frn> {
  final String rsoc;
  final String? adr;
  final double? capital;
  final String? rcs;
  final String? nif;
  final String? stat;
  final String? tel;
  final String? port;
  final String? email;
  final String? site;
  final String? fax;
  final String? telex;
  final double? soldes;
  final DateTime? datedernop;
  final int? delai;
  final double? soldesa;
  final String? action;
  const Frn(
      {required this.rsoc,
      this.adr,
      this.capital,
      this.rcs,
      this.nif,
      this.stat,
      this.tel,
      this.port,
      this.email,
      this.site,
      this.fax,
      this.telex,
      this.soldes,
      this.datedernop,
      this.delai,
      this.soldesa,
      this.action});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['rsoc'] = Variable<String>(rsoc);
    if (!nullToAbsent || adr != null) {
      map['adr'] = Variable<String>(adr);
    }
    if (!nullToAbsent || capital != null) {
      map['capital'] = Variable<double>(capital);
    }
    if (!nullToAbsent || rcs != null) {
      map['rcs'] = Variable<String>(rcs);
    }
    if (!nullToAbsent || nif != null) {
      map['nif'] = Variable<String>(nif);
    }
    if (!nullToAbsent || stat != null) {
      map['stat'] = Variable<String>(stat);
    }
    if (!nullToAbsent || tel != null) {
      map['tel'] = Variable<String>(tel);
    }
    if (!nullToAbsent || port != null) {
      map['port'] = Variable<String>(port);
    }
    if (!nullToAbsent || email != null) {
      map['email'] = Variable<String>(email);
    }
    if (!nullToAbsent || site != null) {
      map['site'] = Variable<String>(site);
    }
    if (!nullToAbsent || fax != null) {
      map['fax'] = Variable<String>(fax);
    }
    if (!nullToAbsent || telex != null) {
      map['telex'] = Variable<String>(telex);
    }
    if (!nullToAbsent || soldes != null) {
      map['soldes'] = Variable<double>(soldes);
    }
    if (!nullToAbsent || datedernop != null) {
      map['datedernop'] = Variable<DateTime>(datedernop);
    }
    if (!nullToAbsent || delai != null) {
      map['delai'] = Variable<int>(delai);
    }
    if (!nullToAbsent || soldesa != null) {
      map['soldesa'] = Variable<double>(soldesa);
    }
    if (!nullToAbsent || action != null) {
      map['action'] = Variable<String>(action);
    }
    return map;
  }

  FrnsCompanion toCompanion(bool nullToAbsent) {
    return FrnsCompanion(
      rsoc: Value(rsoc),
      adr: adr == null && nullToAbsent ? const Value.absent() : Value(adr),
      capital: capital == null && nullToAbsent
          ? const Value.absent()
          : Value(capital),
      rcs: rcs == null && nullToAbsent ? const Value.absent() : Value(rcs),
      nif: nif == null && nullToAbsent ? const Value.absent() : Value(nif),
      stat: stat == null && nullToAbsent ? const Value.absent() : Value(stat),
      tel: tel == null && nullToAbsent ? const Value.absent() : Value(tel),
      port: port == null && nullToAbsent ? const Value.absent() : Value(port),
      email:
          email == null && nullToAbsent ? const Value.absent() : Value(email),
      site: site == null && nullToAbsent ? const Value.absent() : Value(site),
      fax: fax == null && nullToAbsent ? const Value.absent() : Value(fax),
      telex:
          telex == null && nullToAbsent ? const Value.absent() : Value(telex),
      soldes:
          soldes == null && nullToAbsent ? const Value.absent() : Value(soldes),
      datedernop: datedernop == null && nullToAbsent
          ? const Value.absent()
          : Value(datedernop),
      delai:
          delai == null && nullToAbsent ? const Value.absent() : Value(delai),
      soldesa: soldesa == null && nullToAbsent
          ? const Value.absent()
          : Value(soldesa),
      action:
          action == null && nullToAbsent ? const Value.absent() : Value(action),
    );
  }

  factory Frn.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Frn(
      rsoc: serializer.fromJson<String>(json['rsoc']),
      adr: serializer.fromJson<String?>(json['adr']),
      capital: serializer.fromJson<double?>(json['capital']),
      rcs: serializer.fromJson<String?>(json['rcs']),
      nif: serializer.fromJson<String?>(json['nif']),
      stat: serializer.fromJson<String?>(json['stat']),
      tel: serializer.fromJson<String?>(json['tel']),
      port: serializer.fromJson<String?>(json['port']),
      email: serializer.fromJson<String?>(json['email']),
      site: serializer.fromJson<String?>(json['site']),
      fax: serializer.fromJson<String?>(json['fax']),
      telex: serializer.fromJson<String?>(json['telex']),
      soldes: serializer.fromJson<double?>(json['soldes']),
      datedernop: serializer.fromJson<DateTime?>(json['datedernop']),
      delai: serializer.fromJson<int?>(json['delai']),
      soldesa: serializer.fromJson<double?>(json['soldesa']),
      action: serializer.fromJson<String?>(json['action']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'rsoc': serializer.toJson<String>(rsoc),
      'adr': serializer.toJson<String?>(adr),
      'capital': serializer.toJson<double?>(capital),
      'rcs': serializer.toJson<String?>(rcs),
      'nif': serializer.toJson<String?>(nif),
      'stat': serializer.toJson<String?>(stat),
      'tel': serializer.toJson<String?>(tel),
      'port': serializer.toJson<String?>(port),
      'email': serializer.toJson<String?>(email),
      'site': serializer.toJson<String?>(site),
      'fax': serializer.toJson<String?>(fax),
      'telex': serializer.toJson<String?>(telex),
      'soldes': serializer.toJson<double?>(soldes),
      'datedernop': serializer.toJson<DateTime?>(datedernop),
      'delai': serializer.toJson<int?>(delai),
      'soldesa': serializer.toJson<double?>(soldesa),
      'action': serializer.toJson<String?>(action),
    };
  }

  Frn copyWith(
          {String? rsoc,
          Value<String?> adr = const Value.absent(),
          Value<double?> capital = const Value.absent(),
          Value<String?> rcs = const Value.absent(),
          Value<String?> nif = const Value.absent(),
          Value<String?> stat = const Value.absent(),
          Value<String?> tel = const Value.absent(),
          Value<String?> port = const Value.absent(),
          Value<String?> email = const Value.absent(),
          Value<String?> site = const Value.absent(),
          Value<String?> fax = const Value.absent(),
          Value<String?> telex = const Value.absent(),
          Value<double?> soldes = const Value.absent(),
          Value<DateTime?> datedernop = const Value.absent(),
          Value<int?> delai = const Value.absent(),
          Value<double?> soldesa = const Value.absent(),
          Value<String?> action = const Value.absent()}) =>
      Frn(
        rsoc: rsoc ?? this.rsoc,
        adr: adr.present ? adr.value : this.adr,
        capital: capital.present ? capital.value : this.capital,
        rcs: rcs.present ? rcs.value : this.rcs,
        nif: nif.present ? nif.value : this.nif,
        stat: stat.present ? stat.value : this.stat,
        tel: tel.present ? tel.value : this.tel,
        port: port.present ? port.value : this.port,
        email: email.present ? email.value : this.email,
        site: site.present ? site.value : this.site,
        fax: fax.present ? fax.value : this.fax,
        telex: telex.present ? telex.value : this.telex,
        soldes: soldes.present ? soldes.value : this.soldes,
        datedernop: datedernop.present ? datedernop.value : this.datedernop,
        delai: delai.present ? delai.value : this.delai,
        soldesa: soldesa.present ? soldesa.value : this.soldesa,
        action: action.present ? action.value : this.action,
      );
  Frn copyWithCompanion(FrnsCompanion data) {
    return Frn(
      rsoc: data.rsoc.present ? data.rsoc.value : this.rsoc,
      adr: data.adr.present ? data.adr.value : this.adr,
      capital: data.capital.present ? data.capital.value : this.capital,
      rcs: data.rcs.present ? data.rcs.value : this.rcs,
      nif: data.nif.present ? data.nif.value : this.nif,
      stat: data.stat.present ? data.stat.value : this.stat,
      tel: data.tel.present ? data.tel.value : this.tel,
      port: data.port.present ? data.port.value : this.port,
      email: data.email.present ? data.email.value : this.email,
      site: data.site.present ? data.site.value : this.site,
      fax: data.fax.present ? data.fax.value : this.fax,
      telex: data.telex.present ? data.telex.value : this.telex,
      soldes: data.soldes.present ? data.soldes.value : this.soldes,
      datedernop:
          data.datedernop.present ? data.datedernop.value : this.datedernop,
      delai: data.delai.present ? data.delai.value : this.delai,
      soldesa: data.soldesa.present ? data.soldesa.value : this.soldesa,
      action: data.action.present ? data.action.value : this.action,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Frn(')
          ..write('rsoc: $rsoc, ')
          ..write('adr: $adr, ')
          ..write('capital: $capital, ')
          ..write('rcs: $rcs, ')
          ..write('nif: $nif, ')
          ..write('stat: $stat, ')
          ..write('tel: $tel, ')
          ..write('port: $port, ')
          ..write('email: $email, ')
          ..write('site: $site, ')
          ..write('fax: $fax, ')
          ..write('telex: $telex, ')
          ..write('soldes: $soldes, ')
          ..write('datedernop: $datedernop, ')
          ..write('delai: $delai, ')
          ..write('soldesa: $soldesa, ')
          ..write('action: $action')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(rsoc, adr, capital, rcs, nif, stat, tel, port,
      email, site, fax, telex, soldes, datedernop, delai, soldesa, action);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Frn &&
          other.rsoc == this.rsoc &&
          other.adr == this.adr &&
          other.capital == this.capital &&
          other.rcs == this.rcs &&
          other.nif == this.nif &&
          other.stat == this.stat &&
          other.tel == this.tel &&
          other.port == this.port &&
          other.email == this.email &&
          other.site == this.site &&
          other.fax == this.fax &&
          other.telex == this.telex &&
          other.soldes == this.soldes &&
          other.datedernop == this.datedernop &&
          other.delai == this.delai &&
          other.soldesa == this.soldesa &&
          other.action == this.action);
}

class FrnsCompanion extends UpdateCompanion<Frn> {
  final Value<String> rsoc;
  final Value<String?> adr;
  final Value<double?> capital;
  final Value<String?> rcs;
  final Value<String?> nif;
  final Value<String?> stat;
  final Value<String?> tel;
  final Value<String?> port;
  final Value<String?> email;
  final Value<String?> site;
  final Value<String?> fax;
  final Value<String?> telex;
  final Value<double?> soldes;
  final Value<DateTime?> datedernop;
  final Value<int?> delai;
  final Value<double?> soldesa;
  final Value<String?> action;
  final Value<int> rowid;
  const FrnsCompanion({
    this.rsoc = const Value.absent(),
    this.adr = const Value.absent(),
    this.capital = const Value.absent(),
    this.rcs = const Value.absent(),
    this.nif = const Value.absent(),
    this.stat = const Value.absent(),
    this.tel = const Value.absent(),
    this.port = const Value.absent(),
    this.email = const Value.absent(),
    this.site = const Value.absent(),
    this.fax = const Value.absent(),
    this.telex = const Value.absent(),
    this.soldes = const Value.absent(),
    this.datedernop = const Value.absent(),
    this.delai = const Value.absent(),
    this.soldesa = const Value.absent(),
    this.action = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  FrnsCompanion.insert({
    required String rsoc,
    this.adr = const Value.absent(),
    this.capital = const Value.absent(),
    this.rcs = const Value.absent(),
    this.nif = const Value.absent(),
    this.stat = const Value.absent(),
    this.tel = const Value.absent(),
    this.port = const Value.absent(),
    this.email = const Value.absent(),
    this.site = const Value.absent(),
    this.fax = const Value.absent(),
    this.telex = const Value.absent(),
    this.soldes = const Value.absent(),
    this.datedernop = const Value.absent(),
    this.delai = const Value.absent(),
    this.soldesa = const Value.absent(),
    this.action = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : rsoc = Value(rsoc);
  static Insertable<Frn> custom({
    Expression<String>? rsoc,
    Expression<String>? adr,
    Expression<double>? capital,
    Expression<String>? rcs,
    Expression<String>? nif,
    Expression<String>? stat,
    Expression<String>? tel,
    Expression<String>? port,
    Expression<String>? email,
    Expression<String>? site,
    Expression<String>? fax,
    Expression<String>? telex,
    Expression<double>? soldes,
    Expression<DateTime>? datedernop,
    Expression<int>? delai,
    Expression<double>? soldesa,
    Expression<String>? action,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (rsoc != null) 'rsoc': rsoc,
      if (adr != null) 'adr': adr,
      if (capital != null) 'capital': capital,
      if (rcs != null) 'rcs': rcs,
      if (nif != null) 'nif': nif,
      if (stat != null) 'stat': stat,
      if (tel != null) 'tel': tel,
      if (port != null) 'port': port,
      if (email != null) 'email': email,
      if (site != null) 'site': site,
      if (fax != null) 'fax': fax,
      if (telex != null) 'telex': telex,
      if (soldes != null) 'soldes': soldes,
      if (datedernop != null) 'datedernop': datedernop,
      if (delai != null) 'delai': delai,
      if (soldesa != null) 'soldesa': soldesa,
      if (action != null) 'action': action,
      if (rowid != null) 'rowid': rowid,
    });
  }

  FrnsCompanion copyWith(
      {Value<String>? rsoc,
      Value<String?>? adr,
      Value<double?>? capital,
      Value<String?>? rcs,
      Value<String?>? nif,
      Value<String?>? stat,
      Value<String?>? tel,
      Value<String?>? port,
      Value<String?>? email,
      Value<String?>? site,
      Value<String?>? fax,
      Value<String?>? telex,
      Value<double?>? soldes,
      Value<DateTime?>? datedernop,
      Value<int?>? delai,
      Value<double?>? soldesa,
      Value<String?>? action,
      Value<int>? rowid}) {
    return FrnsCompanion(
      rsoc: rsoc ?? this.rsoc,
      adr: adr ?? this.adr,
      capital: capital ?? this.capital,
      rcs: rcs ?? this.rcs,
      nif: nif ?? this.nif,
      stat: stat ?? this.stat,
      tel: tel ?? this.tel,
      port: port ?? this.port,
      email: email ?? this.email,
      site: site ?? this.site,
      fax: fax ?? this.fax,
      telex: telex ?? this.telex,
      soldes: soldes ?? this.soldes,
      datedernop: datedernop ?? this.datedernop,
      delai: delai ?? this.delai,
      soldesa: soldesa ?? this.soldesa,
      action: action ?? this.action,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (rsoc.present) {
      map['rsoc'] = Variable<String>(rsoc.value);
    }
    if (adr.present) {
      map['adr'] = Variable<String>(adr.value);
    }
    if (capital.present) {
      map['capital'] = Variable<double>(capital.value);
    }
    if (rcs.present) {
      map['rcs'] = Variable<String>(rcs.value);
    }
    if (nif.present) {
      map['nif'] = Variable<String>(nif.value);
    }
    if (stat.present) {
      map['stat'] = Variable<String>(stat.value);
    }
    if (tel.present) {
      map['tel'] = Variable<String>(tel.value);
    }
    if (port.present) {
      map['port'] = Variable<String>(port.value);
    }
    if (email.present) {
      map['email'] = Variable<String>(email.value);
    }
    if (site.present) {
      map['site'] = Variable<String>(site.value);
    }
    if (fax.present) {
      map['fax'] = Variable<String>(fax.value);
    }
    if (telex.present) {
      map['telex'] = Variable<String>(telex.value);
    }
    if (soldes.present) {
      map['soldes'] = Variable<double>(soldes.value);
    }
    if (datedernop.present) {
      map['datedernop'] = Variable<DateTime>(datedernop.value);
    }
    if (delai.present) {
      map['delai'] = Variable<int>(delai.value);
    }
    if (soldesa.present) {
      map['soldesa'] = Variable<double>(soldesa.value);
    }
    if (action.present) {
      map['action'] = Variable<String>(action.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FrnsCompanion(')
          ..write('rsoc: $rsoc, ')
          ..write('adr: $adr, ')
          ..write('capital: $capital, ')
          ..write('rcs: $rcs, ')
          ..write('nif: $nif, ')
          ..write('stat: $stat, ')
          ..write('tel: $tel, ')
          ..write('port: $port, ')
          ..write('email: $email, ')
          ..write('site: $site, ')
          ..write('fax: $fax, ')
          ..write('telex: $telex, ')
          ..write('soldes: $soldes, ')
          ..write('datedernop: $datedernop, ')
          ..write('delai: $delai, ')
          ..write('soldesa: $soldesa, ')
          ..write('action: $action, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ComTable extends Com with TableInfo<$ComTable, ComData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ComTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _nomMeta = const VerificationMeta('nom');
  @override
  late final GeneratedColumn<String> nom = GeneratedColumn<String>(
      'nom', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _adrMeta = const VerificationMeta('adr');
  @override
  late final GeneratedColumn<String> adr = GeneratedColumn<String>(
      'adr', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 200),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _telMeta = const VerificationMeta('tel');
  @override
  late final GeneratedColumn<String> tel = GeneratedColumn<String>(
      'tel', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _emailMeta = const VerificationMeta('email');
  @override
  late final GeneratedColumn<String> email = GeneratedColumn<String>(
      'email', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _soldesMeta = const VerificationMeta('soldes');
  @override
  late final GeneratedColumn<double> soldes = GeneratedColumn<double>(
      'soldes', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _tauxMeta = const VerificationMeta('taux');
  @override
  late final GeneratedColumn<double> taux = GeneratedColumn<double>(
      'taux', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _actionMeta = const VerificationMeta('action');
  @override
  late final GeneratedColumn<String> action = GeneratedColumn<String>(
      'action', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _soldesaMeta =
      const VerificationMeta('soldesa');
  @override
  late final GeneratedColumn<double> soldesa = GeneratedColumn<double>(
      'soldesa', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns =>
      [nom, adr, tel, email, soldes, taux, action, soldesa];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'com';
  @override
  VerificationContext validateIntegrity(Insertable<ComData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('nom')) {
      context.handle(
          _nomMeta, nom.isAcceptableOrUnknown(data['nom']!, _nomMeta));
    } else if (isInserting) {
      context.missing(_nomMeta);
    }
    if (data.containsKey('adr')) {
      context.handle(
          _adrMeta, adr.isAcceptableOrUnknown(data['adr']!, _adrMeta));
    }
    if (data.containsKey('tel')) {
      context.handle(
          _telMeta, tel.isAcceptableOrUnknown(data['tel']!, _telMeta));
    }
    if (data.containsKey('email')) {
      context.handle(
          _emailMeta, email.isAcceptableOrUnknown(data['email']!, _emailMeta));
    }
    if (data.containsKey('soldes')) {
      context.handle(_soldesMeta,
          soldes.isAcceptableOrUnknown(data['soldes']!, _soldesMeta));
    }
    if (data.containsKey('taux')) {
      context.handle(
          _tauxMeta, taux.isAcceptableOrUnknown(data['taux']!, _tauxMeta));
    }
    if (data.containsKey('action')) {
      context.handle(_actionMeta,
          action.isAcceptableOrUnknown(data['action']!, _actionMeta));
    }
    if (data.containsKey('soldesa')) {
      context.handle(_soldesaMeta,
          soldesa.isAcceptableOrUnknown(data['soldesa']!, _soldesaMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {nom};
  @override
  ComData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ComData(
      nom: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}nom'])!,
      adr: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}adr']),
      tel: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tel']),
      email: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}email']),
      soldes: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}soldes']),
      taux: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}taux']),
      action: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}action']),
      soldesa: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}soldesa']),
    );
  }

  @override
  $ComTable createAlias(String alias) {
    return $ComTable(attachedDatabase, alias);
  }
}

class ComData extends DataClass implements Insertable<ComData> {
  final String nom;
  final String? adr;
  final String? tel;
  final String? email;
  final double? soldes;
  final double? taux;
  final String? action;
  final double? soldesa;
  const ComData(
      {required this.nom,
      this.adr,
      this.tel,
      this.email,
      this.soldes,
      this.taux,
      this.action,
      this.soldesa});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['nom'] = Variable<String>(nom);
    if (!nullToAbsent || adr != null) {
      map['adr'] = Variable<String>(adr);
    }
    if (!nullToAbsent || tel != null) {
      map['tel'] = Variable<String>(tel);
    }
    if (!nullToAbsent || email != null) {
      map['email'] = Variable<String>(email);
    }
    if (!nullToAbsent || soldes != null) {
      map['soldes'] = Variable<double>(soldes);
    }
    if (!nullToAbsent || taux != null) {
      map['taux'] = Variable<double>(taux);
    }
    if (!nullToAbsent || action != null) {
      map['action'] = Variable<String>(action);
    }
    if (!nullToAbsent || soldesa != null) {
      map['soldesa'] = Variable<double>(soldesa);
    }
    return map;
  }

  ComCompanion toCompanion(bool nullToAbsent) {
    return ComCompanion(
      nom: Value(nom),
      adr: adr == null && nullToAbsent ? const Value.absent() : Value(adr),
      tel: tel == null && nullToAbsent ? const Value.absent() : Value(tel),
      email:
          email == null && nullToAbsent ? const Value.absent() : Value(email),
      soldes:
          soldes == null && nullToAbsent ? const Value.absent() : Value(soldes),
      taux: taux == null && nullToAbsent ? const Value.absent() : Value(taux),
      action:
          action == null && nullToAbsent ? const Value.absent() : Value(action),
      soldesa: soldesa == null && nullToAbsent
          ? const Value.absent()
          : Value(soldesa),
    );
  }

  factory ComData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ComData(
      nom: serializer.fromJson<String>(json['nom']),
      adr: serializer.fromJson<String?>(json['adr']),
      tel: serializer.fromJson<String?>(json['tel']),
      email: serializer.fromJson<String?>(json['email']),
      soldes: serializer.fromJson<double?>(json['soldes']),
      taux: serializer.fromJson<double?>(json['taux']),
      action: serializer.fromJson<String?>(json['action']),
      soldesa: serializer.fromJson<double?>(json['soldesa']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'nom': serializer.toJson<String>(nom),
      'adr': serializer.toJson<String?>(adr),
      'tel': serializer.toJson<String?>(tel),
      'email': serializer.toJson<String?>(email),
      'soldes': serializer.toJson<double?>(soldes),
      'taux': serializer.toJson<double?>(taux),
      'action': serializer.toJson<String?>(action),
      'soldesa': serializer.toJson<double?>(soldesa),
    };
  }

  ComData copyWith(
          {String? nom,
          Value<String?> adr = const Value.absent(),
          Value<String?> tel = const Value.absent(),
          Value<String?> email = const Value.absent(),
          Value<double?> soldes = const Value.absent(),
          Value<double?> taux = const Value.absent(),
          Value<String?> action = const Value.absent(),
          Value<double?> soldesa = const Value.absent()}) =>
      ComData(
        nom: nom ?? this.nom,
        adr: adr.present ? adr.value : this.adr,
        tel: tel.present ? tel.value : this.tel,
        email: email.present ? email.value : this.email,
        soldes: soldes.present ? soldes.value : this.soldes,
        taux: taux.present ? taux.value : this.taux,
        action: action.present ? action.value : this.action,
        soldesa: soldesa.present ? soldesa.value : this.soldesa,
      );
  ComData copyWithCompanion(ComCompanion data) {
    return ComData(
      nom: data.nom.present ? data.nom.value : this.nom,
      adr: data.adr.present ? data.adr.value : this.adr,
      tel: data.tel.present ? data.tel.value : this.tel,
      email: data.email.present ? data.email.value : this.email,
      soldes: data.soldes.present ? data.soldes.value : this.soldes,
      taux: data.taux.present ? data.taux.value : this.taux,
      action: data.action.present ? data.action.value : this.action,
      soldesa: data.soldesa.present ? data.soldesa.value : this.soldesa,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ComData(')
          ..write('nom: $nom, ')
          ..write('adr: $adr, ')
          ..write('tel: $tel, ')
          ..write('email: $email, ')
          ..write('soldes: $soldes, ')
          ..write('taux: $taux, ')
          ..write('action: $action, ')
          ..write('soldesa: $soldesa')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(nom, adr, tel, email, soldes, taux, action, soldesa);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ComData &&
          other.nom == this.nom &&
          other.adr == this.adr &&
          other.tel == this.tel &&
          other.email == this.email &&
          other.soldes == this.soldes &&
          other.taux == this.taux &&
          other.action == this.action &&
          other.soldesa == this.soldesa);
}

class ComCompanion extends UpdateCompanion<ComData> {
  final Value<String> nom;
  final Value<String?> adr;
  final Value<String?> tel;
  final Value<String?> email;
  final Value<double?> soldes;
  final Value<double?> taux;
  final Value<String?> action;
  final Value<double?> soldesa;
  final Value<int> rowid;
  const ComCompanion({
    this.nom = const Value.absent(),
    this.adr = const Value.absent(),
    this.tel = const Value.absent(),
    this.email = const Value.absent(),
    this.soldes = const Value.absent(),
    this.taux = const Value.absent(),
    this.action = const Value.absent(),
    this.soldesa = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ComCompanion.insert({
    required String nom,
    this.adr = const Value.absent(),
    this.tel = const Value.absent(),
    this.email = const Value.absent(),
    this.soldes = const Value.absent(),
    this.taux = const Value.absent(),
    this.action = const Value.absent(),
    this.soldesa = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : nom = Value(nom);
  static Insertable<ComData> custom({
    Expression<String>? nom,
    Expression<String>? adr,
    Expression<String>? tel,
    Expression<String>? email,
    Expression<double>? soldes,
    Expression<double>? taux,
    Expression<String>? action,
    Expression<double>? soldesa,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (nom != null) 'nom': nom,
      if (adr != null) 'adr': adr,
      if (tel != null) 'tel': tel,
      if (email != null) 'email': email,
      if (soldes != null) 'soldes': soldes,
      if (taux != null) 'taux': taux,
      if (action != null) 'action': action,
      if (soldesa != null) 'soldesa': soldesa,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ComCompanion copyWith(
      {Value<String>? nom,
      Value<String?>? adr,
      Value<String?>? tel,
      Value<String?>? email,
      Value<double?>? soldes,
      Value<double?>? taux,
      Value<String?>? action,
      Value<double?>? soldesa,
      Value<int>? rowid}) {
    return ComCompanion(
      nom: nom ?? this.nom,
      adr: adr ?? this.adr,
      tel: tel ?? this.tel,
      email: email ?? this.email,
      soldes: soldes ?? this.soldes,
      taux: taux ?? this.taux,
      action: action ?? this.action,
      soldesa: soldesa ?? this.soldesa,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (nom.present) {
      map['nom'] = Variable<String>(nom.value);
    }
    if (adr.present) {
      map['adr'] = Variable<String>(adr.value);
    }
    if (tel.present) {
      map['tel'] = Variable<String>(tel.value);
    }
    if (email.present) {
      map['email'] = Variable<String>(email.value);
    }
    if (soldes.present) {
      map['soldes'] = Variable<double>(soldes.value);
    }
    if (taux.present) {
      map['taux'] = Variable<double>(taux.value);
    }
    if (action.present) {
      map['action'] = Variable<String>(action.value);
    }
    if (soldesa.present) {
      map['soldesa'] = Variable<double>(soldesa.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ComCompanion(')
          ..write('nom: $nom, ')
          ..write('adr: $adr, ')
          ..write('tel: $tel, ')
          ..write('email: $email, ')
          ..write('soldes: $soldes, ')
          ..write('taux: $taux, ')
          ..write('action: $action, ')
          ..write('soldesa: $soldesa, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $VentesTable extends Ventes with TableInfo<$VentesTable, Vente> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $VentesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _numMeta = const VerificationMeta('num');
  @override
  late final GeneratedColumn<int> num = GeneratedColumn<int>(
      'num', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _numventesMeta =
      const VerificationMeta('numventes');
  @override
  late final GeneratedColumn<String> numventes = GeneratedColumn<String>(
      'numventes', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _nfactMeta = const VerificationMeta('nfact');
  @override
  late final GeneratedColumn<String> nfact = GeneratedColumn<String>(
      'nfact', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _datyMeta = const VerificationMeta('daty');
  @override
  late final GeneratedColumn<DateTime> daty = GeneratedColumn<DateTime>(
      'daty', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _cltMeta = const VerificationMeta('clt');
  @override
  late final GeneratedColumn<String> clt = GeneratedColumn<String>(
      'clt', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _modepaiMeta =
      const VerificationMeta('modepai');
  @override
  late final GeneratedColumn<String> modepai = GeneratedColumn<String>(
      'modepai', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _echeanceMeta =
      const VerificationMeta('echeance');
  @override
  late final GeneratedColumn<DateTime> echeance = GeneratedColumn<DateTime>(
      'echeance', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _totalntMeta =
      const VerificationMeta('totalnt');
  @override
  late final GeneratedColumn<double> totalnt = GeneratedColumn<double>(
      'totalnt', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _totalttcMeta =
      const VerificationMeta('totalttc');
  @override
  late final GeneratedColumn<double> totalttc = GeneratedColumn<double>(
      'totalttc', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _tvaMeta = const VerificationMeta('tva');
  @override
  late final GeneratedColumn<double> tva = GeneratedColumn<double>(
      'tva', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _contreMeta = const VerificationMeta('contre');
  @override
  late final GeneratedColumn<String> contre = GeneratedColumn<String>(
      'contre', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _avanceMeta = const VerificationMeta('avance');
  @override
  late final GeneratedColumn<double> avance = GeneratedColumn<double>(
      'avance', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _bqMeta = const VerificationMeta('bq');
  @override
  late final GeneratedColumn<String> bq = GeneratedColumn<String>(
      'bq', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _reglMeta = const VerificationMeta('regl');
  @override
  late final GeneratedColumn<double> regl = GeneratedColumn<double>(
      'regl', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _datrcolMeta =
      const VerificationMeta('datrcol');
  @override
  late final GeneratedColumn<DateTime> datrcol = GeneratedColumn<DateTime>(
      'datrcol', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _mreglMeta = const VerificationMeta('mregl');
  @override
  late final GeneratedColumn<String> mregl = GeneratedColumn<String>(
      'mregl', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _commercMeta =
      const VerificationMeta('commerc');
  @override
  late final GeneratedColumn<String> commerc = GeneratedColumn<String>(
      'commerc', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _commissionMeta =
      const VerificationMeta('commission');
  @override
  late final GeneratedColumn<double> commission = GeneratedColumn<double>(
      'commission', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _remiseMeta = const VerificationMeta('remise');
  @override
  late final GeneratedColumn<double> remise = GeneratedColumn<double>(
      'remise', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _verificationMeta =
      const VerificationMeta('verification');
  @override
  late final GeneratedColumn<String> verification = GeneratedColumn<String>(
      'verification', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
      'type', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _asMeta = const VerificationMeta('as');
  @override
  late final GeneratedColumn<String> as = GeneratedColumn<String>(
      'as', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _embMeta = const VerificationMeta('emb');
  @override
  late final GeneratedColumn<String> emb = GeneratedColumn<String>(
      'emb', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _transpMeta = const VerificationMeta('transp');
  @override
  late final GeneratedColumn<String> transp = GeneratedColumn<String>(
      'transp', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _heureMeta = const VerificationMeta('heure');
  @override
  late final GeneratedColumn<String> heure = GeneratedColumn<String>(
      'heure', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 10),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _posteMeta = const VerificationMeta('poste');
  @override
  late final GeneratedColumn<String> poste = GeneratedColumn<String>(
      'poste', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        num,
        numventes,
        nfact,
        daty,
        clt,
        modepai,
        echeance,
        totalnt,
        totalttc,
        tva,
        contre,
        avance,
        bq,
        regl,
        datrcol,
        mregl,
        commerc,
        commission,
        remise,
        verification,
        type,
        as,
        emb,
        transp,
        heure,
        poste
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ventes';
  @override
  VerificationContext validateIntegrity(Insertable<Vente> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('num')) {
      context.handle(
          _numMeta, num.isAcceptableOrUnknown(data['num']!, _numMeta));
    }
    if (data.containsKey('numventes')) {
      context.handle(_numventesMeta,
          numventes.isAcceptableOrUnknown(data['numventes']!, _numventesMeta));
    }
    if (data.containsKey('nfact')) {
      context.handle(
          _nfactMeta, nfact.isAcceptableOrUnknown(data['nfact']!, _nfactMeta));
    }
    if (data.containsKey('daty')) {
      context.handle(
          _datyMeta, daty.isAcceptableOrUnknown(data['daty']!, _datyMeta));
    }
    if (data.containsKey('clt')) {
      context.handle(
          _cltMeta, clt.isAcceptableOrUnknown(data['clt']!, _cltMeta));
    }
    if (data.containsKey('modepai')) {
      context.handle(_modepaiMeta,
          modepai.isAcceptableOrUnknown(data['modepai']!, _modepaiMeta));
    }
    if (data.containsKey('echeance')) {
      context.handle(_echeanceMeta,
          echeance.isAcceptableOrUnknown(data['echeance']!, _echeanceMeta));
    }
    if (data.containsKey('totalnt')) {
      context.handle(_totalntMeta,
          totalnt.isAcceptableOrUnknown(data['totalnt']!, _totalntMeta));
    }
    if (data.containsKey('totalttc')) {
      context.handle(_totalttcMeta,
          totalttc.isAcceptableOrUnknown(data['totalttc']!, _totalttcMeta));
    }
    if (data.containsKey('tva')) {
      context.handle(
          _tvaMeta, tva.isAcceptableOrUnknown(data['tva']!, _tvaMeta));
    }
    if (data.containsKey('contre')) {
      context.handle(_contreMeta,
          contre.isAcceptableOrUnknown(data['contre']!, _contreMeta));
    }
    if (data.containsKey('avance')) {
      context.handle(_avanceMeta,
          avance.isAcceptableOrUnknown(data['avance']!, _avanceMeta));
    }
    if (data.containsKey('bq')) {
      context.handle(_bqMeta, bq.isAcceptableOrUnknown(data['bq']!, _bqMeta));
    }
    if (data.containsKey('regl')) {
      context.handle(
          _reglMeta, regl.isAcceptableOrUnknown(data['regl']!, _reglMeta));
    }
    if (data.containsKey('datrcol')) {
      context.handle(_datrcolMeta,
          datrcol.isAcceptableOrUnknown(data['datrcol']!, _datrcolMeta));
    }
    if (data.containsKey('mregl')) {
      context.handle(
          _mreglMeta, mregl.isAcceptableOrUnknown(data['mregl']!, _mreglMeta));
    }
    if (data.containsKey('commerc')) {
      context.handle(_commercMeta,
          commerc.isAcceptableOrUnknown(data['commerc']!, _commercMeta));
    }
    if (data.containsKey('commission')) {
      context.handle(
          _commissionMeta,
          commission.isAcceptableOrUnknown(
              data['commission']!, _commissionMeta));
    }
    if (data.containsKey('remise')) {
      context.handle(_remiseMeta,
          remise.isAcceptableOrUnknown(data['remise']!, _remiseMeta));
    }
    if (data.containsKey('verification')) {
      context.handle(
          _verificationMeta,
          verification.isAcceptableOrUnknown(
              data['verification']!, _verificationMeta));
    }
    if (data.containsKey('type')) {
      context.handle(
          _typeMeta, type.isAcceptableOrUnknown(data['type']!, _typeMeta));
    }
    if (data.containsKey('as')) {
      context.handle(_asMeta, as.isAcceptableOrUnknown(data['as']!, _asMeta));
    }
    if (data.containsKey('emb')) {
      context.handle(
          _embMeta, emb.isAcceptableOrUnknown(data['emb']!, _embMeta));
    }
    if (data.containsKey('transp')) {
      context.handle(_transpMeta,
          transp.isAcceptableOrUnknown(data['transp']!, _transpMeta));
    }
    if (data.containsKey('heure')) {
      context.handle(
          _heureMeta, heure.isAcceptableOrUnknown(data['heure']!, _heureMeta));
    }
    if (data.containsKey('poste')) {
      context.handle(
          _posteMeta, poste.isAcceptableOrUnknown(data['poste']!, _posteMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {num};
  @override
  Vente map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Vente(
      num: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}num'])!,
      numventes: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}numventes']),
      nfact: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}nfact']),
      daty: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}daty']),
      clt: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}clt']),
      modepai: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}modepai']),
      echeance: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}echeance']),
      totalnt: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}totalnt']),
      totalttc: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}totalttc']),
      tva: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}tva']),
      contre: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}contre']),
      avance: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}avance']),
      bq: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}bq']),
      regl: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}regl']),
      datrcol: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}datrcol']),
      mregl: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}mregl']),
      commerc: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}commerc']),
      commission: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}commission']),
      remise: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}remise']),
      verification: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}verification']),
      type: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type']),
      as: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}as']),
      emb: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}emb']),
      transp: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}transp']),
      heure: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}heure']),
      poste: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}poste']),
    );
  }

  @override
  $VentesTable createAlias(String alias) {
    return $VentesTable(attachedDatabase, alias);
  }
}

class Vente extends DataClass implements Insertable<Vente> {
  final int num;
  final String? numventes;
  final String? nfact;
  final DateTime? daty;
  final String? clt;
  final String? modepai;
  final DateTime? echeance;
  final double? totalnt;
  final double? totalttc;
  final double? tva;
  final String? contre;
  final double? avance;
  final String? bq;
  final double? regl;
  final DateTime? datrcol;
  final String? mregl;
  final String? commerc;
  final double? commission;
  final double? remise;
  final String? verification;
  final String? type;
  final String? as;
  final String? emb;
  final String? transp;
  final String? heure;
  final String? poste;
  const Vente(
      {required this.num,
      this.numventes,
      this.nfact,
      this.daty,
      this.clt,
      this.modepai,
      this.echeance,
      this.totalnt,
      this.totalttc,
      this.tva,
      this.contre,
      this.avance,
      this.bq,
      this.regl,
      this.datrcol,
      this.mregl,
      this.commerc,
      this.commission,
      this.remise,
      this.verification,
      this.type,
      this.as,
      this.emb,
      this.transp,
      this.heure,
      this.poste});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['num'] = Variable<int>(num);
    if (!nullToAbsent || numventes != null) {
      map['numventes'] = Variable<String>(numventes);
    }
    if (!nullToAbsent || nfact != null) {
      map['nfact'] = Variable<String>(nfact);
    }
    if (!nullToAbsent || daty != null) {
      map['daty'] = Variable<DateTime>(daty);
    }
    if (!nullToAbsent || clt != null) {
      map['clt'] = Variable<String>(clt);
    }
    if (!nullToAbsent || modepai != null) {
      map['modepai'] = Variable<String>(modepai);
    }
    if (!nullToAbsent || echeance != null) {
      map['echeance'] = Variable<DateTime>(echeance);
    }
    if (!nullToAbsent || totalnt != null) {
      map['totalnt'] = Variable<double>(totalnt);
    }
    if (!nullToAbsent || totalttc != null) {
      map['totalttc'] = Variable<double>(totalttc);
    }
    if (!nullToAbsent || tva != null) {
      map['tva'] = Variable<double>(tva);
    }
    if (!nullToAbsent || contre != null) {
      map['contre'] = Variable<String>(contre);
    }
    if (!nullToAbsent || avance != null) {
      map['avance'] = Variable<double>(avance);
    }
    if (!nullToAbsent || bq != null) {
      map['bq'] = Variable<String>(bq);
    }
    if (!nullToAbsent || regl != null) {
      map['regl'] = Variable<double>(regl);
    }
    if (!nullToAbsent || datrcol != null) {
      map['datrcol'] = Variable<DateTime>(datrcol);
    }
    if (!nullToAbsent || mregl != null) {
      map['mregl'] = Variable<String>(mregl);
    }
    if (!nullToAbsent || commerc != null) {
      map['commerc'] = Variable<String>(commerc);
    }
    if (!nullToAbsent || commission != null) {
      map['commission'] = Variable<double>(commission);
    }
    if (!nullToAbsent || remise != null) {
      map['remise'] = Variable<double>(remise);
    }
    if (!nullToAbsent || verification != null) {
      map['verification'] = Variable<String>(verification);
    }
    if (!nullToAbsent || type != null) {
      map['type'] = Variable<String>(type);
    }
    if (!nullToAbsent || as != null) {
      map['as'] = Variable<String>(as);
    }
    if (!nullToAbsent || emb != null) {
      map['emb'] = Variable<String>(emb);
    }
    if (!nullToAbsent || transp != null) {
      map['transp'] = Variable<String>(transp);
    }
    if (!nullToAbsent || heure != null) {
      map['heure'] = Variable<String>(heure);
    }
    if (!nullToAbsent || poste != null) {
      map['poste'] = Variable<String>(poste);
    }
    return map;
  }

  VentesCompanion toCompanion(bool nullToAbsent) {
    return VentesCompanion(
      num: Value(num),
      numventes: numventes == null && nullToAbsent
          ? const Value.absent()
          : Value(numventes),
      nfact:
          nfact == null && nullToAbsent ? const Value.absent() : Value(nfact),
      daty: daty == null && nullToAbsent ? const Value.absent() : Value(daty),
      clt: clt == null && nullToAbsent ? const Value.absent() : Value(clt),
      modepai: modepai == null && nullToAbsent
          ? const Value.absent()
          : Value(modepai),
      echeance: echeance == null && nullToAbsent
          ? const Value.absent()
          : Value(echeance),
      totalnt: totalnt == null && nullToAbsent
          ? const Value.absent()
          : Value(totalnt),
      totalttc: totalttc == null && nullToAbsent
          ? const Value.absent()
          : Value(totalttc),
      tva: tva == null && nullToAbsent ? const Value.absent() : Value(tva),
      contre:
          contre == null && nullToAbsent ? const Value.absent() : Value(contre),
      avance:
          avance == null && nullToAbsent ? const Value.absent() : Value(avance),
      bq: bq == null && nullToAbsent ? const Value.absent() : Value(bq),
      regl: regl == null && nullToAbsent ? const Value.absent() : Value(regl),
      datrcol: datrcol == null && nullToAbsent
          ? const Value.absent()
          : Value(datrcol),
      mregl:
          mregl == null && nullToAbsent ? const Value.absent() : Value(mregl),
      commerc: commerc == null && nullToAbsent
          ? const Value.absent()
          : Value(commerc),
      commission: commission == null && nullToAbsent
          ? const Value.absent()
          : Value(commission),
      remise:
          remise == null && nullToAbsent ? const Value.absent() : Value(remise),
      verification: verification == null && nullToAbsent
          ? const Value.absent()
          : Value(verification),
      type: type == null && nullToAbsent ? const Value.absent() : Value(type),
      as: as == null && nullToAbsent ? const Value.absent() : Value(as),
      emb: emb == null && nullToAbsent ? const Value.absent() : Value(emb),
      transp:
          transp == null && nullToAbsent ? const Value.absent() : Value(transp),
      heure:
          heure == null && nullToAbsent ? const Value.absent() : Value(heure),
      poste:
          poste == null && nullToAbsent ? const Value.absent() : Value(poste),
    );
  }

  factory Vente.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Vente(
      num: serializer.fromJson<int>(json['num']),
      numventes: serializer.fromJson<String?>(json['numventes']),
      nfact: serializer.fromJson<String?>(json['nfact']),
      daty: serializer.fromJson<DateTime?>(json['daty']),
      clt: serializer.fromJson<String?>(json['clt']),
      modepai: serializer.fromJson<String?>(json['modepai']),
      echeance: serializer.fromJson<DateTime?>(json['echeance']),
      totalnt: serializer.fromJson<double?>(json['totalnt']),
      totalttc: serializer.fromJson<double?>(json['totalttc']),
      tva: serializer.fromJson<double?>(json['tva']),
      contre: serializer.fromJson<String?>(json['contre']),
      avance: serializer.fromJson<double?>(json['avance']),
      bq: serializer.fromJson<String?>(json['bq']),
      regl: serializer.fromJson<double?>(json['regl']),
      datrcol: serializer.fromJson<DateTime?>(json['datrcol']),
      mregl: serializer.fromJson<String?>(json['mregl']),
      commerc: serializer.fromJson<String?>(json['commerc']),
      commission: serializer.fromJson<double?>(json['commission']),
      remise: serializer.fromJson<double?>(json['remise']),
      verification: serializer.fromJson<String?>(json['verification']),
      type: serializer.fromJson<String?>(json['type']),
      as: serializer.fromJson<String?>(json['as']),
      emb: serializer.fromJson<String?>(json['emb']),
      transp: serializer.fromJson<String?>(json['transp']),
      heure: serializer.fromJson<String?>(json['heure']),
      poste: serializer.fromJson<String?>(json['poste']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'num': serializer.toJson<int>(num),
      'numventes': serializer.toJson<String?>(numventes),
      'nfact': serializer.toJson<String?>(nfact),
      'daty': serializer.toJson<DateTime?>(daty),
      'clt': serializer.toJson<String?>(clt),
      'modepai': serializer.toJson<String?>(modepai),
      'echeance': serializer.toJson<DateTime?>(echeance),
      'totalnt': serializer.toJson<double?>(totalnt),
      'totalttc': serializer.toJson<double?>(totalttc),
      'tva': serializer.toJson<double?>(tva),
      'contre': serializer.toJson<String?>(contre),
      'avance': serializer.toJson<double?>(avance),
      'bq': serializer.toJson<String?>(bq),
      'regl': serializer.toJson<double?>(regl),
      'datrcol': serializer.toJson<DateTime?>(datrcol),
      'mregl': serializer.toJson<String?>(mregl),
      'commerc': serializer.toJson<String?>(commerc),
      'commission': serializer.toJson<double?>(commission),
      'remise': serializer.toJson<double?>(remise),
      'verification': serializer.toJson<String?>(verification),
      'type': serializer.toJson<String?>(type),
      'as': serializer.toJson<String?>(as),
      'emb': serializer.toJson<String?>(emb),
      'transp': serializer.toJson<String?>(transp),
      'heure': serializer.toJson<String?>(heure),
      'poste': serializer.toJson<String?>(poste),
    };
  }

  Vente copyWith(
          {int? num,
          Value<String?> numventes = const Value.absent(),
          Value<String?> nfact = const Value.absent(),
          Value<DateTime?> daty = const Value.absent(),
          Value<String?> clt = const Value.absent(),
          Value<String?> modepai = const Value.absent(),
          Value<DateTime?> echeance = const Value.absent(),
          Value<double?> totalnt = const Value.absent(),
          Value<double?> totalttc = const Value.absent(),
          Value<double?> tva = const Value.absent(),
          Value<String?> contre = const Value.absent(),
          Value<double?> avance = const Value.absent(),
          Value<String?> bq = const Value.absent(),
          Value<double?> regl = const Value.absent(),
          Value<DateTime?> datrcol = const Value.absent(),
          Value<String?> mregl = const Value.absent(),
          Value<String?> commerc = const Value.absent(),
          Value<double?> commission = const Value.absent(),
          Value<double?> remise = const Value.absent(),
          Value<String?> verification = const Value.absent(),
          Value<String?> type = const Value.absent(),
          Value<String?> as = const Value.absent(),
          Value<String?> emb = const Value.absent(),
          Value<String?> transp = const Value.absent(),
          Value<String?> heure = const Value.absent(),
          Value<String?> poste = const Value.absent()}) =>
      Vente(
        num: num ?? this.num,
        numventes: numventes.present ? numventes.value : this.numventes,
        nfact: nfact.present ? nfact.value : this.nfact,
        daty: daty.present ? daty.value : this.daty,
        clt: clt.present ? clt.value : this.clt,
        modepai: modepai.present ? modepai.value : this.modepai,
        echeance: echeance.present ? echeance.value : this.echeance,
        totalnt: totalnt.present ? totalnt.value : this.totalnt,
        totalttc: totalttc.present ? totalttc.value : this.totalttc,
        tva: tva.present ? tva.value : this.tva,
        contre: contre.present ? contre.value : this.contre,
        avance: avance.present ? avance.value : this.avance,
        bq: bq.present ? bq.value : this.bq,
        regl: regl.present ? regl.value : this.regl,
        datrcol: datrcol.present ? datrcol.value : this.datrcol,
        mregl: mregl.present ? mregl.value : this.mregl,
        commerc: commerc.present ? commerc.value : this.commerc,
        commission: commission.present ? commission.value : this.commission,
        remise: remise.present ? remise.value : this.remise,
        verification:
            verification.present ? verification.value : this.verification,
        type: type.present ? type.value : this.type,
        as: as.present ? as.value : this.as,
        emb: emb.present ? emb.value : this.emb,
        transp: transp.present ? transp.value : this.transp,
        heure: heure.present ? heure.value : this.heure,
        poste: poste.present ? poste.value : this.poste,
      );
  Vente copyWithCompanion(VentesCompanion data) {
    return Vente(
      num: data.num.present ? data.num.value : this.num,
      numventes: data.numventes.present ? data.numventes.value : this.numventes,
      nfact: data.nfact.present ? data.nfact.value : this.nfact,
      daty: data.daty.present ? data.daty.value : this.daty,
      clt: data.clt.present ? data.clt.value : this.clt,
      modepai: data.modepai.present ? data.modepai.value : this.modepai,
      echeance: data.echeance.present ? data.echeance.value : this.echeance,
      totalnt: data.totalnt.present ? data.totalnt.value : this.totalnt,
      totalttc: data.totalttc.present ? data.totalttc.value : this.totalttc,
      tva: data.tva.present ? data.tva.value : this.tva,
      contre: data.contre.present ? data.contre.value : this.contre,
      avance: data.avance.present ? data.avance.value : this.avance,
      bq: data.bq.present ? data.bq.value : this.bq,
      regl: data.regl.present ? data.regl.value : this.regl,
      datrcol: data.datrcol.present ? data.datrcol.value : this.datrcol,
      mregl: data.mregl.present ? data.mregl.value : this.mregl,
      commerc: data.commerc.present ? data.commerc.value : this.commerc,
      commission:
          data.commission.present ? data.commission.value : this.commission,
      remise: data.remise.present ? data.remise.value : this.remise,
      verification: data.verification.present
          ? data.verification.value
          : this.verification,
      type: data.type.present ? data.type.value : this.type,
      as: data.as.present ? data.as.value : this.as,
      emb: data.emb.present ? data.emb.value : this.emb,
      transp: data.transp.present ? data.transp.value : this.transp,
      heure: data.heure.present ? data.heure.value : this.heure,
      poste: data.poste.present ? data.poste.value : this.poste,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Vente(')
          ..write('num: $num, ')
          ..write('numventes: $numventes, ')
          ..write('nfact: $nfact, ')
          ..write('daty: $daty, ')
          ..write('clt: $clt, ')
          ..write('modepai: $modepai, ')
          ..write('echeance: $echeance, ')
          ..write('totalnt: $totalnt, ')
          ..write('totalttc: $totalttc, ')
          ..write('tva: $tva, ')
          ..write('contre: $contre, ')
          ..write('avance: $avance, ')
          ..write('bq: $bq, ')
          ..write('regl: $regl, ')
          ..write('datrcol: $datrcol, ')
          ..write('mregl: $mregl, ')
          ..write('commerc: $commerc, ')
          ..write('commission: $commission, ')
          ..write('remise: $remise, ')
          ..write('verification: $verification, ')
          ..write('type: $type, ')
          ..write('as: $as, ')
          ..write('emb: $emb, ')
          ..write('transp: $transp, ')
          ..write('heure: $heure, ')
          ..write('poste: $poste')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        num,
        numventes,
        nfact,
        daty,
        clt,
        modepai,
        echeance,
        totalnt,
        totalttc,
        tva,
        contre,
        avance,
        bq,
        regl,
        datrcol,
        mregl,
        commerc,
        commission,
        remise,
        verification,
        type,
        as,
        emb,
        transp,
        heure,
        poste
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Vente &&
          other.num == this.num &&
          other.numventes == this.numventes &&
          other.nfact == this.nfact &&
          other.daty == this.daty &&
          other.clt == this.clt &&
          other.modepai == this.modepai &&
          other.echeance == this.echeance &&
          other.totalnt == this.totalnt &&
          other.totalttc == this.totalttc &&
          other.tva == this.tva &&
          other.contre == this.contre &&
          other.avance == this.avance &&
          other.bq == this.bq &&
          other.regl == this.regl &&
          other.datrcol == this.datrcol &&
          other.mregl == this.mregl &&
          other.commerc == this.commerc &&
          other.commission == this.commission &&
          other.remise == this.remise &&
          other.verification == this.verification &&
          other.type == this.type &&
          other.as == this.as &&
          other.emb == this.emb &&
          other.transp == this.transp &&
          other.heure == this.heure &&
          other.poste == this.poste);
}

class VentesCompanion extends UpdateCompanion<Vente> {
  final Value<int> num;
  final Value<String?> numventes;
  final Value<String?> nfact;
  final Value<DateTime?> daty;
  final Value<String?> clt;
  final Value<String?> modepai;
  final Value<DateTime?> echeance;
  final Value<double?> totalnt;
  final Value<double?> totalttc;
  final Value<double?> tva;
  final Value<String?> contre;
  final Value<double?> avance;
  final Value<String?> bq;
  final Value<double?> regl;
  final Value<DateTime?> datrcol;
  final Value<String?> mregl;
  final Value<String?> commerc;
  final Value<double?> commission;
  final Value<double?> remise;
  final Value<String?> verification;
  final Value<String?> type;
  final Value<String?> as;
  final Value<String?> emb;
  final Value<String?> transp;
  final Value<String?> heure;
  final Value<String?> poste;
  const VentesCompanion({
    this.num = const Value.absent(),
    this.numventes = const Value.absent(),
    this.nfact = const Value.absent(),
    this.daty = const Value.absent(),
    this.clt = const Value.absent(),
    this.modepai = const Value.absent(),
    this.echeance = const Value.absent(),
    this.totalnt = const Value.absent(),
    this.totalttc = const Value.absent(),
    this.tva = const Value.absent(),
    this.contre = const Value.absent(),
    this.avance = const Value.absent(),
    this.bq = const Value.absent(),
    this.regl = const Value.absent(),
    this.datrcol = const Value.absent(),
    this.mregl = const Value.absent(),
    this.commerc = const Value.absent(),
    this.commission = const Value.absent(),
    this.remise = const Value.absent(),
    this.verification = const Value.absent(),
    this.type = const Value.absent(),
    this.as = const Value.absent(),
    this.emb = const Value.absent(),
    this.transp = const Value.absent(),
    this.heure = const Value.absent(),
    this.poste = const Value.absent(),
  });
  VentesCompanion.insert({
    this.num = const Value.absent(),
    this.numventes = const Value.absent(),
    this.nfact = const Value.absent(),
    this.daty = const Value.absent(),
    this.clt = const Value.absent(),
    this.modepai = const Value.absent(),
    this.echeance = const Value.absent(),
    this.totalnt = const Value.absent(),
    this.totalttc = const Value.absent(),
    this.tva = const Value.absent(),
    this.contre = const Value.absent(),
    this.avance = const Value.absent(),
    this.bq = const Value.absent(),
    this.regl = const Value.absent(),
    this.datrcol = const Value.absent(),
    this.mregl = const Value.absent(),
    this.commerc = const Value.absent(),
    this.commission = const Value.absent(),
    this.remise = const Value.absent(),
    this.verification = const Value.absent(),
    this.type = const Value.absent(),
    this.as = const Value.absent(),
    this.emb = const Value.absent(),
    this.transp = const Value.absent(),
    this.heure = const Value.absent(),
    this.poste = const Value.absent(),
  });
  static Insertable<Vente> custom({
    Expression<int>? num,
    Expression<String>? numventes,
    Expression<String>? nfact,
    Expression<DateTime>? daty,
    Expression<String>? clt,
    Expression<String>? modepai,
    Expression<DateTime>? echeance,
    Expression<double>? totalnt,
    Expression<double>? totalttc,
    Expression<double>? tva,
    Expression<String>? contre,
    Expression<double>? avance,
    Expression<String>? bq,
    Expression<double>? regl,
    Expression<DateTime>? datrcol,
    Expression<String>? mregl,
    Expression<String>? commerc,
    Expression<double>? commission,
    Expression<double>? remise,
    Expression<String>? verification,
    Expression<String>? type,
    Expression<String>? as,
    Expression<String>? emb,
    Expression<String>? transp,
    Expression<String>? heure,
    Expression<String>? poste,
  }) {
    return RawValuesInsertable({
      if (num != null) 'num': num,
      if (numventes != null) 'numventes': numventes,
      if (nfact != null) 'nfact': nfact,
      if (daty != null) 'daty': daty,
      if (clt != null) 'clt': clt,
      if (modepai != null) 'modepai': modepai,
      if (echeance != null) 'echeance': echeance,
      if (totalnt != null) 'totalnt': totalnt,
      if (totalttc != null) 'totalttc': totalttc,
      if (tva != null) 'tva': tva,
      if (contre != null) 'contre': contre,
      if (avance != null) 'avance': avance,
      if (bq != null) 'bq': bq,
      if (regl != null) 'regl': regl,
      if (datrcol != null) 'datrcol': datrcol,
      if (mregl != null) 'mregl': mregl,
      if (commerc != null) 'commerc': commerc,
      if (commission != null) 'commission': commission,
      if (remise != null) 'remise': remise,
      if (verification != null) 'verification': verification,
      if (type != null) 'type': type,
      if (as != null) 'as': as,
      if (emb != null) 'emb': emb,
      if (transp != null) 'transp': transp,
      if (heure != null) 'heure': heure,
      if (poste != null) 'poste': poste,
    });
  }

  VentesCompanion copyWith(
      {Value<int>? num,
      Value<String?>? numventes,
      Value<String?>? nfact,
      Value<DateTime?>? daty,
      Value<String?>? clt,
      Value<String?>? modepai,
      Value<DateTime?>? echeance,
      Value<double?>? totalnt,
      Value<double?>? totalttc,
      Value<double?>? tva,
      Value<String?>? contre,
      Value<double?>? avance,
      Value<String?>? bq,
      Value<double?>? regl,
      Value<DateTime?>? datrcol,
      Value<String?>? mregl,
      Value<String?>? commerc,
      Value<double?>? commission,
      Value<double?>? remise,
      Value<String?>? verification,
      Value<String?>? type,
      Value<String?>? as,
      Value<String?>? emb,
      Value<String?>? transp,
      Value<String?>? heure,
      Value<String?>? poste}) {
    return VentesCompanion(
      num: num ?? this.num,
      numventes: numventes ?? this.numventes,
      nfact: nfact ?? this.nfact,
      daty: daty ?? this.daty,
      clt: clt ?? this.clt,
      modepai: modepai ?? this.modepai,
      echeance: echeance ?? this.echeance,
      totalnt: totalnt ?? this.totalnt,
      totalttc: totalttc ?? this.totalttc,
      tva: tva ?? this.tva,
      contre: contre ?? this.contre,
      avance: avance ?? this.avance,
      bq: bq ?? this.bq,
      regl: regl ?? this.regl,
      datrcol: datrcol ?? this.datrcol,
      mregl: mregl ?? this.mregl,
      commerc: commerc ?? this.commerc,
      commission: commission ?? this.commission,
      remise: remise ?? this.remise,
      verification: verification ?? this.verification,
      type: type ?? this.type,
      as: as ?? this.as,
      emb: emb ?? this.emb,
      transp: transp ?? this.transp,
      heure: heure ?? this.heure,
      poste: poste ?? this.poste,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (num.present) {
      map['num'] = Variable<int>(num.value);
    }
    if (numventes.present) {
      map['numventes'] = Variable<String>(numventes.value);
    }
    if (nfact.present) {
      map['nfact'] = Variable<String>(nfact.value);
    }
    if (daty.present) {
      map['daty'] = Variable<DateTime>(daty.value);
    }
    if (clt.present) {
      map['clt'] = Variable<String>(clt.value);
    }
    if (modepai.present) {
      map['modepai'] = Variable<String>(modepai.value);
    }
    if (echeance.present) {
      map['echeance'] = Variable<DateTime>(echeance.value);
    }
    if (totalnt.present) {
      map['totalnt'] = Variable<double>(totalnt.value);
    }
    if (totalttc.present) {
      map['totalttc'] = Variable<double>(totalttc.value);
    }
    if (tva.present) {
      map['tva'] = Variable<double>(tva.value);
    }
    if (contre.present) {
      map['contre'] = Variable<String>(contre.value);
    }
    if (avance.present) {
      map['avance'] = Variable<double>(avance.value);
    }
    if (bq.present) {
      map['bq'] = Variable<String>(bq.value);
    }
    if (regl.present) {
      map['regl'] = Variable<double>(regl.value);
    }
    if (datrcol.present) {
      map['datrcol'] = Variable<DateTime>(datrcol.value);
    }
    if (mregl.present) {
      map['mregl'] = Variable<String>(mregl.value);
    }
    if (commerc.present) {
      map['commerc'] = Variable<String>(commerc.value);
    }
    if (commission.present) {
      map['commission'] = Variable<double>(commission.value);
    }
    if (remise.present) {
      map['remise'] = Variable<double>(remise.value);
    }
    if (verification.present) {
      map['verification'] = Variable<String>(verification.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (as.present) {
      map['as'] = Variable<String>(as.value);
    }
    if (emb.present) {
      map['emb'] = Variable<String>(emb.value);
    }
    if (transp.present) {
      map['transp'] = Variable<String>(transp.value);
    }
    if (heure.present) {
      map['heure'] = Variable<String>(heure.value);
    }
    if (poste.present) {
      map['poste'] = Variable<String>(poste.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('VentesCompanion(')
          ..write('num: $num, ')
          ..write('numventes: $numventes, ')
          ..write('nfact: $nfact, ')
          ..write('daty: $daty, ')
          ..write('clt: $clt, ')
          ..write('modepai: $modepai, ')
          ..write('echeance: $echeance, ')
          ..write('totalnt: $totalnt, ')
          ..write('totalttc: $totalttc, ')
          ..write('tva: $tva, ')
          ..write('contre: $contre, ')
          ..write('avance: $avance, ')
          ..write('bq: $bq, ')
          ..write('regl: $regl, ')
          ..write('datrcol: $datrcol, ')
          ..write('mregl: $mregl, ')
          ..write('commerc: $commerc, ')
          ..write('commission: $commission, ')
          ..write('remise: $remise, ')
          ..write('verification: $verification, ')
          ..write('type: $type, ')
          ..write('as: $as, ')
          ..write('emb: $emb, ')
          ..write('transp: $transp, ')
          ..write('heure: $heure, ')
          ..write('poste: $poste')
          ..write(')'))
        .toString();
  }
}

class $AchatsTable extends Achats with TableInfo<$AchatsTable, Achat> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AchatsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _numMeta = const VerificationMeta('num');
  @override
  late final GeneratedColumn<int> num = GeneratedColumn<int>(
      'num', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _numachatsMeta =
      const VerificationMeta('numachats');
  @override
  late final GeneratedColumn<String> numachats = GeneratedColumn<String>(
      'numachats', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _nfactMeta = const VerificationMeta('nfact');
  @override
  late final GeneratedColumn<String> nfact = GeneratedColumn<String>(
      'nfact', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _datyMeta = const VerificationMeta('daty');
  @override
  late final GeneratedColumn<DateTime> daty = GeneratedColumn<DateTime>(
      'daty', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _frnsMeta = const VerificationMeta('frns');
  @override
  late final GeneratedColumn<String> frns = GeneratedColumn<String>(
      'frns', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _modepaiMeta =
      const VerificationMeta('modepai');
  @override
  late final GeneratedColumn<String> modepai = GeneratedColumn<String>(
      'modepai', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _echeanceMeta =
      const VerificationMeta('echeance');
  @override
  late final GeneratedColumn<DateTime> echeance = GeneratedColumn<DateTime>(
      'echeance', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _totalntMeta =
      const VerificationMeta('totalnt');
  @override
  late final GeneratedColumn<double> totalnt = GeneratedColumn<double>(
      'totalnt', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _totalttcMeta =
      const VerificationMeta('totalttc');
  @override
  late final GeneratedColumn<double> totalttc = GeneratedColumn<double>(
      'totalttc', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _tvaMeta = const VerificationMeta('tva');
  @override
  late final GeneratedColumn<double> tva = GeneratedColumn<double>(
      'tva', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _contreMeta = const VerificationMeta('contre');
  @override
  late final GeneratedColumn<String> contre = GeneratedColumn<String>(
      'contre', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _bqMeta = const VerificationMeta('bq');
  @override
  late final GeneratedColumn<String> bq = GeneratedColumn<String>(
      'bq', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _reglMeta = const VerificationMeta('regl');
  @override
  late final GeneratedColumn<double> regl = GeneratedColumn<double>(
      'regl', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _datreglMeta =
      const VerificationMeta('datregl');
  @override
  late final GeneratedColumn<DateTime> datregl = GeneratedColumn<DateTime>(
      'datregl', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _mreglMeta = const VerificationMeta('mregl');
  @override
  late final GeneratedColumn<String> mregl = GeneratedColumn<String>(
      'mregl', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _verificationMeta =
      const VerificationMeta('verification');
  @override
  late final GeneratedColumn<String> verification = GeneratedColumn<String>(
      'verification', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
      'type', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _asMeta = const VerificationMeta('as');
  @override
  late final GeneratedColumn<String> as = GeneratedColumn<String>(
      'as', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _embMeta = const VerificationMeta('emb');
  @override
  late final GeneratedColumn<String> emb = GeneratedColumn<String>(
      'emb', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _transpMeta = const VerificationMeta('transp');
  @override
  late final GeneratedColumn<String> transp = GeneratedColumn<String>(
      'transp', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        num,
        numachats,
        nfact,
        daty,
        frns,
        modepai,
        echeance,
        totalnt,
        totalttc,
        tva,
        contre,
        bq,
        regl,
        datregl,
        mregl,
        verification,
        type,
        as,
        emb,
        transp
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'achats';
  @override
  VerificationContext validateIntegrity(Insertable<Achat> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('num')) {
      context.handle(
          _numMeta, num.isAcceptableOrUnknown(data['num']!, _numMeta));
    }
    if (data.containsKey('numachats')) {
      context.handle(_numachatsMeta,
          numachats.isAcceptableOrUnknown(data['numachats']!, _numachatsMeta));
    }
    if (data.containsKey('nfact')) {
      context.handle(
          _nfactMeta, nfact.isAcceptableOrUnknown(data['nfact']!, _nfactMeta));
    }
    if (data.containsKey('daty')) {
      context.handle(
          _datyMeta, daty.isAcceptableOrUnknown(data['daty']!, _datyMeta));
    }
    if (data.containsKey('frns')) {
      context.handle(
          _frnsMeta, frns.isAcceptableOrUnknown(data['frns']!, _frnsMeta));
    }
    if (data.containsKey('modepai')) {
      context.handle(_modepaiMeta,
          modepai.isAcceptableOrUnknown(data['modepai']!, _modepaiMeta));
    }
    if (data.containsKey('echeance')) {
      context.handle(_echeanceMeta,
          echeance.isAcceptableOrUnknown(data['echeance']!, _echeanceMeta));
    }
    if (data.containsKey('totalnt')) {
      context.handle(_totalntMeta,
          totalnt.isAcceptableOrUnknown(data['totalnt']!, _totalntMeta));
    }
    if (data.containsKey('totalttc')) {
      context.handle(_totalttcMeta,
          totalttc.isAcceptableOrUnknown(data['totalttc']!, _totalttcMeta));
    }
    if (data.containsKey('tva')) {
      context.handle(
          _tvaMeta, tva.isAcceptableOrUnknown(data['tva']!, _tvaMeta));
    }
    if (data.containsKey('contre')) {
      context.handle(_contreMeta,
          contre.isAcceptableOrUnknown(data['contre']!, _contreMeta));
    }
    if (data.containsKey('bq')) {
      context.handle(_bqMeta, bq.isAcceptableOrUnknown(data['bq']!, _bqMeta));
    }
    if (data.containsKey('regl')) {
      context.handle(
          _reglMeta, regl.isAcceptableOrUnknown(data['regl']!, _reglMeta));
    }
    if (data.containsKey('datregl')) {
      context.handle(_datreglMeta,
          datregl.isAcceptableOrUnknown(data['datregl']!, _datreglMeta));
    }
    if (data.containsKey('mregl')) {
      context.handle(
          _mreglMeta, mregl.isAcceptableOrUnknown(data['mregl']!, _mreglMeta));
    }
    if (data.containsKey('verification')) {
      context.handle(
          _verificationMeta,
          verification.isAcceptableOrUnknown(
              data['verification']!, _verificationMeta));
    }
    if (data.containsKey('type')) {
      context.handle(
          _typeMeta, type.isAcceptableOrUnknown(data['type']!, _typeMeta));
    }
    if (data.containsKey('as')) {
      context.handle(_asMeta, as.isAcceptableOrUnknown(data['as']!, _asMeta));
    }
    if (data.containsKey('emb')) {
      context.handle(
          _embMeta, emb.isAcceptableOrUnknown(data['emb']!, _embMeta));
    }
    if (data.containsKey('transp')) {
      context.handle(_transpMeta,
          transp.isAcceptableOrUnknown(data['transp']!, _transpMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {num};
  @override
  Achat map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Achat(
      num: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}num'])!,
      numachats: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}numachats']),
      nfact: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}nfact']),
      daty: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}daty']),
      frns: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}frns']),
      modepai: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}modepai']),
      echeance: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}echeance']),
      totalnt: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}totalnt']),
      totalttc: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}totalttc']),
      tva: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}tva']),
      contre: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}contre']),
      bq: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}bq']),
      regl: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}regl']),
      datregl: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}datregl']),
      mregl: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}mregl']),
      verification: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}verification']),
      type: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type']),
      as: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}as']),
      emb: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}emb']),
      transp: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}transp']),
    );
  }

  @override
  $AchatsTable createAlias(String alias) {
    return $AchatsTable(attachedDatabase, alias);
  }
}

class Achat extends DataClass implements Insertable<Achat> {
  final int num;
  final String? numachats;
  final String? nfact;
  final DateTime? daty;
  final String? frns;
  final String? modepai;
  final DateTime? echeance;
  final double? totalnt;
  final double? totalttc;
  final double? tva;
  final String? contre;
  final String? bq;
  final double? regl;
  final DateTime? datregl;
  final String? mregl;
  final String? verification;
  final String? type;
  final String? as;
  final String? emb;
  final String? transp;
  const Achat(
      {required this.num,
      this.numachats,
      this.nfact,
      this.daty,
      this.frns,
      this.modepai,
      this.echeance,
      this.totalnt,
      this.totalttc,
      this.tva,
      this.contre,
      this.bq,
      this.regl,
      this.datregl,
      this.mregl,
      this.verification,
      this.type,
      this.as,
      this.emb,
      this.transp});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['num'] = Variable<int>(num);
    if (!nullToAbsent || numachats != null) {
      map['numachats'] = Variable<String>(numachats);
    }
    if (!nullToAbsent || nfact != null) {
      map['nfact'] = Variable<String>(nfact);
    }
    if (!nullToAbsent || daty != null) {
      map['daty'] = Variable<DateTime>(daty);
    }
    if (!nullToAbsent || frns != null) {
      map['frns'] = Variable<String>(frns);
    }
    if (!nullToAbsent || modepai != null) {
      map['modepai'] = Variable<String>(modepai);
    }
    if (!nullToAbsent || echeance != null) {
      map['echeance'] = Variable<DateTime>(echeance);
    }
    if (!nullToAbsent || totalnt != null) {
      map['totalnt'] = Variable<double>(totalnt);
    }
    if (!nullToAbsent || totalttc != null) {
      map['totalttc'] = Variable<double>(totalttc);
    }
    if (!nullToAbsent || tva != null) {
      map['tva'] = Variable<double>(tva);
    }
    if (!nullToAbsent || contre != null) {
      map['contre'] = Variable<String>(contre);
    }
    if (!nullToAbsent || bq != null) {
      map['bq'] = Variable<String>(bq);
    }
    if (!nullToAbsent || regl != null) {
      map['regl'] = Variable<double>(regl);
    }
    if (!nullToAbsent || datregl != null) {
      map['datregl'] = Variable<DateTime>(datregl);
    }
    if (!nullToAbsent || mregl != null) {
      map['mregl'] = Variable<String>(mregl);
    }
    if (!nullToAbsent || verification != null) {
      map['verification'] = Variable<String>(verification);
    }
    if (!nullToAbsent || type != null) {
      map['type'] = Variable<String>(type);
    }
    if (!nullToAbsent || as != null) {
      map['as'] = Variable<String>(as);
    }
    if (!nullToAbsent || emb != null) {
      map['emb'] = Variable<String>(emb);
    }
    if (!nullToAbsent || transp != null) {
      map['transp'] = Variable<String>(transp);
    }
    return map;
  }

  AchatsCompanion toCompanion(bool nullToAbsent) {
    return AchatsCompanion(
      num: Value(num),
      numachats: numachats == null && nullToAbsent
          ? const Value.absent()
          : Value(numachats),
      nfact:
          nfact == null && nullToAbsent ? const Value.absent() : Value(nfact),
      daty: daty == null && nullToAbsent ? const Value.absent() : Value(daty),
      frns: frns == null && nullToAbsent ? const Value.absent() : Value(frns),
      modepai: modepai == null && nullToAbsent
          ? const Value.absent()
          : Value(modepai),
      echeance: echeance == null && nullToAbsent
          ? const Value.absent()
          : Value(echeance),
      totalnt: totalnt == null && nullToAbsent
          ? const Value.absent()
          : Value(totalnt),
      totalttc: totalttc == null && nullToAbsent
          ? const Value.absent()
          : Value(totalttc),
      tva: tva == null && nullToAbsent ? const Value.absent() : Value(tva),
      contre:
          contre == null && nullToAbsent ? const Value.absent() : Value(contre),
      bq: bq == null && nullToAbsent ? const Value.absent() : Value(bq),
      regl: regl == null && nullToAbsent ? const Value.absent() : Value(regl),
      datregl: datregl == null && nullToAbsent
          ? const Value.absent()
          : Value(datregl),
      mregl:
          mregl == null && nullToAbsent ? const Value.absent() : Value(mregl),
      verification: verification == null && nullToAbsent
          ? const Value.absent()
          : Value(verification),
      type: type == null && nullToAbsent ? const Value.absent() : Value(type),
      as: as == null && nullToAbsent ? const Value.absent() : Value(as),
      emb: emb == null && nullToAbsent ? const Value.absent() : Value(emb),
      transp:
          transp == null && nullToAbsent ? const Value.absent() : Value(transp),
    );
  }

  factory Achat.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Achat(
      num: serializer.fromJson<int>(json['num']),
      numachats: serializer.fromJson<String?>(json['numachats']),
      nfact: serializer.fromJson<String?>(json['nfact']),
      daty: serializer.fromJson<DateTime?>(json['daty']),
      frns: serializer.fromJson<String?>(json['frns']),
      modepai: serializer.fromJson<String?>(json['modepai']),
      echeance: serializer.fromJson<DateTime?>(json['echeance']),
      totalnt: serializer.fromJson<double?>(json['totalnt']),
      totalttc: serializer.fromJson<double?>(json['totalttc']),
      tva: serializer.fromJson<double?>(json['tva']),
      contre: serializer.fromJson<String?>(json['contre']),
      bq: serializer.fromJson<String?>(json['bq']),
      regl: serializer.fromJson<double?>(json['regl']),
      datregl: serializer.fromJson<DateTime?>(json['datregl']),
      mregl: serializer.fromJson<String?>(json['mregl']),
      verification: serializer.fromJson<String?>(json['verification']),
      type: serializer.fromJson<String?>(json['type']),
      as: serializer.fromJson<String?>(json['as']),
      emb: serializer.fromJson<String?>(json['emb']),
      transp: serializer.fromJson<String?>(json['transp']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'num': serializer.toJson<int>(num),
      'numachats': serializer.toJson<String?>(numachats),
      'nfact': serializer.toJson<String?>(nfact),
      'daty': serializer.toJson<DateTime?>(daty),
      'frns': serializer.toJson<String?>(frns),
      'modepai': serializer.toJson<String?>(modepai),
      'echeance': serializer.toJson<DateTime?>(echeance),
      'totalnt': serializer.toJson<double?>(totalnt),
      'totalttc': serializer.toJson<double?>(totalttc),
      'tva': serializer.toJson<double?>(tva),
      'contre': serializer.toJson<String?>(contre),
      'bq': serializer.toJson<String?>(bq),
      'regl': serializer.toJson<double?>(regl),
      'datregl': serializer.toJson<DateTime?>(datregl),
      'mregl': serializer.toJson<String?>(mregl),
      'verification': serializer.toJson<String?>(verification),
      'type': serializer.toJson<String?>(type),
      'as': serializer.toJson<String?>(as),
      'emb': serializer.toJson<String?>(emb),
      'transp': serializer.toJson<String?>(transp),
    };
  }

  Achat copyWith(
          {int? num,
          Value<String?> numachats = const Value.absent(),
          Value<String?> nfact = const Value.absent(),
          Value<DateTime?> daty = const Value.absent(),
          Value<String?> frns = const Value.absent(),
          Value<String?> modepai = const Value.absent(),
          Value<DateTime?> echeance = const Value.absent(),
          Value<double?> totalnt = const Value.absent(),
          Value<double?> totalttc = const Value.absent(),
          Value<double?> tva = const Value.absent(),
          Value<String?> contre = const Value.absent(),
          Value<String?> bq = const Value.absent(),
          Value<double?> regl = const Value.absent(),
          Value<DateTime?> datregl = const Value.absent(),
          Value<String?> mregl = const Value.absent(),
          Value<String?> verification = const Value.absent(),
          Value<String?> type = const Value.absent(),
          Value<String?> as = const Value.absent(),
          Value<String?> emb = const Value.absent(),
          Value<String?> transp = const Value.absent()}) =>
      Achat(
        num: num ?? this.num,
        numachats: numachats.present ? numachats.value : this.numachats,
        nfact: nfact.present ? nfact.value : this.nfact,
        daty: daty.present ? daty.value : this.daty,
        frns: frns.present ? frns.value : this.frns,
        modepai: modepai.present ? modepai.value : this.modepai,
        echeance: echeance.present ? echeance.value : this.echeance,
        totalnt: totalnt.present ? totalnt.value : this.totalnt,
        totalttc: totalttc.present ? totalttc.value : this.totalttc,
        tva: tva.present ? tva.value : this.tva,
        contre: contre.present ? contre.value : this.contre,
        bq: bq.present ? bq.value : this.bq,
        regl: regl.present ? regl.value : this.regl,
        datregl: datregl.present ? datregl.value : this.datregl,
        mregl: mregl.present ? mregl.value : this.mregl,
        verification:
            verification.present ? verification.value : this.verification,
        type: type.present ? type.value : this.type,
        as: as.present ? as.value : this.as,
        emb: emb.present ? emb.value : this.emb,
        transp: transp.present ? transp.value : this.transp,
      );
  Achat copyWithCompanion(AchatsCompanion data) {
    return Achat(
      num: data.num.present ? data.num.value : this.num,
      numachats: data.numachats.present ? data.numachats.value : this.numachats,
      nfact: data.nfact.present ? data.nfact.value : this.nfact,
      daty: data.daty.present ? data.daty.value : this.daty,
      frns: data.frns.present ? data.frns.value : this.frns,
      modepai: data.modepai.present ? data.modepai.value : this.modepai,
      echeance: data.echeance.present ? data.echeance.value : this.echeance,
      totalnt: data.totalnt.present ? data.totalnt.value : this.totalnt,
      totalttc: data.totalttc.present ? data.totalttc.value : this.totalttc,
      tva: data.tva.present ? data.tva.value : this.tva,
      contre: data.contre.present ? data.contre.value : this.contre,
      bq: data.bq.present ? data.bq.value : this.bq,
      regl: data.regl.present ? data.regl.value : this.regl,
      datregl: data.datregl.present ? data.datregl.value : this.datregl,
      mregl: data.mregl.present ? data.mregl.value : this.mregl,
      verification: data.verification.present
          ? data.verification.value
          : this.verification,
      type: data.type.present ? data.type.value : this.type,
      as: data.as.present ? data.as.value : this.as,
      emb: data.emb.present ? data.emb.value : this.emb,
      transp: data.transp.present ? data.transp.value : this.transp,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Achat(')
          ..write('num: $num, ')
          ..write('numachats: $numachats, ')
          ..write('nfact: $nfact, ')
          ..write('daty: $daty, ')
          ..write('frns: $frns, ')
          ..write('modepai: $modepai, ')
          ..write('echeance: $echeance, ')
          ..write('totalnt: $totalnt, ')
          ..write('totalttc: $totalttc, ')
          ..write('tva: $tva, ')
          ..write('contre: $contre, ')
          ..write('bq: $bq, ')
          ..write('regl: $regl, ')
          ..write('datregl: $datregl, ')
          ..write('mregl: $mregl, ')
          ..write('verification: $verification, ')
          ..write('type: $type, ')
          ..write('as: $as, ')
          ..write('emb: $emb, ')
          ..write('transp: $transp')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      num,
      numachats,
      nfact,
      daty,
      frns,
      modepai,
      echeance,
      totalnt,
      totalttc,
      tva,
      contre,
      bq,
      regl,
      datregl,
      mregl,
      verification,
      type,
      as,
      emb,
      transp);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Achat &&
          other.num == this.num &&
          other.numachats == this.numachats &&
          other.nfact == this.nfact &&
          other.daty == this.daty &&
          other.frns == this.frns &&
          other.modepai == this.modepai &&
          other.echeance == this.echeance &&
          other.totalnt == this.totalnt &&
          other.totalttc == this.totalttc &&
          other.tva == this.tva &&
          other.contre == this.contre &&
          other.bq == this.bq &&
          other.regl == this.regl &&
          other.datregl == this.datregl &&
          other.mregl == this.mregl &&
          other.verification == this.verification &&
          other.type == this.type &&
          other.as == this.as &&
          other.emb == this.emb &&
          other.transp == this.transp);
}

class AchatsCompanion extends UpdateCompanion<Achat> {
  final Value<int> num;
  final Value<String?> numachats;
  final Value<String?> nfact;
  final Value<DateTime?> daty;
  final Value<String?> frns;
  final Value<String?> modepai;
  final Value<DateTime?> echeance;
  final Value<double?> totalnt;
  final Value<double?> totalttc;
  final Value<double?> tva;
  final Value<String?> contre;
  final Value<String?> bq;
  final Value<double?> regl;
  final Value<DateTime?> datregl;
  final Value<String?> mregl;
  final Value<String?> verification;
  final Value<String?> type;
  final Value<String?> as;
  final Value<String?> emb;
  final Value<String?> transp;
  const AchatsCompanion({
    this.num = const Value.absent(),
    this.numachats = const Value.absent(),
    this.nfact = const Value.absent(),
    this.daty = const Value.absent(),
    this.frns = const Value.absent(),
    this.modepai = const Value.absent(),
    this.echeance = const Value.absent(),
    this.totalnt = const Value.absent(),
    this.totalttc = const Value.absent(),
    this.tva = const Value.absent(),
    this.contre = const Value.absent(),
    this.bq = const Value.absent(),
    this.regl = const Value.absent(),
    this.datregl = const Value.absent(),
    this.mregl = const Value.absent(),
    this.verification = const Value.absent(),
    this.type = const Value.absent(),
    this.as = const Value.absent(),
    this.emb = const Value.absent(),
    this.transp = const Value.absent(),
  });
  AchatsCompanion.insert({
    this.num = const Value.absent(),
    this.numachats = const Value.absent(),
    this.nfact = const Value.absent(),
    this.daty = const Value.absent(),
    this.frns = const Value.absent(),
    this.modepai = const Value.absent(),
    this.echeance = const Value.absent(),
    this.totalnt = const Value.absent(),
    this.totalttc = const Value.absent(),
    this.tva = const Value.absent(),
    this.contre = const Value.absent(),
    this.bq = const Value.absent(),
    this.regl = const Value.absent(),
    this.datregl = const Value.absent(),
    this.mregl = const Value.absent(),
    this.verification = const Value.absent(),
    this.type = const Value.absent(),
    this.as = const Value.absent(),
    this.emb = const Value.absent(),
    this.transp = const Value.absent(),
  });
  static Insertable<Achat> custom({
    Expression<int>? num,
    Expression<String>? numachats,
    Expression<String>? nfact,
    Expression<DateTime>? daty,
    Expression<String>? frns,
    Expression<String>? modepai,
    Expression<DateTime>? echeance,
    Expression<double>? totalnt,
    Expression<double>? totalttc,
    Expression<double>? tva,
    Expression<String>? contre,
    Expression<String>? bq,
    Expression<double>? regl,
    Expression<DateTime>? datregl,
    Expression<String>? mregl,
    Expression<String>? verification,
    Expression<String>? type,
    Expression<String>? as,
    Expression<String>? emb,
    Expression<String>? transp,
  }) {
    return RawValuesInsertable({
      if (num != null) 'num': num,
      if (numachats != null) 'numachats': numachats,
      if (nfact != null) 'nfact': nfact,
      if (daty != null) 'daty': daty,
      if (frns != null) 'frns': frns,
      if (modepai != null) 'modepai': modepai,
      if (echeance != null) 'echeance': echeance,
      if (totalnt != null) 'totalnt': totalnt,
      if (totalttc != null) 'totalttc': totalttc,
      if (tva != null) 'tva': tva,
      if (contre != null) 'contre': contre,
      if (bq != null) 'bq': bq,
      if (regl != null) 'regl': regl,
      if (datregl != null) 'datregl': datregl,
      if (mregl != null) 'mregl': mregl,
      if (verification != null) 'verification': verification,
      if (type != null) 'type': type,
      if (as != null) 'as': as,
      if (emb != null) 'emb': emb,
      if (transp != null) 'transp': transp,
    });
  }

  AchatsCompanion copyWith(
      {Value<int>? num,
      Value<String?>? numachats,
      Value<String?>? nfact,
      Value<DateTime?>? daty,
      Value<String?>? frns,
      Value<String?>? modepai,
      Value<DateTime?>? echeance,
      Value<double?>? totalnt,
      Value<double?>? totalttc,
      Value<double?>? tva,
      Value<String?>? contre,
      Value<String?>? bq,
      Value<double?>? regl,
      Value<DateTime?>? datregl,
      Value<String?>? mregl,
      Value<String?>? verification,
      Value<String?>? type,
      Value<String?>? as,
      Value<String?>? emb,
      Value<String?>? transp}) {
    return AchatsCompanion(
      num: num ?? this.num,
      numachats: numachats ?? this.numachats,
      nfact: nfact ?? this.nfact,
      daty: daty ?? this.daty,
      frns: frns ?? this.frns,
      modepai: modepai ?? this.modepai,
      echeance: echeance ?? this.echeance,
      totalnt: totalnt ?? this.totalnt,
      totalttc: totalttc ?? this.totalttc,
      tva: tva ?? this.tva,
      contre: contre ?? this.contre,
      bq: bq ?? this.bq,
      regl: regl ?? this.regl,
      datregl: datregl ?? this.datregl,
      mregl: mregl ?? this.mregl,
      verification: verification ?? this.verification,
      type: type ?? this.type,
      as: as ?? this.as,
      emb: emb ?? this.emb,
      transp: transp ?? this.transp,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (num.present) {
      map['num'] = Variable<int>(num.value);
    }
    if (numachats.present) {
      map['numachats'] = Variable<String>(numachats.value);
    }
    if (nfact.present) {
      map['nfact'] = Variable<String>(nfact.value);
    }
    if (daty.present) {
      map['daty'] = Variable<DateTime>(daty.value);
    }
    if (frns.present) {
      map['frns'] = Variable<String>(frns.value);
    }
    if (modepai.present) {
      map['modepai'] = Variable<String>(modepai.value);
    }
    if (echeance.present) {
      map['echeance'] = Variable<DateTime>(echeance.value);
    }
    if (totalnt.present) {
      map['totalnt'] = Variable<double>(totalnt.value);
    }
    if (totalttc.present) {
      map['totalttc'] = Variable<double>(totalttc.value);
    }
    if (tva.present) {
      map['tva'] = Variable<double>(tva.value);
    }
    if (contre.present) {
      map['contre'] = Variable<String>(contre.value);
    }
    if (bq.present) {
      map['bq'] = Variable<String>(bq.value);
    }
    if (regl.present) {
      map['regl'] = Variable<double>(regl.value);
    }
    if (datregl.present) {
      map['datregl'] = Variable<DateTime>(datregl.value);
    }
    if (mregl.present) {
      map['mregl'] = Variable<String>(mregl.value);
    }
    if (verification.present) {
      map['verification'] = Variable<String>(verification.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (as.present) {
      map['as'] = Variable<String>(as.value);
    }
    if (emb.present) {
      map['emb'] = Variable<String>(emb.value);
    }
    if (transp.present) {
      map['transp'] = Variable<String>(transp.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AchatsCompanion(')
          ..write('num: $num, ')
          ..write('numachats: $numachats, ')
          ..write('nfact: $nfact, ')
          ..write('daty: $daty, ')
          ..write('frns: $frns, ')
          ..write('modepai: $modepai, ')
          ..write('echeance: $echeance, ')
          ..write('totalnt: $totalnt, ')
          ..write('totalttc: $totalttc, ')
          ..write('tva: $tva, ')
          ..write('contre: $contre, ')
          ..write('bq: $bq, ')
          ..write('regl: $regl, ')
          ..write('datregl: $datregl, ')
          ..write('mregl: $mregl, ')
          ..write('verification: $verification, ')
          ..write('type: $type, ')
          ..write('as: $as, ')
          ..write('emb: $emb, ')
          ..write('transp: $transp')
          ..write(')'))
        .toString();
  }
}

class $StocksTable extends Stocks with TableInfo<$StocksTable, Stock> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StocksTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _refMeta = const VerificationMeta('ref');
  @override
  late final GeneratedColumn<String> ref = GeneratedColumn<String>(
      'ref', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _datyMeta = const VerificationMeta('daty');
  @override
  late final GeneratedColumn<DateTime> daty = GeneratedColumn<DateTime>(
      'daty', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _libMeta = const VerificationMeta('lib');
  @override
  late final GeneratedColumn<String> lib = GeneratedColumn<String>(
      'lib', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _numachatsMeta =
      const VerificationMeta('numachats');
  @override
  late final GeneratedColumn<String> numachats = GeneratedColumn<String>(
      'numachats', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _nfactMeta = const VerificationMeta('nfact');
  @override
  late final GeneratedColumn<String> nfact = GeneratedColumn<String>(
      'nfact', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _refartMeta = const VerificationMeta('refart');
  @override
  late final GeneratedColumn<String> refart = GeneratedColumn<String>(
      'refart', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _qeMeta = const VerificationMeta('qe');
  @override
  late final GeneratedColumn<double> qe = GeneratedColumn<double>(
      'qe', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _entresMeta = const VerificationMeta('entres');
  @override
  late final GeneratedColumn<double> entres = GeneratedColumn<double>(
      'entres', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _qsMeta = const VerificationMeta('qs');
  @override
  late final GeneratedColumn<double> qs = GeneratedColumn<double>(
      'qs', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _pusMeta = const VerificationMeta('pus');
  @override
  late final GeneratedColumn<double> pus = GeneratedColumn<double>(
      'pus', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _sortieMeta = const VerificationMeta('sortie');
  @override
  late final GeneratedColumn<double> sortie = GeneratedColumn<double>(
      'sortie', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _stocksu1Meta =
      const VerificationMeta('stocksu1');
  @override
  late final GeneratedColumn<double> stocksu1 = GeneratedColumn<double>(
      'stocksu1', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _numventesMeta =
      const VerificationMeta('numventes');
  @override
  late final GeneratedColumn<String> numventes = GeneratedColumn<String>(
      'numventes', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _ueMeta = const VerificationMeta('ue');
  @override
  late final GeneratedColumn<String> ue = GeneratedColumn<String>(
      'ue', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _usMeta = const VerificationMeta('us');
  @override
  late final GeneratedColumn<String> us = GeneratedColumn<String>(
      'us', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _stocksu2Meta =
      const VerificationMeta('stocksu2');
  @override
  late final GeneratedColumn<double> stocksu2 = GeneratedColumn<double>(
      'stocksu2', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _stocksu3Meta =
      const VerificationMeta('stocksu3');
  @override
  late final GeneratedColumn<double> stocksu3 = GeneratedColumn<double>(
      'stocksu3', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _depotsMeta = const VerificationMeta('depots');
  @override
  late final GeneratedColumn<String> depots = GeneratedColumn<String>(
      'depots', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _cmupMeta = const VerificationMeta('cmup');
  @override
  late final GeneratedColumn<double> cmup = GeneratedColumn<double>(
      'cmup', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _cltMeta = const VerificationMeta('clt');
  @override
  late final GeneratedColumn<String> clt = GeneratedColumn<String>(
      'clt', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _frnsMeta = const VerificationMeta('frns');
  @override
  late final GeneratedColumn<String> frns = GeneratedColumn<String>(
      'frns', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _verificationMeta =
      const VerificationMeta('verification');
  @override
  late final GeneratedColumn<String> verification = GeneratedColumn<String>(
      'verification', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _stkdepMeta = const VerificationMeta('stkdep');
  @override
  late final GeneratedColumn<double> stkdep = GeneratedColumn<double>(
      'stkdep', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _marqMeta = const VerificationMeta('marq');
  @override
  late final GeneratedColumn<String> marq = GeneratedColumn<String>(
      'marq', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        ref,
        daty,
        lib,
        numachats,
        nfact,
        refart,
        qe,
        entres,
        qs,
        pus,
        sortie,
        stocksu1,
        numventes,
        ue,
        us,
        stocksu2,
        stocksu3,
        depots,
        cmup,
        clt,
        frns,
        verification,
        stkdep,
        marq
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stocks';
  @override
  VerificationContext validateIntegrity(Insertable<Stock> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('ref')) {
      context.handle(
          _refMeta, ref.isAcceptableOrUnknown(data['ref']!, _refMeta));
    } else if (isInserting) {
      context.missing(_refMeta);
    }
    if (data.containsKey('daty')) {
      context.handle(
          _datyMeta, daty.isAcceptableOrUnknown(data['daty']!, _datyMeta));
    }
    if (data.containsKey('lib')) {
      context.handle(
          _libMeta, lib.isAcceptableOrUnknown(data['lib']!, _libMeta));
    }
    if (data.containsKey('numachats')) {
      context.handle(_numachatsMeta,
          numachats.isAcceptableOrUnknown(data['numachats']!, _numachatsMeta));
    }
    if (data.containsKey('nfact')) {
      context.handle(
          _nfactMeta, nfact.isAcceptableOrUnknown(data['nfact']!, _nfactMeta));
    }
    if (data.containsKey('refart')) {
      context.handle(_refartMeta,
          refart.isAcceptableOrUnknown(data['refart']!, _refartMeta));
    }
    if (data.containsKey('qe')) {
      context.handle(_qeMeta, qe.isAcceptableOrUnknown(data['qe']!, _qeMeta));
    }
    if (data.containsKey('entres')) {
      context.handle(_entresMeta,
          entres.isAcceptableOrUnknown(data['entres']!, _entresMeta));
    }
    if (data.containsKey('qs')) {
      context.handle(_qsMeta, qs.isAcceptableOrUnknown(data['qs']!, _qsMeta));
    }
    if (data.containsKey('pus')) {
      context.handle(
          _pusMeta, pus.isAcceptableOrUnknown(data['pus']!, _pusMeta));
    }
    if (data.containsKey('sortie')) {
      context.handle(_sortieMeta,
          sortie.isAcceptableOrUnknown(data['sortie']!, _sortieMeta));
    }
    if (data.containsKey('stocksu1')) {
      context.handle(_stocksu1Meta,
          stocksu1.isAcceptableOrUnknown(data['stocksu1']!, _stocksu1Meta));
    }
    if (data.containsKey('numventes')) {
      context.handle(_numventesMeta,
          numventes.isAcceptableOrUnknown(data['numventes']!, _numventesMeta));
    }
    if (data.containsKey('ue')) {
      context.handle(_ueMeta, ue.isAcceptableOrUnknown(data['ue']!, _ueMeta));
    }
    if (data.containsKey('us')) {
      context.handle(_usMeta, us.isAcceptableOrUnknown(data['us']!, _usMeta));
    }
    if (data.containsKey('stocksu2')) {
      context.handle(_stocksu2Meta,
          stocksu2.isAcceptableOrUnknown(data['stocksu2']!, _stocksu2Meta));
    }
    if (data.containsKey('stocksu3')) {
      context.handle(_stocksu3Meta,
          stocksu3.isAcceptableOrUnknown(data['stocksu3']!, _stocksu3Meta));
    }
    if (data.containsKey('depots')) {
      context.handle(_depotsMeta,
          depots.isAcceptableOrUnknown(data['depots']!, _depotsMeta));
    }
    if (data.containsKey('cmup')) {
      context.handle(
          _cmupMeta, cmup.isAcceptableOrUnknown(data['cmup']!, _cmupMeta));
    }
    if (data.containsKey('clt')) {
      context.handle(
          _cltMeta, clt.isAcceptableOrUnknown(data['clt']!, _cltMeta));
    }
    if (data.containsKey('frns')) {
      context.handle(
          _frnsMeta, frns.isAcceptableOrUnknown(data['frns']!, _frnsMeta));
    }
    if (data.containsKey('verification')) {
      context.handle(
          _verificationMeta,
          verification.isAcceptableOrUnknown(
              data['verification']!, _verificationMeta));
    }
    if (data.containsKey('stkdep')) {
      context.handle(_stkdepMeta,
          stkdep.isAcceptableOrUnknown(data['stkdep']!, _stkdepMeta));
    }
    if (data.containsKey('marq')) {
      context.handle(
          _marqMeta, marq.isAcceptableOrUnknown(data['marq']!, _marqMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {ref};
  @override
  Stock map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Stock(
      ref: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}ref'])!,
      daty: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}daty']),
      lib: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}lib']),
      numachats: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}numachats']),
      nfact: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}nfact']),
      refart: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}refart']),
      qe: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}qe']),
      entres: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}entres']),
      qs: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}qs']),
      pus: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}pus']),
      sortie: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}sortie']),
      stocksu1: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}stocksu1']),
      numventes: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}numventes']),
      ue: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}ue']),
      us: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}us']),
      stocksu2: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}stocksu2']),
      stocksu3: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}stocksu3']),
      depots: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}depots']),
      cmup: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}cmup']),
      clt: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}clt']),
      frns: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}frns']),
      verification: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}verification']),
      stkdep: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}stkdep']),
      marq: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}marq']),
    );
  }

  @override
  $StocksTable createAlias(String alias) {
    return $StocksTable(attachedDatabase, alias);
  }
}

class Stock extends DataClass implements Insertable<Stock> {
  final String ref;
  final DateTime? daty;
  final String? lib;
  final String? numachats;
  final String? nfact;
  final String? refart;
  final double? qe;
  final double? entres;
  final double? qs;
  final double? pus;
  final double? sortie;
  final double? stocksu1;
  final String? numventes;
  final String? ue;
  final String? us;
  final double? stocksu2;
  final double? stocksu3;
  final String? depots;
  final double? cmup;
  final String? clt;
  final String? frns;
  final String? verification;
  final double? stkdep;
  final String? marq;
  const Stock(
      {required this.ref,
      this.daty,
      this.lib,
      this.numachats,
      this.nfact,
      this.refart,
      this.qe,
      this.entres,
      this.qs,
      this.pus,
      this.sortie,
      this.stocksu1,
      this.numventes,
      this.ue,
      this.us,
      this.stocksu2,
      this.stocksu3,
      this.depots,
      this.cmup,
      this.clt,
      this.frns,
      this.verification,
      this.stkdep,
      this.marq});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['ref'] = Variable<String>(ref);
    if (!nullToAbsent || daty != null) {
      map['daty'] = Variable<DateTime>(daty);
    }
    if (!nullToAbsent || lib != null) {
      map['lib'] = Variable<String>(lib);
    }
    if (!nullToAbsent || numachats != null) {
      map['numachats'] = Variable<String>(numachats);
    }
    if (!nullToAbsent || nfact != null) {
      map['nfact'] = Variable<String>(nfact);
    }
    if (!nullToAbsent || refart != null) {
      map['refart'] = Variable<String>(refart);
    }
    if (!nullToAbsent || qe != null) {
      map['qe'] = Variable<double>(qe);
    }
    if (!nullToAbsent || entres != null) {
      map['entres'] = Variable<double>(entres);
    }
    if (!nullToAbsent || qs != null) {
      map['qs'] = Variable<double>(qs);
    }
    if (!nullToAbsent || pus != null) {
      map['pus'] = Variable<double>(pus);
    }
    if (!nullToAbsent || sortie != null) {
      map['sortie'] = Variable<double>(sortie);
    }
    if (!nullToAbsent || stocksu1 != null) {
      map['stocksu1'] = Variable<double>(stocksu1);
    }
    if (!nullToAbsent || numventes != null) {
      map['numventes'] = Variable<String>(numventes);
    }
    if (!nullToAbsent || ue != null) {
      map['ue'] = Variable<String>(ue);
    }
    if (!nullToAbsent || us != null) {
      map['us'] = Variable<String>(us);
    }
    if (!nullToAbsent || stocksu2 != null) {
      map['stocksu2'] = Variable<double>(stocksu2);
    }
    if (!nullToAbsent || stocksu3 != null) {
      map['stocksu3'] = Variable<double>(stocksu3);
    }
    if (!nullToAbsent || depots != null) {
      map['depots'] = Variable<String>(depots);
    }
    if (!nullToAbsent || cmup != null) {
      map['cmup'] = Variable<double>(cmup);
    }
    if (!nullToAbsent || clt != null) {
      map['clt'] = Variable<String>(clt);
    }
    if (!nullToAbsent || frns != null) {
      map['frns'] = Variable<String>(frns);
    }
    if (!nullToAbsent || verification != null) {
      map['verification'] = Variable<String>(verification);
    }
    if (!nullToAbsent || stkdep != null) {
      map['stkdep'] = Variable<double>(stkdep);
    }
    if (!nullToAbsent || marq != null) {
      map['marq'] = Variable<String>(marq);
    }
    return map;
  }

  StocksCompanion toCompanion(bool nullToAbsent) {
    return StocksCompanion(
      ref: Value(ref),
      daty: daty == null && nullToAbsent ? const Value.absent() : Value(daty),
      lib: lib == null && nullToAbsent ? const Value.absent() : Value(lib),
      numachats: numachats == null && nullToAbsent
          ? const Value.absent()
          : Value(numachats),
      nfact:
          nfact == null && nullToAbsent ? const Value.absent() : Value(nfact),
      refart:
          refart == null && nullToAbsent ? const Value.absent() : Value(refart),
      qe: qe == null && nullToAbsent ? const Value.absent() : Value(qe),
      entres:
          entres == null && nullToAbsent ? const Value.absent() : Value(entres),
      qs: qs == null && nullToAbsent ? const Value.absent() : Value(qs),
      pus: pus == null && nullToAbsent ? const Value.absent() : Value(pus),
      sortie:
          sortie == null && nullToAbsent ? const Value.absent() : Value(sortie),
      stocksu1: stocksu1 == null && nullToAbsent
          ? const Value.absent()
          : Value(stocksu1),
      numventes: numventes == null && nullToAbsent
          ? const Value.absent()
          : Value(numventes),
      ue: ue == null && nullToAbsent ? const Value.absent() : Value(ue),
      us: us == null && nullToAbsent ? const Value.absent() : Value(us),
      stocksu2: stocksu2 == null && nullToAbsent
          ? const Value.absent()
          : Value(stocksu2),
      stocksu3: stocksu3 == null && nullToAbsent
          ? const Value.absent()
          : Value(stocksu3),
      depots:
          depots == null && nullToAbsent ? const Value.absent() : Value(depots),
      cmup: cmup == null && nullToAbsent ? const Value.absent() : Value(cmup),
      clt: clt == null && nullToAbsent ? const Value.absent() : Value(clt),
      frns: frns == null && nullToAbsent ? const Value.absent() : Value(frns),
      verification: verification == null && nullToAbsent
          ? const Value.absent()
          : Value(verification),
      stkdep:
          stkdep == null && nullToAbsent ? const Value.absent() : Value(stkdep),
      marq: marq == null && nullToAbsent ? const Value.absent() : Value(marq),
    );
  }

  factory Stock.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Stock(
      ref: serializer.fromJson<String>(json['ref']),
      daty: serializer.fromJson<DateTime?>(json['daty']),
      lib: serializer.fromJson<String?>(json['lib']),
      numachats: serializer.fromJson<String?>(json['numachats']),
      nfact: serializer.fromJson<String?>(json['nfact']),
      refart: serializer.fromJson<String?>(json['refart']),
      qe: serializer.fromJson<double?>(json['qe']),
      entres: serializer.fromJson<double?>(json['entres']),
      qs: serializer.fromJson<double?>(json['qs']),
      pus: serializer.fromJson<double?>(json['pus']),
      sortie: serializer.fromJson<double?>(json['sortie']),
      stocksu1: serializer.fromJson<double?>(json['stocksu1']),
      numventes: serializer.fromJson<String?>(json['numventes']),
      ue: serializer.fromJson<String?>(json['ue']),
      us: serializer.fromJson<String?>(json['us']),
      stocksu2: serializer.fromJson<double?>(json['stocksu2']),
      stocksu3: serializer.fromJson<double?>(json['stocksu3']),
      depots: serializer.fromJson<String?>(json['depots']),
      cmup: serializer.fromJson<double?>(json['cmup']),
      clt: serializer.fromJson<String?>(json['clt']),
      frns: serializer.fromJson<String?>(json['frns']),
      verification: serializer.fromJson<String?>(json['verification']),
      stkdep: serializer.fromJson<double?>(json['stkdep']),
      marq: serializer.fromJson<String?>(json['marq']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'ref': serializer.toJson<String>(ref),
      'daty': serializer.toJson<DateTime?>(daty),
      'lib': serializer.toJson<String?>(lib),
      'numachats': serializer.toJson<String?>(numachats),
      'nfact': serializer.toJson<String?>(nfact),
      'refart': serializer.toJson<String?>(refart),
      'qe': serializer.toJson<double?>(qe),
      'entres': serializer.toJson<double?>(entres),
      'qs': serializer.toJson<double?>(qs),
      'pus': serializer.toJson<double?>(pus),
      'sortie': serializer.toJson<double?>(sortie),
      'stocksu1': serializer.toJson<double?>(stocksu1),
      'numventes': serializer.toJson<String?>(numventes),
      'ue': serializer.toJson<String?>(ue),
      'us': serializer.toJson<String?>(us),
      'stocksu2': serializer.toJson<double?>(stocksu2),
      'stocksu3': serializer.toJson<double?>(stocksu3),
      'depots': serializer.toJson<String?>(depots),
      'cmup': serializer.toJson<double?>(cmup),
      'clt': serializer.toJson<String?>(clt),
      'frns': serializer.toJson<String?>(frns),
      'verification': serializer.toJson<String?>(verification),
      'stkdep': serializer.toJson<double?>(stkdep),
      'marq': serializer.toJson<String?>(marq),
    };
  }

  Stock copyWith(
          {String? ref,
          Value<DateTime?> daty = const Value.absent(),
          Value<String?> lib = const Value.absent(),
          Value<String?> numachats = const Value.absent(),
          Value<String?> nfact = const Value.absent(),
          Value<String?> refart = const Value.absent(),
          Value<double?> qe = const Value.absent(),
          Value<double?> entres = const Value.absent(),
          Value<double?> qs = const Value.absent(),
          Value<double?> pus = const Value.absent(),
          Value<double?> sortie = const Value.absent(),
          Value<double?> stocksu1 = const Value.absent(),
          Value<String?> numventes = const Value.absent(),
          Value<String?> ue = const Value.absent(),
          Value<String?> us = const Value.absent(),
          Value<double?> stocksu2 = const Value.absent(),
          Value<double?> stocksu3 = const Value.absent(),
          Value<String?> depots = const Value.absent(),
          Value<double?> cmup = const Value.absent(),
          Value<String?> clt = const Value.absent(),
          Value<String?> frns = const Value.absent(),
          Value<String?> verification = const Value.absent(),
          Value<double?> stkdep = const Value.absent(),
          Value<String?> marq = const Value.absent()}) =>
      Stock(
        ref: ref ?? this.ref,
        daty: daty.present ? daty.value : this.daty,
        lib: lib.present ? lib.value : this.lib,
        numachats: numachats.present ? numachats.value : this.numachats,
        nfact: nfact.present ? nfact.value : this.nfact,
        refart: refart.present ? refart.value : this.refart,
        qe: qe.present ? qe.value : this.qe,
        entres: entres.present ? entres.value : this.entres,
        qs: qs.present ? qs.value : this.qs,
        pus: pus.present ? pus.value : this.pus,
        sortie: sortie.present ? sortie.value : this.sortie,
        stocksu1: stocksu1.present ? stocksu1.value : this.stocksu1,
        numventes: numventes.present ? numventes.value : this.numventes,
        ue: ue.present ? ue.value : this.ue,
        us: us.present ? us.value : this.us,
        stocksu2: stocksu2.present ? stocksu2.value : this.stocksu2,
        stocksu3: stocksu3.present ? stocksu3.value : this.stocksu3,
        depots: depots.present ? depots.value : this.depots,
        cmup: cmup.present ? cmup.value : this.cmup,
        clt: clt.present ? clt.value : this.clt,
        frns: frns.present ? frns.value : this.frns,
        verification:
            verification.present ? verification.value : this.verification,
        stkdep: stkdep.present ? stkdep.value : this.stkdep,
        marq: marq.present ? marq.value : this.marq,
      );
  Stock copyWithCompanion(StocksCompanion data) {
    return Stock(
      ref: data.ref.present ? data.ref.value : this.ref,
      daty: data.daty.present ? data.daty.value : this.daty,
      lib: data.lib.present ? data.lib.value : this.lib,
      numachats: data.numachats.present ? data.numachats.value : this.numachats,
      nfact: data.nfact.present ? data.nfact.value : this.nfact,
      refart: data.refart.present ? data.refart.value : this.refart,
      qe: data.qe.present ? data.qe.value : this.qe,
      entres: data.entres.present ? data.entres.value : this.entres,
      qs: data.qs.present ? data.qs.value : this.qs,
      pus: data.pus.present ? data.pus.value : this.pus,
      sortie: data.sortie.present ? data.sortie.value : this.sortie,
      stocksu1: data.stocksu1.present ? data.stocksu1.value : this.stocksu1,
      numventes: data.numventes.present ? data.numventes.value : this.numventes,
      ue: data.ue.present ? data.ue.value : this.ue,
      us: data.us.present ? data.us.value : this.us,
      stocksu2: data.stocksu2.present ? data.stocksu2.value : this.stocksu2,
      stocksu3: data.stocksu3.present ? data.stocksu3.value : this.stocksu3,
      depots: data.depots.present ? data.depots.value : this.depots,
      cmup: data.cmup.present ? data.cmup.value : this.cmup,
      clt: data.clt.present ? data.clt.value : this.clt,
      frns: data.frns.present ? data.frns.value : this.frns,
      verification: data.verification.present
          ? data.verification.value
          : this.verification,
      stkdep: data.stkdep.present ? data.stkdep.value : this.stkdep,
      marq: data.marq.present ? data.marq.value : this.marq,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Stock(')
          ..write('ref: $ref, ')
          ..write('daty: $daty, ')
          ..write('lib: $lib, ')
          ..write('numachats: $numachats, ')
          ..write('nfact: $nfact, ')
          ..write('refart: $refart, ')
          ..write('qe: $qe, ')
          ..write('entres: $entres, ')
          ..write('qs: $qs, ')
          ..write('pus: $pus, ')
          ..write('sortie: $sortie, ')
          ..write('stocksu1: $stocksu1, ')
          ..write('numventes: $numventes, ')
          ..write('ue: $ue, ')
          ..write('us: $us, ')
          ..write('stocksu2: $stocksu2, ')
          ..write('stocksu3: $stocksu3, ')
          ..write('depots: $depots, ')
          ..write('cmup: $cmup, ')
          ..write('clt: $clt, ')
          ..write('frns: $frns, ')
          ..write('verification: $verification, ')
          ..write('stkdep: $stkdep, ')
          ..write('marq: $marq')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        ref,
        daty,
        lib,
        numachats,
        nfact,
        refart,
        qe,
        entres,
        qs,
        pus,
        sortie,
        stocksu1,
        numventes,
        ue,
        us,
        stocksu2,
        stocksu3,
        depots,
        cmup,
        clt,
        frns,
        verification,
        stkdep,
        marq
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Stock &&
          other.ref == this.ref &&
          other.daty == this.daty &&
          other.lib == this.lib &&
          other.numachats == this.numachats &&
          other.nfact == this.nfact &&
          other.refart == this.refart &&
          other.qe == this.qe &&
          other.entres == this.entres &&
          other.qs == this.qs &&
          other.pus == this.pus &&
          other.sortie == this.sortie &&
          other.stocksu1 == this.stocksu1 &&
          other.numventes == this.numventes &&
          other.ue == this.ue &&
          other.us == this.us &&
          other.stocksu2 == this.stocksu2 &&
          other.stocksu3 == this.stocksu3 &&
          other.depots == this.depots &&
          other.cmup == this.cmup &&
          other.clt == this.clt &&
          other.frns == this.frns &&
          other.verification == this.verification &&
          other.stkdep == this.stkdep &&
          other.marq == this.marq);
}

class StocksCompanion extends UpdateCompanion<Stock> {
  final Value<String> ref;
  final Value<DateTime?> daty;
  final Value<String?> lib;
  final Value<String?> numachats;
  final Value<String?> nfact;
  final Value<String?> refart;
  final Value<double?> qe;
  final Value<double?> entres;
  final Value<double?> qs;
  final Value<double?> pus;
  final Value<double?> sortie;
  final Value<double?> stocksu1;
  final Value<String?> numventes;
  final Value<String?> ue;
  final Value<String?> us;
  final Value<double?> stocksu2;
  final Value<double?> stocksu3;
  final Value<String?> depots;
  final Value<double?> cmup;
  final Value<String?> clt;
  final Value<String?> frns;
  final Value<String?> verification;
  final Value<double?> stkdep;
  final Value<String?> marq;
  final Value<int> rowid;
  const StocksCompanion({
    this.ref = const Value.absent(),
    this.daty = const Value.absent(),
    this.lib = const Value.absent(),
    this.numachats = const Value.absent(),
    this.nfact = const Value.absent(),
    this.refart = const Value.absent(),
    this.qe = const Value.absent(),
    this.entres = const Value.absent(),
    this.qs = const Value.absent(),
    this.pus = const Value.absent(),
    this.sortie = const Value.absent(),
    this.stocksu1 = const Value.absent(),
    this.numventes = const Value.absent(),
    this.ue = const Value.absent(),
    this.us = const Value.absent(),
    this.stocksu2 = const Value.absent(),
    this.stocksu3 = const Value.absent(),
    this.depots = const Value.absent(),
    this.cmup = const Value.absent(),
    this.clt = const Value.absent(),
    this.frns = const Value.absent(),
    this.verification = const Value.absent(),
    this.stkdep = const Value.absent(),
    this.marq = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  StocksCompanion.insert({
    required String ref,
    this.daty = const Value.absent(),
    this.lib = const Value.absent(),
    this.numachats = const Value.absent(),
    this.nfact = const Value.absent(),
    this.refart = const Value.absent(),
    this.qe = const Value.absent(),
    this.entres = const Value.absent(),
    this.qs = const Value.absent(),
    this.pus = const Value.absent(),
    this.sortie = const Value.absent(),
    this.stocksu1 = const Value.absent(),
    this.numventes = const Value.absent(),
    this.ue = const Value.absent(),
    this.us = const Value.absent(),
    this.stocksu2 = const Value.absent(),
    this.stocksu3 = const Value.absent(),
    this.depots = const Value.absent(),
    this.cmup = const Value.absent(),
    this.clt = const Value.absent(),
    this.frns = const Value.absent(),
    this.verification = const Value.absent(),
    this.stkdep = const Value.absent(),
    this.marq = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : ref = Value(ref);
  static Insertable<Stock> custom({
    Expression<String>? ref,
    Expression<DateTime>? daty,
    Expression<String>? lib,
    Expression<String>? numachats,
    Expression<String>? nfact,
    Expression<String>? refart,
    Expression<double>? qe,
    Expression<double>? entres,
    Expression<double>? qs,
    Expression<double>? pus,
    Expression<double>? sortie,
    Expression<double>? stocksu1,
    Expression<String>? numventes,
    Expression<String>? ue,
    Expression<String>? us,
    Expression<double>? stocksu2,
    Expression<double>? stocksu3,
    Expression<String>? depots,
    Expression<double>? cmup,
    Expression<String>? clt,
    Expression<String>? frns,
    Expression<String>? verification,
    Expression<double>? stkdep,
    Expression<String>? marq,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (ref != null) 'ref': ref,
      if (daty != null) 'daty': daty,
      if (lib != null) 'lib': lib,
      if (numachats != null) 'numachats': numachats,
      if (nfact != null) 'nfact': nfact,
      if (refart != null) 'refart': refart,
      if (qe != null) 'qe': qe,
      if (entres != null) 'entres': entres,
      if (qs != null) 'qs': qs,
      if (pus != null) 'pus': pus,
      if (sortie != null) 'sortie': sortie,
      if (stocksu1 != null) 'stocksu1': stocksu1,
      if (numventes != null) 'numventes': numventes,
      if (ue != null) 'ue': ue,
      if (us != null) 'us': us,
      if (stocksu2 != null) 'stocksu2': stocksu2,
      if (stocksu3 != null) 'stocksu3': stocksu3,
      if (depots != null) 'depots': depots,
      if (cmup != null) 'cmup': cmup,
      if (clt != null) 'clt': clt,
      if (frns != null) 'frns': frns,
      if (verification != null) 'verification': verification,
      if (stkdep != null) 'stkdep': stkdep,
      if (marq != null) 'marq': marq,
      if (rowid != null) 'rowid': rowid,
    });
  }

  StocksCompanion copyWith(
      {Value<String>? ref,
      Value<DateTime?>? daty,
      Value<String?>? lib,
      Value<String?>? numachats,
      Value<String?>? nfact,
      Value<String?>? refart,
      Value<double?>? qe,
      Value<double?>? entres,
      Value<double?>? qs,
      Value<double?>? pus,
      Value<double?>? sortie,
      Value<double?>? stocksu1,
      Value<String?>? numventes,
      Value<String?>? ue,
      Value<String?>? us,
      Value<double?>? stocksu2,
      Value<double?>? stocksu3,
      Value<String?>? depots,
      Value<double?>? cmup,
      Value<String?>? clt,
      Value<String?>? frns,
      Value<String?>? verification,
      Value<double?>? stkdep,
      Value<String?>? marq,
      Value<int>? rowid}) {
    return StocksCompanion(
      ref: ref ?? this.ref,
      daty: daty ?? this.daty,
      lib: lib ?? this.lib,
      numachats: numachats ?? this.numachats,
      nfact: nfact ?? this.nfact,
      refart: refart ?? this.refart,
      qe: qe ?? this.qe,
      entres: entres ?? this.entres,
      qs: qs ?? this.qs,
      pus: pus ?? this.pus,
      sortie: sortie ?? this.sortie,
      stocksu1: stocksu1 ?? this.stocksu1,
      numventes: numventes ?? this.numventes,
      ue: ue ?? this.ue,
      us: us ?? this.us,
      stocksu2: stocksu2 ?? this.stocksu2,
      stocksu3: stocksu3 ?? this.stocksu3,
      depots: depots ?? this.depots,
      cmup: cmup ?? this.cmup,
      clt: clt ?? this.clt,
      frns: frns ?? this.frns,
      verification: verification ?? this.verification,
      stkdep: stkdep ?? this.stkdep,
      marq: marq ?? this.marq,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (ref.present) {
      map['ref'] = Variable<String>(ref.value);
    }
    if (daty.present) {
      map['daty'] = Variable<DateTime>(daty.value);
    }
    if (lib.present) {
      map['lib'] = Variable<String>(lib.value);
    }
    if (numachats.present) {
      map['numachats'] = Variable<String>(numachats.value);
    }
    if (nfact.present) {
      map['nfact'] = Variable<String>(nfact.value);
    }
    if (refart.present) {
      map['refart'] = Variable<String>(refart.value);
    }
    if (qe.present) {
      map['qe'] = Variable<double>(qe.value);
    }
    if (entres.present) {
      map['entres'] = Variable<double>(entres.value);
    }
    if (qs.present) {
      map['qs'] = Variable<double>(qs.value);
    }
    if (pus.present) {
      map['pus'] = Variable<double>(pus.value);
    }
    if (sortie.present) {
      map['sortie'] = Variable<double>(sortie.value);
    }
    if (stocksu1.present) {
      map['stocksu1'] = Variable<double>(stocksu1.value);
    }
    if (numventes.present) {
      map['numventes'] = Variable<String>(numventes.value);
    }
    if (ue.present) {
      map['ue'] = Variable<String>(ue.value);
    }
    if (us.present) {
      map['us'] = Variable<String>(us.value);
    }
    if (stocksu2.present) {
      map['stocksu2'] = Variable<double>(stocksu2.value);
    }
    if (stocksu3.present) {
      map['stocksu3'] = Variable<double>(stocksu3.value);
    }
    if (depots.present) {
      map['depots'] = Variable<String>(depots.value);
    }
    if (cmup.present) {
      map['cmup'] = Variable<double>(cmup.value);
    }
    if (clt.present) {
      map['clt'] = Variable<String>(clt.value);
    }
    if (frns.present) {
      map['frns'] = Variable<String>(frns.value);
    }
    if (verification.present) {
      map['verification'] = Variable<String>(verification.value);
    }
    if (stkdep.present) {
      map['stkdep'] = Variable<double>(stkdep.value);
    }
    if (marq.present) {
      map['marq'] = Variable<String>(marq.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StocksCompanion(')
          ..write('ref: $ref, ')
          ..write('daty: $daty, ')
          ..write('lib: $lib, ')
          ..write('numachats: $numachats, ')
          ..write('nfact: $nfact, ')
          ..write('refart: $refart, ')
          ..write('qe: $qe, ')
          ..write('entres: $entres, ')
          ..write('qs: $qs, ')
          ..write('pus: $pus, ')
          ..write('sortie: $sortie, ')
          ..write('stocksu1: $stocksu1, ')
          ..write('numventes: $numventes, ')
          ..write('ue: $ue, ')
          ..write('us: $us, ')
          ..write('stocksu2: $stocksu2, ')
          ..write('stocksu3: $stocksu3, ')
          ..write('depots: $depots, ')
          ..write('cmup: $cmup, ')
          ..write('clt: $clt, ')
          ..write('frns: $frns, ')
          ..write('verification: $verification, ')
          ..write('stkdep: $stkdep, ')
          ..write('marq: $marq, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $AutrescompteTable extends Autrescompte
    with TableInfo<$AutrescompteTable, AutrescompteData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AutrescompteTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _refMeta = const VerificationMeta('ref');
  @override
  late final GeneratedColumn<String> ref = GeneratedColumn<String>(
      'ref', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _datyMeta = const VerificationMeta('daty');
  @override
  late final GeneratedColumn<DateTime> daty = GeneratedColumn<DateTime>(
      'daty', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _libMeta = const VerificationMeta('lib');
  @override
  late final GeneratedColumn<String> lib = GeneratedColumn<String>(
      'lib', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _compteMeta = const VerificationMeta('compte');
  @override
  late final GeneratedColumn<String> compte = GeneratedColumn<String>(
      'compte', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _entresMeta = const VerificationMeta('entres');
  @override
  late final GeneratedColumn<double> entres = GeneratedColumn<double>(
      'entres', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _sortieMeta = const VerificationMeta('sortie');
  @override
  late final GeneratedColumn<double> sortie = GeneratedColumn<double>(
      'sortie', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _soldeMeta = const VerificationMeta('solde');
  @override
  late final GeneratedColumn<double> solde = GeneratedColumn<double>(
      'solde', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns =>
      [ref, daty, lib, code, compte, entres, sortie, solde];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'autrescompte';
  @override
  VerificationContext validateIntegrity(Insertable<AutrescompteData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('ref')) {
      context.handle(
          _refMeta, ref.isAcceptableOrUnknown(data['ref']!, _refMeta));
    } else if (isInserting) {
      context.missing(_refMeta);
    }
    if (data.containsKey('daty')) {
      context.handle(
          _datyMeta, daty.isAcceptableOrUnknown(data['daty']!, _datyMeta));
    }
    if (data.containsKey('lib')) {
      context.handle(
          _libMeta, lib.isAcceptableOrUnknown(data['lib']!, _libMeta));
    }
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    }
    if (data.containsKey('compte')) {
      context.handle(_compteMeta,
          compte.isAcceptableOrUnknown(data['compte']!, _compteMeta));
    }
    if (data.containsKey('entres')) {
      context.handle(_entresMeta,
          entres.isAcceptableOrUnknown(data['entres']!, _entresMeta));
    }
    if (data.containsKey('sortie')) {
      context.handle(_sortieMeta,
          sortie.isAcceptableOrUnknown(data['sortie']!, _sortieMeta));
    }
    if (data.containsKey('solde')) {
      context.handle(
          _soldeMeta, solde.isAcceptableOrUnknown(data['solde']!, _soldeMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {ref};
  @override
  AutrescompteData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AutrescompteData(
      ref: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}ref'])!,
      daty: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}daty']),
      lib: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}lib']),
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code']),
      compte: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}compte']),
      entres: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}entres']),
      sortie: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}sortie']),
      solde: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}solde']),
    );
  }

  @override
  $AutrescompteTable createAlias(String alias) {
    return $AutrescompteTable(attachedDatabase, alias);
  }
}

class AutrescompteData extends DataClass
    implements Insertable<AutrescompteData> {
  final String ref;
  final DateTime? daty;
  final String? lib;
  final String? code;
  final String? compte;
  final double? entres;
  final double? sortie;
  final double? solde;
  const AutrescompteData(
      {required this.ref,
      this.daty,
      this.lib,
      this.code,
      this.compte,
      this.entres,
      this.sortie,
      this.solde});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['ref'] = Variable<String>(ref);
    if (!nullToAbsent || daty != null) {
      map['daty'] = Variable<DateTime>(daty);
    }
    if (!nullToAbsent || lib != null) {
      map['lib'] = Variable<String>(lib);
    }
    if (!nullToAbsent || code != null) {
      map['code'] = Variable<String>(code);
    }
    if (!nullToAbsent || compte != null) {
      map['compte'] = Variable<String>(compte);
    }
    if (!nullToAbsent || entres != null) {
      map['entres'] = Variable<double>(entres);
    }
    if (!nullToAbsent || sortie != null) {
      map['sortie'] = Variable<double>(sortie);
    }
    if (!nullToAbsent || solde != null) {
      map['solde'] = Variable<double>(solde);
    }
    return map;
  }

  AutrescompteCompanion toCompanion(bool nullToAbsent) {
    return AutrescompteCompanion(
      ref: Value(ref),
      daty: daty == null && nullToAbsent ? const Value.absent() : Value(daty),
      lib: lib == null && nullToAbsent ? const Value.absent() : Value(lib),
      code: code == null && nullToAbsent ? const Value.absent() : Value(code),
      compte:
          compte == null && nullToAbsent ? const Value.absent() : Value(compte),
      entres:
          entres == null && nullToAbsent ? const Value.absent() : Value(entres),
      sortie:
          sortie == null && nullToAbsent ? const Value.absent() : Value(sortie),
      solde:
          solde == null && nullToAbsent ? const Value.absent() : Value(solde),
    );
  }

  factory AutrescompteData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AutrescompteData(
      ref: serializer.fromJson<String>(json['ref']),
      daty: serializer.fromJson<DateTime?>(json['daty']),
      lib: serializer.fromJson<String?>(json['lib']),
      code: serializer.fromJson<String?>(json['code']),
      compte: serializer.fromJson<String?>(json['compte']),
      entres: serializer.fromJson<double?>(json['entres']),
      sortie: serializer.fromJson<double?>(json['sortie']),
      solde: serializer.fromJson<double?>(json['solde']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'ref': serializer.toJson<String>(ref),
      'daty': serializer.toJson<DateTime?>(daty),
      'lib': serializer.toJson<String?>(lib),
      'code': serializer.toJson<String?>(code),
      'compte': serializer.toJson<String?>(compte),
      'entres': serializer.toJson<double?>(entres),
      'sortie': serializer.toJson<double?>(sortie),
      'solde': serializer.toJson<double?>(solde),
    };
  }

  AutrescompteData copyWith(
          {String? ref,
          Value<DateTime?> daty = const Value.absent(),
          Value<String?> lib = const Value.absent(),
          Value<String?> code = const Value.absent(),
          Value<String?> compte = const Value.absent(),
          Value<double?> entres = const Value.absent(),
          Value<double?> sortie = const Value.absent(),
          Value<double?> solde = const Value.absent()}) =>
      AutrescompteData(
        ref: ref ?? this.ref,
        daty: daty.present ? daty.value : this.daty,
        lib: lib.present ? lib.value : this.lib,
        code: code.present ? code.value : this.code,
        compte: compte.present ? compte.value : this.compte,
        entres: entres.present ? entres.value : this.entres,
        sortie: sortie.present ? sortie.value : this.sortie,
        solde: solde.present ? solde.value : this.solde,
      );
  AutrescompteData copyWithCompanion(AutrescompteCompanion data) {
    return AutrescompteData(
      ref: data.ref.present ? data.ref.value : this.ref,
      daty: data.daty.present ? data.daty.value : this.daty,
      lib: data.lib.present ? data.lib.value : this.lib,
      code: data.code.present ? data.code.value : this.code,
      compte: data.compte.present ? data.compte.value : this.compte,
      entres: data.entres.present ? data.entres.value : this.entres,
      sortie: data.sortie.present ? data.sortie.value : this.sortie,
      solde: data.solde.present ? data.solde.value : this.solde,
    );
  }

  @override
  String toString() {
    return (StringBuffer('AutrescompteData(')
          ..write('ref: $ref, ')
          ..write('daty: $daty, ')
          ..write('lib: $lib, ')
          ..write('code: $code, ')
          ..write('compte: $compte, ')
          ..write('entres: $entres, ')
          ..write('sortie: $sortie, ')
          ..write('solde: $solde')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(ref, daty, lib, code, compte, entres, sortie, solde);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AutrescompteData &&
          other.ref == this.ref &&
          other.daty == this.daty &&
          other.lib == this.lib &&
          other.code == this.code &&
          other.compte == this.compte &&
          other.entres == this.entres &&
          other.sortie == this.sortie &&
          other.solde == this.solde);
}

class AutrescompteCompanion extends UpdateCompanion<AutrescompteData> {
  final Value<String> ref;
  final Value<DateTime?> daty;
  final Value<String?> lib;
  final Value<String?> code;
  final Value<String?> compte;
  final Value<double?> entres;
  final Value<double?> sortie;
  final Value<double?> solde;
  final Value<int> rowid;
  const AutrescompteCompanion({
    this.ref = const Value.absent(),
    this.daty = const Value.absent(),
    this.lib = const Value.absent(),
    this.code = const Value.absent(),
    this.compte = const Value.absent(),
    this.entres = const Value.absent(),
    this.sortie = const Value.absent(),
    this.solde = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  AutrescompteCompanion.insert({
    required String ref,
    this.daty = const Value.absent(),
    this.lib = const Value.absent(),
    this.code = const Value.absent(),
    this.compte = const Value.absent(),
    this.entres = const Value.absent(),
    this.sortie = const Value.absent(),
    this.solde = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : ref = Value(ref);
  static Insertable<AutrescompteData> custom({
    Expression<String>? ref,
    Expression<DateTime>? daty,
    Expression<String>? lib,
    Expression<String>? code,
    Expression<String>? compte,
    Expression<double>? entres,
    Expression<double>? sortie,
    Expression<double>? solde,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (ref != null) 'ref': ref,
      if (daty != null) 'daty': daty,
      if (lib != null) 'lib': lib,
      if (code != null) 'code': code,
      if (compte != null) 'compte': compte,
      if (entres != null) 'entres': entres,
      if (sortie != null) 'sortie': sortie,
      if (solde != null) 'solde': solde,
      if (rowid != null) 'rowid': rowid,
    });
  }

  AutrescompteCompanion copyWith(
      {Value<String>? ref,
      Value<DateTime?>? daty,
      Value<String?>? lib,
      Value<String?>? code,
      Value<String?>? compte,
      Value<double?>? entres,
      Value<double?>? sortie,
      Value<double?>? solde,
      Value<int>? rowid}) {
    return AutrescompteCompanion(
      ref: ref ?? this.ref,
      daty: daty ?? this.daty,
      lib: lib ?? this.lib,
      code: code ?? this.code,
      compte: compte ?? this.compte,
      entres: entres ?? this.entres,
      sortie: sortie ?? this.sortie,
      solde: solde ?? this.solde,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (ref.present) {
      map['ref'] = Variable<String>(ref.value);
    }
    if (daty.present) {
      map['daty'] = Variable<DateTime>(daty.value);
    }
    if (lib.present) {
      map['lib'] = Variable<String>(lib.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (compte.present) {
      map['compte'] = Variable<String>(compte.value);
    }
    if (entres.present) {
      map['entres'] = Variable<double>(entres.value);
    }
    if (sortie.present) {
      map['sortie'] = Variable<double>(sortie.value);
    }
    if (solde.present) {
      map['solde'] = Variable<double>(solde.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AutrescompteCompanion(')
          ..write('ref: $ref, ')
          ..write('daty: $daty, ')
          ..write('lib: $lib, ')
          ..write('code: $code, ')
          ..write('compte: $compte, ')
          ..write('entres: $entres, ')
          ..write('sortie: $sortie, ')
          ..write('solde: $solde, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $BanqueTable extends Banque with TableInfo<$BanqueTable, BanqueData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BanqueTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _refMeta = const VerificationMeta('ref');
  @override
  late final GeneratedColumn<String> ref = GeneratedColumn<String>(
      'ref', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _datyMeta = const VerificationMeta('daty');
  @override
  late final GeneratedColumn<DateTime> daty = GeneratedColumn<DateTime>(
      'daty', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _libMeta = const VerificationMeta('lib');
  @override
  late final GeneratedColumn<String> lib = GeneratedColumn<String>(
      'lib', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _debitMeta = const VerificationMeta('debit');
  @override
  late final GeneratedColumn<double> debit = GeneratedColumn<double>(
      'debit', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _creditMeta = const VerificationMeta('credit');
  @override
  late final GeneratedColumn<double> credit = GeneratedColumn<double>(
      'credit', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _soldesMeta = const VerificationMeta('soldes');
  @override
  late final GeneratedColumn<double> soldes = GeneratedColumn<double>(
      'soldes', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
      'type', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _cltMeta = const VerificationMeta('clt');
  @override
  late final GeneratedColumn<String> clt = GeneratedColumn<String>(
      'clt', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _frnsMeta = const VerificationMeta('frns');
  @override
  late final GeneratedColumn<String> frns = GeneratedColumn<String>(
      'frns', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _verificationMeta =
      const VerificationMeta('verification');
  @override
  late final GeneratedColumn<String> verification = GeneratedColumn<String>(
      'verification', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _comptesMeta =
      const VerificationMeta('comptes');
  @override
  late final GeneratedColumn<String> comptes = GeneratedColumn<String>(
      'comptes', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        ref,
        daty,
        lib,
        debit,
        credit,
        soldes,
        code,
        type,
        clt,
        frns,
        verification,
        comptes
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'banque';
  @override
  VerificationContext validateIntegrity(Insertable<BanqueData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('ref')) {
      context.handle(
          _refMeta, ref.isAcceptableOrUnknown(data['ref']!, _refMeta));
    } else if (isInserting) {
      context.missing(_refMeta);
    }
    if (data.containsKey('daty')) {
      context.handle(
          _datyMeta, daty.isAcceptableOrUnknown(data['daty']!, _datyMeta));
    }
    if (data.containsKey('lib')) {
      context.handle(
          _libMeta, lib.isAcceptableOrUnknown(data['lib']!, _libMeta));
    }
    if (data.containsKey('debit')) {
      context.handle(
          _debitMeta, debit.isAcceptableOrUnknown(data['debit']!, _debitMeta));
    }
    if (data.containsKey('credit')) {
      context.handle(_creditMeta,
          credit.isAcceptableOrUnknown(data['credit']!, _creditMeta));
    }
    if (data.containsKey('soldes')) {
      context.handle(_soldesMeta,
          soldes.isAcceptableOrUnknown(data['soldes']!, _soldesMeta));
    }
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    }
    if (data.containsKey('type')) {
      context.handle(
          _typeMeta, type.isAcceptableOrUnknown(data['type']!, _typeMeta));
    }
    if (data.containsKey('clt')) {
      context.handle(
          _cltMeta, clt.isAcceptableOrUnknown(data['clt']!, _cltMeta));
    }
    if (data.containsKey('frns')) {
      context.handle(
          _frnsMeta, frns.isAcceptableOrUnknown(data['frns']!, _frnsMeta));
    }
    if (data.containsKey('verification')) {
      context.handle(
          _verificationMeta,
          verification.isAcceptableOrUnknown(
              data['verification']!, _verificationMeta));
    }
    if (data.containsKey('comptes')) {
      context.handle(_comptesMeta,
          comptes.isAcceptableOrUnknown(data['comptes']!, _comptesMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {ref};
  @override
  BanqueData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BanqueData(
      ref: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}ref'])!,
      daty: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}daty']),
      lib: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}lib']),
      debit: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}debit']),
      credit: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}credit']),
      soldes: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}soldes']),
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code']),
      type: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type']),
      clt: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}clt']),
      frns: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}frns']),
      verification: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}verification']),
      comptes: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}comptes']),
    );
  }

  @override
  $BanqueTable createAlias(String alias) {
    return $BanqueTable(attachedDatabase, alias);
  }
}

class BanqueData extends DataClass implements Insertable<BanqueData> {
  final String ref;
  final DateTime? daty;
  final String? lib;
  final double? debit;
  final double? credit;
  final double? soldes;
  final String? code;
  final String? type;
  final String? clt;
  final String? frns;
  final String? verification;
  final String? comptes;
  const BanqueData(
      {required this.ref,
      this.daty,
      this.lib,
      this.debit,
      this.credit,
      this.soldes,
      this.code,
      this.type,
      this.clt,
      this.frns,
      this.verification,
      this.comptes});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['ref'] = Variable<String>(ref);
    if (!nullToAbsent || daty != null) {
      map['daty'] = Variable<DateTime>(daty);
    }
    if (!nullToAbsent || lib != null) {
      map['lib'] = Variable<String>(lib);
    }
    if (!nullToAbsent || debit != null) {
      map['debit'] = Variable<double>(debit);
    }
    if (!nullToAbsent || credit != null) {
      map['credit'] = Variable<double>(credit);
    }
    if (!nullToAbsent || soldes != null) {
      map['soldes'] = Variable<double>(soldes);
    }
    if (!nullToAbsent || code != null) {
      map['code'] = Variable<String>(code);
    }
    if (!nullToAbsent || type != null) {
      map['type'] = Variable<String>(type);
    }
    if (!nullToAbsent || clt != null) {
      map['clt'] = Variable<String>(clt);
    }
    if (!nullToAbsent || frns != null) {
      map['frns'] = Variable<String>(frns);
    }
    if (!nullToAbsent || verification != null) {
      map['verification'] = Variable<String>(verification);
    }
    if (!nullToAbsent || comptes != null) {
      map['comptes'] = Variable<String>(comptes);
    }
    return map;
  }

  BanqueCompanion toCompanion(bool nullToAbsent) {
    return BanqueCompanion(
      ref: Value(ref),
      daty: daty == null && nullToAbsent ? const Value.absent() : Value(daty),
      lib: lib == null && nullToAbsent ? const Value.absent() : Value(lib),
      debit:
          debit == null && nullToAbsent ? const Value.absent() : Value(debit),
      credit:
          credit == null && nullToAbsent ? const Value.absent() : Value(credit),
      soldes:
          soldes == null && nullToAbsent ? const Value.absent() : Value(soldes),
      code: code == null && nullToAbsent ? const Value.absent() : Value(code),
      type: type == null && nullToAbsent ? const Value.absent() : Value(type),
      clt: clt == null && nullToAbsent ? const Value.absent() : Value(clt),
      frns: frns == null && nullToAbsent ? const Value.absent() : Value(frns),
      verification: verification == null && nullToAbsent
          ? const Value.absent()
          : Value(verification),
      comptes: comptes == null && nullToAbsent
          ? const Value.absent()
          : Value(comptes),
    );
  }

  factory BanqueData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BanqueData(
      ref: serializer.fromJson<String>(json['ref']),
      daty: serializer.fromJson<DateTime?>(json['daty']),
      lib: serializer.fromJson<String?>(json['lib']),
      debit: serializer.fromJson<double?>(json['debit']),
      credit: serializer.fromJson<double?>(json['credit']),
      soldes: serializer.fromJson<double?>(json['soldes']),
      code: serializer.fromJson<String?>(json['code']),
      type: serializer.fromJson<String?>(json['type']),
      clt: serializer.fromJson<String?>(json['clt']),
      frns: serializer.fromJson<String?>(json['frns']),
      verification: serializer.fromJson<String?>(json['verification']),
      comptes: serializer.fromJson<String?>(json['comptes']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'ref': serializer.toJson<String>(ref),
      'daty': serializer.toJson<DateTime?>(daty),
      'lib': serializer.toJson<String?>(lib),
      'debit': serializer.toJson<double?>(debit),
      'credit': serializer.toJson<double?>(credit),
      'soldes': serializer.toJson<double?>(soldes),
      'code': serializer.toJson<String?>(code),
      'type': serializer.toJson<String?>(type),
      'clt': serializer.toJson<String?>(clt),
      'frns': serializer.toJson<String?>(frns),
      'verification': serializer.toJson<String?>(verification),
      'comptes': serializer.toJson<String?>(comptes),
    };
  }

  BanqueData copyWith(
          {String? ref,
          Value<DateTime?> daty = const Value.absent(),
          Value<String?> lib = const Value.absent(),
          Value<double?> debit = const Value.absent(),
          Value<double?> credit = const Value.absent(),
          Value<double?> soldes = const Value.absent(),
          Value<String?> code = const Value.absent(),
          Value<String?> type = const Value.absent(),
          Value<String?> clt = const Value.absent(),
          Value<String?> frns = const Value.absent(),
          Value<String?> verification = const Value.absent(),
          Value<String?> comptes = const Value.absent()}) =>
      BanqueData(
        ref: ref ?? this.ref,
        daty: daty.present ? daty.value : this.daty,
        lib: lib.present ? lib.value : this.lib,
        debit: debit.present ? debit.value : this.debit,
        credit: credit.present ? credit.value : this.credit,
        soldes: soldes.present ? soldes.value : this.soldes,
        code: code.present ? code.value : this.code,
        type: type.present ? type.value : this.type,
        clt: clt.present ? clt.value : this.clt,
        frns: frns.present ? frns.value : this.frns,
        verification:
            verification.present ? verification.value : this.verification,
        comptes: comptes.present ? comptes.value : this.comptes,
      );
  BanqueData copyWithCompanion(BanqueCompanion data) {
    return BanqueData(
      ref: data.ref.present ? data.ref.value : this.ref,
      daty: data.daty.present ? data.daty.value : this.daty,
      lib: data.lib.present ? data.lib.value : this.lib,
      debit: data.debit.present ? data.debit.value : this.debit,
      credit: data.credit.present ? data.credit.value : this.credit,
      soldes: data.soldes.present ? data.soldes.value : this.soldes,
      code: data.code.present ? data.code.value : this.code,
      type: data.type.present ? data.type.value : this.type,
      clt: data.clt.present ? data.clt.value : this.clt,
      frns: data.frns.present ? data.frns.value : this.frns,
      verification: data.verification.present
          ? data.verification.value
          : this.verification,
      comptes: data.comptes.present ? data.comptes.value : this.comptes,
    );
  }

  @override
  String toString() {
    return (StringBuffer('BanqueData(')
          ..write('ref: $ref, ')
          ..write('daty: $daty, ')
          ..write('lib: $lib, ')
          ..write('debit: $debit, ')
          ..write('credit: $credit, ')
          ..write('soldes: $soldes, ')
          ..write('code: $code, ')
          ..write('type: $type, ')
          ..write('clt: $clt, ')
          ..write('frns: $frns, ')
          ..write('verification: $verification, ')
          ..write('comptes: $comptes')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(ref, daty, lib, debit, credit, soldes, code,
      type, clt, frns, verification, comptes);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BanqueData &&
          other.ref == this.ref &&
          other.daty == this.daty &&
          other.lib == this.lib &&
          other.debit == this.debit &&
          other.credit == this.credit &&
          other.soldes == this.soldes &&
          other.code == this.code &&
          other.type == this.type &&
          other.clt == this.clt &&
          other.frns == this.frns &&
          other.verification == this.verification &&
          other.comptes == this.comptes);
}

class BanqueCompanion extends UpdateCompanion<BanqueData> {
  final Value<String> ref;
  final Value<DateTime?> daty;
  final Value<String?> lib;
  final Value<double?> debit;
  final Value<double?> credit;
  final Value<double?> soldes;
  final Value<String?> code;
  final Value<String?> type;
  final Value<String?> clt;
  final Value<String?> frns;
  final Value<String?> verification;
  final Value<String?> comptes;
  final Value<int> rowid;
  const BanqueCompanion({
    this.ref = const Value.absent(),
    this.daty = const Value.absent(),
    this.lib = const Value.absent(),
    this.debit = const Value.absent(),
    this.credit = const Value.absent(),
    this.soldes = const Value.absent(),
    this.code = const Value.absent(),
    this.type = const Value.absent(),
    this.clt = const Value.absent(),
    this.frns = const Value.absent(),
    this.verification = const Value.absent(),
    this.comptes = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  BanqueCompanion.insert({
    required String ref,
    this.daty = const Value.absent(),
    this.lib = const Value.absent(),
    this.debit = const Value.absent(),
    this.credit = const Value.absent(),
    this.soldes = const Value.absent(),
    this.code = const Value.absent(),
    this.type = const Value.absent(),
    this.clt = const Value.absent(),
    this.frns = const Value.absent(),
    this.verification = const Value.absent(),
    this.comptes = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : ref = Value(ref);
  static Insertable<BanqueData> custom({
    Expression<String>? ref,
    Expression<DateTime>? daty,
    Expression<String>? lib,
    Expression<double>? debit,
    Expression<double>? credit,
    Expression<double>? soldes,
    Expression<String>? code,
    Expression<String>? type,
    Expression<String>? clt,
    Expression<String>? frns,
    Expression<String>? verification,
    Expression<String>? comptes,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (ref != null) 'ref': ref,
      if (daty != null) 'daty': daty,
      if (lib != null) 'lib': lib,
      if (debit != null) 'debit': debit,
      if (credit != null) 'credit': credit,
      if (soldes != null) 'soldes': soldes,
      if (code != null) 'code': code,
      if (type != null) 'type': type,
      if (clt != null) 'clt': clt,
      if (frns != null) 'frns': frns,
      if (verification != null) 'verification': verification,
      if (comptes != null) 'comptes': comptes,
      if (rowid != null) 'rowid': rowid,
    });
  }

  BanqueCompanion copyWith(
      {Value<String>? ref,
      Value<DateTime?>? daty,
      Value<String?>? lib,
      Value<double?>? debit,
      Value<double?>? credit,
      Value<double?>? soldes,
      Value<String?>? code,
      Value<String?>? type,
      Value<String?>? clt,
      Value<String?>? frns,
      Value<String?>? verification,
      Value<String?>? comptes,
      Value<int>? rowid}) {
    return BanqueCompanion(
      ref: ref ?? this.ref,
      daty: daty ?? this.daty,
      lib: lib ?? this.lib,
      debit: debit ?? this.debit,
      credit: credit ?? this.credit,
      soldes: soldes ?? this.soldes,
      code: code ?? this.code,
      type: type ?? this.type,
      clt: clt ?? this.clt,
      frns: frns ?? this.frns,
      verification: verification ?? this.verification,
      comptes: comptes ?? this.comptes,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (ref.present) {
      map['ref'] = Variable<String>(ref.value);
    }
    if (daty.present) {
      map['daty'] = Variable<DateTime>(daty.value);
    }
    if (lib.present) {
      map['lib'] = Variable<String>(lib.value);
    }
    if (debit.present) {
      map['debit'] = Variable<double>(debit.value);
    }
    if (credit.present) {
      map['credit'] = Variable<double>(credit.value);
    }
    if (soldes.present) {
      map['soldes'] = Variable<double>(soldes.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (clt.present) {
      map['clt'] = Variable<String>(clt.value);
    }
    if (frns.present) {
      map['frns'] = Variable<String>(frns.value);
    }
    if (verification.present) {
      map['verification'] = Variable<String>(verification.value);
    }
    if (comptes.present) {
      map['comptes'] = Variable<String>(comptes.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BanqueCompanion(')
          ..write('ref: $ref, ')
          ..write('daty: $daty, ')
          ..write('lib: $lib, ')
          ..write('debit: $debit, ')
          ..write('credit: $credit, ')
          ..write('soldes: $soldes, ')
          ..write('code: $code, ')
          ..write('type: $type, ')
          ..write('clt: $clt, ')
          ..write('frns: $frns, ')
          ..write('verification: $verification, ')
          ..write('comptes: $comptes, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $BlcltTable extends Blclt with TableInfo<$BlcltTable, BlcltData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BlcltTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _numMeta = const VerificationMeta('num');
  @override
  late final GeneratedColumn<int> num = GeneratedColumn<int>(
      'num', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _numventesMeta =
      const VerificationMeta('numventes');
  @override
  late final GeneratedColumn<String> numventes = GeneratedColumn<String>(
      'numventes', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _nfactMeta = const VerificationMeta('nfact');
  @override
  late final GeneratedColumn<String> nfact = GeneratedColumn<String>(
      'nfact', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _datyMeta = const VerificationMeta('daty');
  @override
  late final GeneratedColumn<DateTime> daty = GeneratedColumn<DateTime>(
      'daty', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _cltMeta = const VerificationMeta('clt');
  @override
  late final GeneratedColumn<String> clt = GeneratedColumn<String>(
      'clt', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _ecrptancebiMeta =
      const VerificationMeta('ecrptancebi');
  @override
  late final GeneratedColumn<String> ecrptancebi = GeneratedColumn<String>(
      'ecrptancebi', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _montantMeta =
      const VerificationMeta('montant');
  @override
  late final GeneratedColumn<double> montant = GeneratedColumn<double>(
      'montant', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _mpMeta = const VerificationMeta('mp');
  @override
  late final GeneratedColumn<String> mp = GeneratedColumn<String>(
      'mp', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _libpaiementMeta =
      const VerificationMeta('libpaiement');
  @override
  late final GeneratedColumn<String> libpaiement = GeneratedColumn<String>(
      'libpaiement', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _echeancepaiementMeta =
      const VerificationMeta('echeancepaiement');
  @override
  late final GeneratedColumn<DateTime> echeancepaiement =
      GeneratedColumn<DateTime>('echeancepaiement', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _rapMeta = const VerificationMeta('rap');
  @override
  late final GeneratedColumn<double> rap = GeneratedColumn<double>(
      'rap', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _comMeta = const VerificationMeta('com');
  @override
  late final GeneratedColumn<String> com = GeneratedColumn<String>(
      'com', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _verificationMeta =
      const VerificationMeta('verification');
  @override
  late final GeneratedColumn<String> verification = GeneratedColumn<String>(
      'verification', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        num,
        numventes,
        nfact,
        daty,
        clt,
        ecrptancebi,
        montant,
        mp,
        libpaiement,
        echeancepaiement,
        rap,
        com,
        verification
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'blclt';
  @override
  VerificationContext validateIntegrity(Insertable<BlcltData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('num')) {
      context.handle(
          _numMeta, num.isAcceptableOrUnknown(data['num']!, _numMeta));
    }
    if (data.containsKey('numventes')) {
      context.handle(_numventesMeta,
          numventes.isAcceptableOrUnknown(data['numventes']!, _numventesMeta));
    }
    if (data.containsKey('nfact')) {
      context.handle(
          _nfactMeta, nfact.isAcceptableOrUnknown(data['nfact']!, _nfactMeta));
    }
    if (data.containsKey('daty')) {
      context.handle(
          _datyMeta, daty.isAcceptableOrUnknown(data['daty']!, _datyMeta));
    }
    if (data.containsKey('clt')) {
      context.handle(
          _cltMeta, clt.isAcceptableOrUnknown(data['clt']!, _cltMeta));
    }
    if (data.containsKey('ecrptancebi')) {
      context.handle(
          _ecrptancebiMeta,
          ecrptancebi.isAcceptableOrUnknown(
              data['ecrptancebi']!, _ecrptancebiMeta));
    }
    if (data.containsKey('montant')) {
      context.handle(_montantMeta,
          montant.isAcceptableOrUnknown(data['montant']!, _montantMeta));
    }
    if (data.containsKey('mp')) {
      context.handle(_mpMeta, mp.isAcceptableOrUnknown(data['mp']!, _mpMeta));
    }
    if (data.containsKey('libpaiement')) {
      context.handle(
          _libpaiementMeta,
          libpaiement.isAcceptableOrUnknown(
              data['libpaiement']!, _libpaiementMeta));
    }
    if (data.containsKey('echeancepaiement')) {
      context.handle(
          _echeancepaiementMeta,
          echeancepaiement.isAcceptableOrUnknown(
              data['echeancepaiement']!, _echeancepaiementMeta));
    }
    if (data.containsKey('rap')) {
      context.handle(
          _rapMeta, rap.isAcceptableOrUnknown(data['rap']!, _rapMeta));
    }
    if (data.containsKey('com')) {
      context.handle(
          _comMeta, com.isAcceptableOrUnknown(data['com']!, _comMeta));
    }
    if (data.containsKey('verification')) {
      context.handle(
          _verificationMeta,
          verification.isAcceptableOrUnknown(
              data['verification']!, _verificationMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {num};
  @override
  BlcltData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BlcltData(
      num: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}num'])!,
      numventes: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}numventes']),
      nfact: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}nfact']),
      daty: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}daty']),
      clt: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}clt']),
      ecrptancebi: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}ecrptancebi']),
      montant: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}montant']),
      mp: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}mp']),
      libpaiement: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}libpaiement']),
      echeancepaiement: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}echeancepaiement']),
      rap: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}rap']),
      com: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}com']),
      verification: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}verification']),
    );
  }

  @override
  $BlcltTable createAlias(String alias) {
    return $BlcltTable(attachedDatabase, alias);
  }
}

class BlcltData extends DataClass implements Insertable<BlcltData> {
  final int num;
  final String? numventes;
  final String? nfact;
  final DateTime? daty;
  final String? clt;
  final String? ecrptancebi;
  final double? montant;
  final String? mp;
  final String? libpaiement;
  final DateTime? echeancepaiement;
  final double? rap;
  final String? com;
  final String? verification;
  const BlcltData(
      {required this.num,
      this.numventes,
      this.nfact,
      this.daty,
      this.clt,
      this.ecrptancebi,
      this.montant,
      this.mp,
      this.libpaiement,
      this.echeancepaiement,
      this.rap,
      this.com,
      this.verification});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['num'] = Variable<int>(num);
    if (!nullToAbsent || numventes != null) {
      map['numventes'] = Variable<String>(numventes);
    }
    if (!nullToAbsent || nfact != null) {
      map['nfact'] = Variable<String>(nfact);
    }
    if (!nullToAbsent || daty != null) {
      map['daty'] = Variable<DateTime>(daty);
    }
    if (!nullToAbsent || clt != null) {
      map['clt'] = Variable<String>(clt);
    }
    if (!nullToAbsent || ecrptancebi != null) {
      map['ecrptancebi'] = Variable<String>(ecrptancebi);
    }
    if (!nullToAbsent || montant != null) {
      map['montant'] = Variable<double>(montant);
    }
    if (!nullToAbsent || mp != null) {
      map['mp'] = Variable<String>(mp);
    }
    if (!nullToAbsent || libpaiement != null) {
      map['libpaiement'] = Variable<String>(libpaiement);
    }
    if (!nullToAbsent || echeancepaiement != null) {
      map['echeancepaiement'] = Variable<DateTime>(echeancepaiement);
    }
    if (!nullToAbsent || rap != null) {
      map['rap'] = Variable<double>(rap);
    }
    if (!nullToAbsent || com != null) {
      map['com'] = Variable<String>(com);
    }
    if (!nullToAbsent || verification != null) {
      map['verification'] = Variable<String>(verification);
    }
    return map;
  }

  BlcltCompanion toCompanion(bool nullToAbsent) {
    return BlcltCompanion(
      num: Value(num),
      numventes: numventes == null && nullToAbsent
          ? const Value.absent()
          : Value(numventes),
      nfact:
          nfact == null && nullToAbsent ? const Value.absent() : Value(nfact),
      daty: daty == null && nullToAbsent ? const Value.absent() : Value(daty),
      clt: clt == null && nullToAbsent ? const Value.absent() : Value(clt),
      ecrptancebi: ecrptancebi == null && nullToAbsent
          ? const Value.absent()
          : Value(ecrptancebi),
      montant: montant == null && nullToAbsent
          ? const Value.absent()
          : Value(montant),
      mp: mp == null && nullToAbsent ? const Value.absent() : Value(mp),
      libpaiement: libpaiement == null && nullToAbsent
          ? const Value.absent()
          : Value(libpaiement),
      echeancepaiement: echeancepaiement == null && nullToAbsent
          ? const Value.absent()
          : Value(echeancepaiement),
      rap: rap == null && nullToAbsent ? const Value.absent() : Value(rap),
      com: com == null && nullToAbsent ? const Value.absent() : Value(com),
      verification: verification == null && nullToAbsent
          ? const Value.absent()
          : Value(verification),
    );
  }

  factory BlcltData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BlcltData(
      num: serializer.fromJson<int>(json['num']),
      numventes: serializer.fromJson<String?>(json['numventes']),
      nfact: serializer.fromJson<String?>(json['nfact']),
      daty: serializer.fromJson<DateTime?>(json['daty']),
      clt: serializer.fromJson<String?>(json['clt']),
      ecrptancebi: serializer.fromJson<String?>(json['ecrptancebi']),
      montant: serializer.fromJson<double?>(json['montant']),
      mp: serializer.fromJson<String?>(json['mp']),
      libpaiement: serializer.fromJson<String?>(json['libpaiement']),
      echeancepaiement:
          serializer.fromJson<DateTime?>(json['echeancepaiement']),
      rap: serializer.fromJson<double?>(json['rap']),
      com: serializer.fromJson<String?>(json['com']),
      verification: serializer.fromJson<String?>(json['verification']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'num': serializer.toJson<int>(num),
      'numventes': serializer.toJson<String?>(numventes),
      'nfact': serializer.toJson<String?>(nfact),
      'daty': serializer.toJson<DateTime?>(daty),
      'clt': serializer.toJson<String?>(clt),
      'ecrptancebi': serializer.toJson<String?>(ecrptancebi),
      'montant': serializer.toJson<double?>(montant),
      'mp': serializer.toJson<String?>(mp),
      'libpaiement': serializer.toJson<String?>(libpaiement),
      'echeancepaiement': serializer.toJson<DateTime?>(echeancepaiement),
      'rap': serializer.toJson<double?>(rap),
      'com': serializer.toJson<String?>(com),
      'verification': serializer.toJson<String?>(verification),
    };
  }

  BlcltData copyWith(
          {int? num,
          Value<String?> numventes = const Value.absent(),
          Value<String?> nfact = const Value.absent(),
          Value<DateTime?> daty = const Value.absent(),
          Value<String?> clt = const Value.absent(),
          Value<String?> ecrptancebi = const Value.absent(),
          Value<double?> montant = const Value.absent(),
          Value<String?> mp = const Value.absent(),
          Value<String?> libpaiement = const Value.absent(),
          Value<DateTime?> echeancepaiement = const Value.absent(),
          Value<double?> rap = const Value.absent(),
          Value<String?> com = const Value.absent(),
          Value<String?> verification = const Value.absent()}) =>
      BlcltData(
        num: num ?? this.num,
        numventes: numventes.present ? numventes.value : this.numventes,
        nfact: nfact.present ? nfact.value : this.nfact,
        daty: daty.present ? daty.value : this.daty,
        clt: clt.present ? clt.value : this.clt,
        ecrptancebi: ecrptancebi.present ? ecrptancebi.value : this.ecrptancebi,
        montant: montant.present ? montant.value : this.montant,
        mp: mp.present ? mp.value : this.mp,
        libpaiement: libpaiement.present ? libpaiement.value : this.libpaiement,
        echeancepaiement: echeancepaiement.present
            ? echeancepaiement.value
            : this.echeancepaiement,
        rap: rap.present ? rap.value : this.rap,
        com: com.present ? com.value : this.com,
        verification:
            verification.present ? verification.value : this.verification,
      );
  BlcltData copyWithCompanion(BlcltCompanion data) {
    return BlcltData(
      num: data.num.present ? data.num.value : this.num,
      numventes: data.numventes.present ? data.numventes.value : this.numventes,
      nfact: data.nfact.present ? data.nfact.value : this.nfact,
      daty: data.daty.present ? data.daty.value : this.daty,
      clt: data.clt.present ? data.clt.value : this.clt,
      ecrptancebi:
          data.ecrptancebi.present ? data.ecrptancebi.value : this.ecrptancebi,
      montant: data.montant.present ? data.montant.value : this.montant,
      mp: data.mp.present ? data.mp.value : this.mp,
      libpaiement:
          data.libpaiement.present ? data.libpaiement.value : this.libpaiement,
      echeancepaiement: data.echeancepaiement.present
          ? data.echeancepaiement.value
          : this.echeancepaiement,
      rap: data.rap.present ? data.rap.value : this.rap,
      com: data.com.present ? data.com.value : this.com,
      verification: data.verification.present
          ? data.verification.value
          : this.verification,
    );
  }

  @override
  String toString() {
    return (StringBuffer('BlcltData(')
          ..write('num: $num, ')
          ..write('numventes: $numventes, ')
          ..write('nfact: $nfact, ')
          ..write('daty: $daty, ')
          ..write('clt: $clt, ')
          ..write('ecrptancebi: $ecrptancebi, ')
          ..write('montant: $montant, ')
          ..write('mp: $mp, ')
          ..write('libpaiement: $libpaiement, ')
          ..write('echeancepaiement: $echeancepaiement, ')
          ..write('rap: $rap, ')
          ..write('com: $com, ')
          ..write('verification: $verification')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(num, numventes, nfact, daty, clt, ecrptancebi,
      montant, mp, libpaiement, echeancepaiement, rap, com, verification);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BlcltData &&
          other.num == this.num &&
          other.numventes == this.numventes &&
          other.nfact == this.nfact &&
          other.daty == this.daty &&
          other.clt == this.clt &&
          other.ecrptancebi == this.ecrptancebi &&
          other.montant == this.montant &&
          other.mp == this.mp &&
          other.libpaiement == this.libpaiement &&
          other.echeancepaiement == this.echeancepaiement &&
          other.rap == this.rap &&
          other.com == this.com &&
          other.verification == this.verification);
}

class BlcltCompanion extends UpdateCompanion<BlcltData> {
  final Value<int> num;
  final Value<String?> numventes;
  final Value<String?> nfact;
  final Value<DateTime?> daty;
  final Value<String?> clt;
  final Value<String?> ecrptancebi;
  final Value<double?> montant;
  final Value<String?> mp;
  final Value<String?> libpaiement;
  final Value<DateTime?> echeancepaiement;
  final Value<double?> rap;
  final Value<String?> com;
  final Value<String?> verification;
  const BlcltCompanion({
    this.num = const Value.absent(),
    this.numventes = const Value.absent(),
    this.nfact = const Value.absent(),
    this.daty = const Value.absent(),
    this.clt = const Value.absent(),
    this.ecrptancebi = const Value.absent(),
    this.montant = const Value.absent(),
    this.mp = const Value.absent(),
    this.libpaiement = const Value.absent(),
    this.echeancepaiement = const Value.absent(),
    this.rap = const Value.absent(),
    this.com = const Value.absent(),
    this.verification = const Value.absent(),
  });
  BlcltCompanion.insert({
    this.num = const Value.absent(),
    this.numventes = const Value.absent(),
    this.nfact = const Value.absent(),
    this.daty = const Value.absent(),
    this.clt = const Value.absent(),
    this.ecrptancebi = const Value.absent(),
    this.montant = const Value.absent(),
    this.mp = const Value.absent(),
    this.libpaiement = const Value.absent(),
    this.echeancepaiement = const Value.absent(),
    this.rap = const Value.absent(),
    this.com = const Value.absent(),
    this.verification = const Value.absent(),
  });
  static Insertable<BlcltData> custom({
    Expression<int>? num,
    Expression<String>? numventes,
    Expression<String>? nfact,
    Expression<DateTime>? daty,
    Expression<String>? clt,
    Expression<String>? ecrptancebi,
    Expression<double>? montant,
    Expression<String>? mp,
    Expression<String>? libpaiement,
    Expression<DateTime>? echeancepaiement,
    Expression<double>? rap,
    Expression<String>? com,
    Expression<String>? verification,
  }) {
    return RawValuesInsertable({
      if (num != null) 'num': num,
      if (numventes != null) 'numventes': numventes,
      if (nfact != null) 'nfact': nfact,
      if (daty != null) 'daty': daty,
      if (clt != null) 'clt': clt,
      if (ecrptancebi != null) 'ecrptancebi': ecrptancebi,
      if (montant != null) 'montant': montant,
      if (mp != null) 'mp': mp,
      if (libpaiement != null) 'libpaiement': libpaiement,
      if (echeancepaiement != null) 'echeancepaiement': echeancepaiement,
      if (rap != null) 'rap': rap,
      if (com != null) 'com': com,
      if (verification != null) 'verification': verification,
    });
  }

  BlcltCompanion copyWith(
      {Value<int>? num,
      Value<String?>? numventes,
      Value<String?>? nfact,
      Value<DateTime?>? daty,
      Value<String?>? clt,
      Value<String?>? ecrptancebi,
      Value<double?>? montant,
      Value<String?>? mp,
      Value<String?>? libpaiement,
      Value<DateTime?>? echeancepaiement,
      Value<double?>? rap,
      Value<String?>? com,
      Value<String?>? verification}) {
    return BlcltCompanion(
      num: num ?? this.num,
      numventes: numventes ?? this.numventes,
      nfact: nfact ?? this.nfact,
      daty: daty ?? this.daty,
      clt: clt ?? this.clt,
      ecrptancebi: ecrptancebi ?? this.ecrptancebi,
      montant: montant ?? this.montant,
      mp: mp ?? this.mp,
      libpaiement: libpaiement ?? this.libpaiement,
      echeancepaiement: echeancepaiement ?? this.echeancepaiement,
      rap: rap ?? this.rap,
      com: com ?? this.com,
      verification: verification ?? this.verification,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (num.present) {
      map['num'] = Variable<int>(num.value);
    }
    if (numventes.present) {
      map['numventes'] = Variable<String>(numventes.value);
    }
    if (nfact.present) {
      map['nfact'] = Variable<String>(nfact.value);
    }
    if (daty.present) {
      map['daty'] = Variable<DateTime>(daty.value);
    }
    if (clt.present) {
      map['clt'] = Variable<String>(clt.value);
    }
    if (ecrptancebi.present) {
      map['ecrptancebi'] = Variable<String>(ecrptancebi.value);
    }
    if (montant.present) {
      map['montant'] = Variable<double>(montant.value);
    }
    if (mp.present) {
      map['mp'] = Variable<String>(mp.value);
    }
    if (libpaiement.present) {
      map['libpaiement'] = Variable<String>(libpaiement.value);
    }
    if (echeancepaiement.present) {
      map['echeancepaiement'] = Variable<DateTime>(echeancepaiement.value);
    }
    if (rap.present) {
      map['rap'] = Variable<double>(rap.value);
    }
    if (com.present) {
      map['com'] = Variable<String>(com.value);
    }
    if (verification.present) {
      map['verification'] = Variable<String>(verification.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BlcltCompanion(')
          ..write('num: $num, ')
          ..write('numventes: $numventes, ')
          ..write('nfact: $nfact, ')
          ..write('daty: $daty, ')
          ..write('clt: $clt, ')
          ..write('ecrptancebi: $ecrptancebi, ')
          ..write('montant: $montant, ')
          ..write('mp: $mp, ')
          ..write('libpaiement: $libpaiement, ')
          ..write('echeancepaiement: $echeancepaiement, ')
          ..write('rap: $rap, ')
          ..write('com: $com, ')
          ..write('verification: $verification')
          ..write(')'))
        .toString();
  }
}

class $BqTable extends Bq with TableInfo<$BqTable, BqData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BqTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _intituleMeta =
      const VerificationMeta('intitule');
  @override
  late final GeneratedColumn<String> intitule = GeneratedColumn<String>(
      'intitule', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _nCompteMeta =
      const VerificationMeta('nCompte');
  @override
  late final GeneratedColumn<String> nCompte = GeneratedColumn<String>(
      'n_compte', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _soldesMeta = const VerificationMeta('soldes');
  @override
  late final GeneratedColumn<double> soldes = GeneratedColumn<double>(
      'soldes', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [code, intitule, nCompte, soldes];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'bq';
  @override
  VerificationContext validateIntegrity(Insertable<BqData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('intitule')) {
      context.handle(_intituleMeta,
          intitule.isAcceptableOrUnknown(data['intitule']!, _intituleMeta));
    }
    if (data.containsKey('n_compte')) {
      context.handle(_nCompteMeta,
          nCompte.isAcceptableOrUnknown(data['n_compte']!, _nCompteMeta));
    }
    if (data.containsKey('soldes')) {
      context.handle(_soldesMeta,
          soldes.isAcceptableOrUnknown(data['soldes']!, _soldesMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {code};
  @override
  BqData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BqData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      intitule: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}intitule']),
      nCompte: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}n_compte']),
      soldes: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}soldes']),
    );
  }

  @override
  $BqTable createAlias(String alias) {
    return $BqTable(attachedDatabase, alias);
  }
}

class BqData extends DataClass implements Insertable<BqData> {
  final String code;
  final String? intitule;
  final String? nCompte;
  final double? soldes;
  const BqData({required this.code, this.intitule, this.nCompte, this.soldes});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['code'] = Variable<String>(code);
    if (!nullToAbsent || intitule != null) {
      map['intitule'] = Variable<String>(intitule);
    }
    if (!nullToAbsent || nCompte != null) {
      map['n_compte'] = Variable<String>(nCompte);
    }
    if (!nullToAbsent || soldes != null) {
      map['soldes'] = Variable<double>(soldes);
    }
    return map;
  }

  BqCompanion toCompanion(bool nullToAbsent) {
    return BqCompanion(
      code: Value(code),
      intitule: intitule == null && nullToAbsent
          ? const Value.absent()
          : Value(intitule),
      nCompte: nCompte == null && nullToAbsent
          ? const Value.absent()
          : Value(nCompte),
      soldes:
          soldes == null && nullToAbsent ? const Value.absent() : Value(soldes),
    );
  }

  factory BqData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BqData(
      code: serializer.fromJson<String>(json['code']),
      intitule: serializer.fromJson<String?>(json['intitule']),
      nCompte: serializer.fromJson<String?>(json['nCompte']),
      soldes: serializer.fromJson<double?>(json['soldes']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'intitule': serializer.toJson<String?>(intitule),
      'nCompte': serializer.toJson<String?>(nCompte),
      'soldes': serializer.toJson<double?>(soldes),
    };
  }

  BqData copyWith(
          {String? code,
          Value<String?> intitule = const Value.absent(),
          Value<String?> nCompte = const Value.absent(),
          Value<double?> soldes = const Value.absent()}) =>
      BqData(
        code: code ?? this.code,
        intitule: intitule.present ? intitule.value : this.intitule,
        nCompte: nCompte.present ? nCompte.value : this.nCompte,
        soldes: soldes.present ? soldes.value : this.soldes,
      );
  BqData copyWithCompanion(BqCompanion data) {
    return BqData(
      code: data.code.present ? data.code.value : this.code,
      intitule: data.intitule.present ? data.intitule.value : this.intitule,
      nCompte: data.nCompte.present ? data.nCompte.value : this.nCompte,
      soldes: data.soldes.present ? data.soldes.value : this.soldes,
    );
  }

  @override
  String toString() {
    return (StringBuffer('BqData(')
          ..write('code: $code, ')
          ..write('intitule: $intitule, ')
          ..write('nCompte: $nCompte, ')
          ..write('soldes: $soldes')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, intitule, nCompte, soldes);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BqData &&
          other.code == this.code &&
          other.intitule == this.intitule &&
          other.nCompte == this.nCompte &&
          other.soldes == this.soldes);
}

class BqCompanion extends UpdateCompanion<BqData> {
  final Value<String> code;
  final Value<String?> intitule;
  final Value<String?> nCompte;
  final Value<double?> soldes;
  final Value<int> rowid;
  const BqCompanion({
    this.code = const Value.absent(),
    this.intitule = const Value.absent(),
    this.nCompte = const Value.absent(),
    this.soldes = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  BqCompanion.insert({
    required String code,
    this.intitule = const Value.absent(),
    this.nCompte = const Value.absent(),
    this.soldes = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : code = Value(code);
  static Insertable<BqData> custom({
    Expression<String>? code,
    Expression<String>? intitule,
    Expression<String>? nCompte,
    Expression<double>? soldes,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (code != null) 'code': code,
      if (intitule != null) 'intitule': intitule,
      if (nCompte != null) 'n_compte': nCompte,
      if (soldes != null) 'soldes': soldes,
      if (rowid != null) 'rowid': rowid,
    });
  }

  BqCompanion copyWith(
      {Value<String>? code,
      Value<String?>? intitule,
      Value<String?>? nCompte,
      Value<double?>? soldes,
      Value<int>? rowid}) {
    return BqCompanion(
      code: code ?? this.code,
      intitule: intitule ?? this.intitule,
      nCompte: nCompte ?? this.nCompte,
      soldes: soldes ?? this.soldes,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (intitule.present) {
      map['intitule'] = Variable<String>(intitule.value);
    }
    if (nCompte.present) {
      map['n_compte'] = Variable<String>(nCompte.value);
    }
    if (soldes.present) {
      map['soldes'] = Variable<double>(soldes.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BqCompanion(')
          ..write('code: $code, ')
          ..write('intitule: $intitule, ')
          ..write('nCompte: $nCompte, ')
          ..write('soldes: $soldes, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $CaTable extends Ca with TableInfo<$CaTable, CaData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CaTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _intituleMeta =
      const VerificationMeta('intitule');
  @override
  late final GeneratedColumn<String> intitule = GeneratedColumn<String>(
      'intitule', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _compteMeta = const VerificationMeta('compte');
  @override
  late final GeneratedColumn<String> compte = GeneratedColumn<String>(
      'compte', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _soldesMeta = const VerificationMeta('soldes');
  @override
  late final GeneratedColumn<double> soldes = GeneratedColumn<double>(
      'soldes', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _soldesaMeta =
      const VerificationMeta('soldesa');
  @override
  late final GeneratedColumn<double> soldesa = GeneratedColumn<double>(
      'soldesa', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns =>
      [code, intitule, compte, soldes, soldesa];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ca';
  @override
  VerificationContext validateIntegrity(Insertable<CaData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('intitule')) {
      context.handle(_intituleMeta,
          intitule.isAcceptableOrUnknown(data['intitule']!, _intituleMeta));
    }
    if (data.containsKey('compte')) {
      context.handle(_compteMeta,
          compte.isAcceptableOrUnknown(data['compte']!, _compteMeta));
    }
    if (data.containsKey('soldes')) {
      context.handle(_soldesMeta,
          soldes.isAcceptableOrUnknown(data['soldes']!, _soldesMeta));
    }
    if (data.containsKey('soldesa')) {
      context.handle(_soldesaMeta,
          soldesa.isAcceptableOrUnknown(data['soldesa']!, _soldesaMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {code};
  @override
  CaData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CaData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      intitule: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}intitule']),
      compte: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}compte']),
      soldes: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}soldes']),
      soldesa: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}soldesa']),
    );
  }

  @override
  $CaTable createAlias(String alias) {
    return $CaTable(attachedDatabase, alias);
  }
}

class CaData extends DataClass implements Insertable<CaData> {
  final String code;
  final String? intitule;
  final String? compte;
  final double? soldes;
  final double? soldesa;
  const CaData(
      {required this.code,
      this.intitule,
      this.compte,
      this.soldes,
      this.soldesa});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['code'] = Variable<String>(code);
    if (!nullToAbsent || intitule != null) {
      map['intitule'] = Variable<String>(intitule);
    }
    if (!nullToAbsent || compte != null) {
      map['compte'] = Variable<String>(compte);
    }
    if (!nullToAbsent || soldes != null) {
      map['soldes'] = Variable<double>(soldes);
    }
    if (!nullToAbsent || soldesa != null) {
      map['soldesa'] = Variable<double>(soldesa);
    }
    return map;
  }

  CaCompanion toCompanion(bool nullToAbsent) {
    return CaCompanion(
      code: Value(code),
      intitule: intitule == null && nullToAbsent
          ? const Value.absent()
          : Value(intitule),
      compte:
          compte == null && nullToAbsent ? const Value.absent() : Value(compte),
      soldes:
          soldes == null && nullToAbsent ? const Value.absent() : Value(soldes),
      soldesa: soldesa == null && nullToAbsent
          ? const Value.absent()
          : Value(soldesa),
    );
  }

  factory CaData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CaData(
      code: serializer.fromJson<String>(json['code']),
      intitule: serializer.fromJson<String?>(json['intitule']),
      compte: serializer.fromJson<String?>(json['compte']),
      soldes: serializer.fromJson<double?>(json['soldes']),
      soldesa: serializer.fromJson<double?>(json['soldesa']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'intitule': serializer.toJson<String?>(intitule),
      'compte': serializer.toJson<String?>(compte),
      'soldes': serializer.toJson<double?>(soldes),
      'soldesa': serializer.toJson<double?>(soldesa),
    };
  }

  CaData copyWith(
          {String? code,
          Value<String?> intitule = const Value.absent(),
          Value<String?> compte = const Value.absent(),
          Value<double?> soldes = const Value.absent(),
          Value<double?> soldesa = const Value.absent()}) =>
      CaData(
        code: code ?? this.code,
        intitule: intitule.present ? intitule.value : this.intitule,
        compte: compte.present ? compte.value : this.compte,
        soldes: soldes.present ? soldes.value : this.soldes,
        soldesa: soldesa.present ? soldesa.value : this.soldesa,
      );
  CaData copyWithCompanion(CaCompanion data) {
    return CaData(
      code: data.code.present ? data.code.value : this.code,
      intitule: data.intitule.present ? data.intitule.value : this.intitule,
      compte: data.compte.present ? data.compte.value : this.compte,
      soldes: data.soldes.present ? data.soldes.value : this.soldes,
      soldesa: data.soldesa.present ? data.soldesa.value : this.soldesa,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CaData(')
          ..write('code: $code, ')
          ..write('intitule: $intitule, ')
          ..write('compte: $compte, ')
          ..write('soldes: $soldes, ')
          ..write('soldesa: $soldesa')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, intitule, compte, soldes, soldesa);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CaData &&
          other.code == this.code &&
          other.intitule == this.intitule &&
          other.compte == this.compte &&
          other.soldes == this.soldes &&
          other.soldesa == this.soldesa);
}

class CaCompanion extends UpdateCompanion<CaData> {
  final Value<String> code;
  final Value<String?> intitule;
  final Value<String?> compte;
  final Value<double?> soldes;
  final Value<double?> soldesa;
  final Value<int> rowid;
  const CaCompanion({
    this.code = const Value.absent(),
    this.intitule = const Value.absent(),
    this.compte = const Value.absent(),
    this.soldes = const Value.absent(),
    this.soldesa = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  CaCompanion.insert({
    required String code,
    this.intitule = const Value.absent(),
    this.compte = const Value.absent(),
    this.soldes = const Value.absent(),
    this.soldesa = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : code = Value(code);
  static Insertable<CaData> custom({
    Expression<String>? code,
    Expression<String>? intitule,
    Expression<String>? compte,
    Expression<double>? soldes,
    Expression<double>? soldesa,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (code != null) 'code': code,
      if (intitule != null) 'intitule': intitule,
      if (compte != null) 'compte': compte,
      if (soldes != null) 'soldes': soldes,
      if (soldesa != null) 'soldesa': soldesa,
      if (rowid != null) 'rowid': rowid,
    });
  }

  CaCompanion copyWith(
      {Value<String>? code,
      Value<String?>? intitule,
      Value<String?>? compte,
      Value<double?>? soldes,
      Value<double?>? soldesa,
      Value<int>? rowid}) {
    return CaCompanion(
      code: code ?? this.code,
      intitule: intitule ?? this.intitule,
      compte: compte ?? this.compte,
      soldes: soldes ?? this.soldes,
      soldesa: soldesa ?? this.soldesa,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (intitule.present) {
      map['intitule'] = Variable<String>(intitule.value);
    }
    if (compte.present) {
      map['compte'] = Variable<String>(compte.value);
    }
    if (soldes.present) {
      map['soldes'] = Variable<double>(soldes.value);
    }
    if (soldesa.present) {
      map['soldesa'] = Variable<double>(soldesa.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CaCompanion(')
          ..write('code: $code, ')
          ..write('intitule: $intitule, ')
          ..write('compte: $compte, ')
          ..write('soldes: $soldes, ')
          ..write('soldesa: $soldesa, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $CaisseTable extends Caisse with TableInfo<$CaisseTable, CaisseData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CaisseTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _refMeta = const VerificationMeta('ref');
  @override
  late final GeneratedColumn<String> ref = GeneratedColumn<String>(
      'ref', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _datyMeta = const VerificationMeta('daty');
  @override
  late final GeneratedColumn<DateTime> daty = GeneratedColumn<DateTime>(
      'daty', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _libMeta = const VerificationMeta('lib');
  @override
  late final GeneratedColumn<String> lib = GeneratedColumn<String>(
      'lib', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _debitMeta = const VerificationMeta('debit');
  @override
  late final GeneratedColumn<double> debit = GeneratedColumn<double>(
      'debit', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _creditMeta = const VerificationMeta('credit');
  @override
  late final GeneratedColumn<double> credit = GeneratedColumn<double>(
      'credit', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _soldesMeta = const VerificationMeta('soldes');
  @override
  late final GeneratedColumn<double> soldes = GeneratedColumn<double>(
      'soldes', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
      'type', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _cltMeta = const VerificationMeta('clt');
  @override
  late final GeneratedColumn<String> clt = GeneratedColumn<String>(
      'clt', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _frnsMeta = const VerificationMeta('frns');
  @override
  late final GeneratedColumn<String> frns = GeneratedColumn<String>(
      'frns', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _verificationMeta =
      const VerificationMeta('verification');
  @override
  late final GeneratedColumn<String> verification = GeneratedColumn<String>(
      'verification', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _comptesMeta =
      const VerificationMeta('comptes');
  @override
  late final GeneratedColumn<String> comptes = GeneratedColumn<String>(
      'comptes', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        ref,
        daty,
        lib,
        debit,
        credit,
        soldes,
        type,
        clt,
        frns,
        verification,
        comptes
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'caisse';
  @override
  VerificationContext validateIntegrity(Insertable<CaisseData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('ref')) {
      context.handle(
          _refMeta, ref.isAcceptableOrUnknown(data['ref']!, _refMeta));
    } else if (isInserting) {
      context.missing(_refMeta);
    }
    if (data.containsKey('daty')) {
      context.handle(
          _datyMeta, daty.isAcceptableOrUnknown(data['daty']!, _datyMeta));
    }
    if (data.containsKey('lib')) {
      context.handle(
          _libMeta, lib.isAcceptableOrUnknown(data['lib']!, _libMeta));
    }
    if (data.containsKey('debit')) {
      context.handle(
          _debitMeta, debit.isAcceptableOrUnknown(data['debit']!, _debitMeta));
    }
    if (data.containsKey('credit')) {
      context.handle(_creditMeta,
          credit.isAcceptableOrUnknown(data['credit']!, _creditMeta));
    }
    if (data.containsKey('soldes')) {
      context.handle(_soldesMeta,
          soldes.isAcceptableOrUnknown(data['soldes']!, _soldesMeta));
    }
    if (data.containsKey('type')) {
      context.handle(
          _typeMeta, type.isAcceptableOrUnknown(data['type']!, _typeMeta));
    }
    if (data.containsKey('clt')) {
      context.handle(
          _cltMeta, clt.isAcceptableOrUnknown(data['clt']!, _cltMeta));
    }
    if (data.containsKey('frns')) {
      context.handle(
          _frnsMeta, frns.isAcceptableOrUnknown(data['frns']!, _frnsMeta));
    }
    if (data.containsKey('verification')) {
      context.handle(
          _verificationMeta,
          verification.isAcceptableOrUnknown(
              data['verification']!, _verificationMeta));
    }
    if (data.containsKey('comptes')) {
      context.handle(_comptesMeta,
          comptes.isAcceptableOrUnknown(data['comptes']!, _comptesMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {ref};
  @override
  CaisseData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CaisseData(
      ref: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}ref'])!,
      daty: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}daty']),
      lib: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}lib']),
      debit: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}debit']),
      credit: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}credit']),
      soldes: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}soldes']),
      type: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type']),
      clt: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}clt']),
      frns: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}frns']),
      verification: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}verification']),
      comptes: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}comptes']),
    );
  }

  @override
  $CaisseTable createAlias(String alias) {
    return $CaisseTable(attachedDatabase, alias);
  }
}

class CaisseData extends DataClass implements Insertable<CaisseData> {
  final String ref;
  final DateTime? daty;
  final String? lib;
  final double? debit;
  final double? credit;
  final double? soldes;
  final String? type;
  final String? clt;
  final String? frns;
  final String? verification;
  final String? comptes;
  const CaisseData(
      {required this.ref,
      this.daty,
      this.lib,
      this.debit,
      this.credit,
      this.soldes,
      this.type,
      this.clt,
      this.frns,
      this.verification,
      this.comptes});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['ref'] = Variable<String>(ref);
    if (!nullToAbsent || daty != null) {
      map['daty'] = Variable<DateTime>(daty);
    }
    if (!nullToAbsent || lib != null) {
      map['lib'] = Variable<String>(lib);
    }
    if (!nullToAbsent || debit != null) {
      map['debit'] = Variable<double>(debit);
    }
    if (!nullToAbsent || credit != null) {
      map['credit'] = Variable<double>(credit);
    }
    if (!nullToAbsent || soldes != null) {
      map['soldes'] = Variable<double>(soldes);
    }
    if (!nullToAbsent || type != null) {
      map['type'] = Variable<String>(type);
    }
    if (!nullToAbsent || clt != null) {
      map['clt'] = Variable<String>(clt);
    }
    if (!nullToAbsent || frns != null) {
      map['frns'] = Variable<String>(frns);
    }
    if (!nullToAbsent || verification != null) {
      map['verification'] = Variable<String>(verification);
    }
    if (!nullToAbsent || comptes != null) {
      map['comptes'] = Variable<String>(comptes);
    }
    return map;
  }

  CaisseCompanion toCompanion(bool nullToAbsent) {
    return CaisseCompanion(
      ref: Value(ref),
      daty: daty == null && nullToAbsent ? const Value.absent() : Value(daty),
      lib: lib == null && nullToAbsent ? const Value.absent() : Value(lib),
      debit:
          debit == null && nullToAbsent ? const Value.absent() : Value(debit),
      credit:
          credit == null && nullToAbsent ? const Value.absent() : Value(credit),
      soldes:
          soldes == null && nullToAbsent ? const Value.absent() : Value(soldes),
      type: type == null && nullToAbsent ? const Value.absent() : Value(type),
      clt: clt == null && nullToAbsent ? const Value.absent() : Value(clt),
      frns: frns == null && nullToAbsent ? const Value.absent() : Value(frns),
      verification: verification == null && nullToAbsent
          ? const Value.absent()
          : Value(verification),
      comptes: comptes == null && nullToAbsent
          ? const Value.absent()
          : Value(comptes),
    );
  }

  factory CaisseData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CaisseData(
      ref: serializer.fromJson<String>(json['ref']),
      daty: serializer.fromJson<DateTime?>(json['daty']),
      lib: serializer.fromJson<String?>(json['lib']),
      debit: serializer.fromJson<double?>(json['debit']),
      credit: serializer.fromJson<double?>(json['credit']),
      soldes: serializer.fromJson<double?>(json['soldes']),
      type: serializer.fromJson<String?>(json['type']),
      clt: serializer.fromJson<String?>(json['clt']),
      frns: serializer.fromJson<String?>(json['frns']),
      verification: serializer.fromJson<String?>(json['verification']),
      comptes: serializer.fromJson<String?>(json['comptes']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'ref': serializer.toJson<String>(ref),
      'daty': serializer.toJson<DateTime?>(daty),
      'lib': serializer.toJson<String?>(lib),
      'debit': serializer.toJson<double?>(debit),
      'credit': serializer.toJson<double?>(credit),
      'soldes': serializer.toJson<double?>(soldes),
      'type': serializer.toJson<String?>(type),
      'clt': serializer.toJson<String?>(clt),
      'frns': serializer.toJson<String?>(frns),
      'verification': serializer.toJson<String?>(verification),
      'comptes': serializer.toJson<String?>(comptes),
    };
  }

  CaisseData copyWith(
          {String? ref,
          Value<DateTime?> daty = const Value.absent(),
          Value<String?> lib = const Value.absent(),
          Value<double?> debit = const Value.absent(),
          Value<double?> credit = const Value.absent(),
          Value<double?> soldes = const Value.absent(),
          Value<String?> type = const Value.absent(),
          Value<String?> clt = const Value.absent(),
          Value<String?> frns = const Value.absent(),
          Value<String?> verification = const Value.absent(),
          Value<String?> comptes = const Value.absent()}) =>
      CaisseData(
        ref: ref ?? this.ref,
        daty: daty.present ? daty.value : this.daty,
        lib: lib.present ? lib.value : this.lib,
        debit: debit.present ? debit.value : this.debit,
        credit: credit.present ? credit.value : this.credit,
        soldes: soldes.present ? soldes.value : this.soldes,
        type: type.present ? type.value : this.type,
        clt: clt.present ? clt.value : this.clt,
        frns: frns.present ? frns.value : this.frns,
        verification:
            verification.present ? verification.value : this.verification,
        comptes: comptes.present ? comptes.value : this.comptes,
      );
  CaisseData copyWithCompanion(CaisseCompanion data) {
    return CaisseData(
      ref: data.ref.present ? data.ref.value : this.ref,
      daty: data.daty.present ? data.daty.value : this.daty,
      lib: data.lib.present ? data.lib.value : this.lib,
      debit: data.debit.present ? data.debit.value : this.debit,
      credit: data.credit.present ? data.credit.value : this.credit,
      soldes: data.soldes.present ? data.soldes.value : this.soldes,
      type: data.type.present ? data.type.value : this.type,
      clt: data.clt.present ? data.clt.value : this.clt,
      frns: data.frns.present ? data.frns.value : this.frns,
      verification: data.verification.present
          ? data.verification.value
          : this.verification,
      comptes: data.comptes.present ? data.comptes.value : this.comptes,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CaisseData(')
          ..write('ref: $ref, ')
          ..write('daty: $daty, ')
          ..write('lib: $lib, ')
          ..write('debit: $debit, ')
          ..write('credit: $credit, ')
          ..write('soldes: $soldes, ')
          ..write('type: $type, ')
          ..write('clt: $clt, ')
          ..write('frns: $frns, ')
          ..write('verification: $verification, ')
          ..write('comptes: $comptes')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(ref, daty, lib, debit, credit, soldes, type,
      clt, frns, verification, comptes);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CaisseData &&
          other.ref == this.ref &&
          other.daty == this.daty &&
          other.lib == this.lib &&
          other.debit == this.debit &&
          other.credit == this.credit &&
          other.soldes == this.soldes &&
          other.type == this.type &&
          other.clt == this.clt &&
          other.frns == this.frns &&
          other.verification == this.verification &&
          other.comptes == this.comptes);
}

class CaisseCompanion extends UpdateCompanion<CaisseData> {
  final Value<String> ref;
  final Value<DateTime?> daty;
  final Value<String?> lib;
  final Value<double?> debit;
  final Value<double?> credit;
  final Value<double?> soldes;
  final Value<String?> type;
  final Value<String?> clt;
  final Value<String?> frns;
  final Value<String?> verification;
  final Value<String?> comptes;
  final Value<int> rowid;
  const CaisseCompanion({
    this.ref = const Value.absent(),
    this.daty = const Value.absent(),
    this.lib = const Value.absent(),
    this.debit = const Value.absent(),
    this.credit = const Value.absent(),
    this.soldes = const Value.absent(),
    this.type = const Value.absent(),
    this.clt = const Value.absent(),
    this.frns = const Value.absent(),
    this.verification = const Value.absent(),
    this.comptes = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  CaisseCompanion.insert({
    required String ref,
    this.daty = const Value.absent(),
    this.lib = const Value.absent(),
    this.debit = const Value.absent(),
    this.credit = const Value.absent(),
    this.soldes = const Value.absent(),
    this.type = const Value.absent(),
    this.clt = const Value.absent(),
    this.frns = const Value.absent(),
    this.verification = const Value.absent(),
    this.comptes = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : ref = Value(ref);
  static Insertable<CaisseData> custom({
    Expression<String>? ref,
    Expression<DateTime>? daty,
    Expression<String>? lib,
    Expression<double>? debit,
    Expression<double>? credit,
    Expression<double>? soldes,
    Expression<String>? type,
    Expression<String>? clt,
    Expression<String>? frns,
    Expression<String>? verification,
    Expression<String>? comptes,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (ref != null) 'ref': ref,
      if (daty != null) 'daty': daty,
      if (lib != null) 'lib': lib,
      if (debit != null) 'debit': debit,
      if (credit != null) 'credit': credit,
      if (soldes != null) 'soldes': soldes,
      if (type != null) 'type': type,
      if (clt != null) 'clt': clt,
      if (frns != null) 'frns': frns,
      if (verification != null) 'verification': verification,
      if (comptes != null) 'comptes': comptes,
      if (rowid != null) 'rowid': rowid,
    });
  }

  CaisseCompanion copyWith(
      {Value<String>? ref,
      Value<DateTime?>? daty,
      Value<String?>? lib,
      Value<double?>? debit,
      Value<double?>? credit,
      Value<double?>? soldes,
      Value<String?>? type,
      Value<String?>? clt,
      Value<String?>? frns,
      Value<String?>? verification,
      Value<String?>? comptes,
      Value<int>? rowid}) {
    return CaisseCompanion(
      ref: ref ?? this.ref,
      daty: daty ?? this.daty,
      lib: lib ?? this.lib,
      debit: debit ?? this.debit,
      credit: credit ?? this.credit,
      soldes: soldes ?? this.soldes,
      type: type ?? this.type,
      clt: clt ?? this.clt,
      frns: frns ?? this.frns,
      verification: verification ?? this.verification,
      comptes: comptes ?? this.comptes,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (ref.present) {
      map['ref'] = Variable<String>(ref.value);
    }
    if (daty.present) {
      map['daty'] = Variable<DateTime>(daty.value);
    }
    if (lib.present) {
      map['lib'] = Variable<String>(lib.value);
    }
    if (debit.present) {
      map['debit'] = Variable<double>(debit.value);
    }
    if (credit.present) {
      map['credit'] = Variable<double>(credit.value);
    }
    if (soldes.present) {
      map['soldes'] = Variable<double>(soldes.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (clt.present) {
      map['clt'] = Variable<String>(clt.value);
    }
    if (frns.present) {
      map['frns'] = Variable<String>(frns.value);
    }
    if (verification.present) {
      map['verification'] = Variable<String>(verification.value);
    }
    if (comptes.present) {
      map['comptes'] = Variable<String>(comptes.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CaisseCompanion(')
          ..write('ref: $ref, ')
          ..write('daty: $daty, ')
          ..write('lib: $lib, ')
          ..write('debit: $debit, ')
          ..write('credit: $credit, ')
          ..write('soldes: $soldes, ')
          ..write('type: $type, ')
          ..write('clt: $clt, ')
          ..write('frns: $frns, ')
          ..write('verification: $verification, ')
          ..write('comptes: $comptes, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ChequierTable extends Chequier
    with TableInfo<$ChequierTable, ChequierData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ChequierTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _aMeta = const VerificationMeta('a');
  @override
  late final GeneratedColumn<int> a = GeneratedColumn<int>(
      'a', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _nopMeta = const VerificationMeta('nop');
  @override
  late final GeneratedColumn<int> nop = GeneratedColumn<int>(
      'nop', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _ncheqMeta = const VerificationMeta('ncheq');
  @override
  late final GeneratedColumn<String> ncheq = GeneratedColumn<String>(
      'ncheq', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _tireMeta = const VerificationMeta('tire');
  @override
  late final GeneratedColumn<String> tire = GeneratedColumn<String>(
      'tire', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _bqtireMeta = const VerificationMeta('bqtire');
  @override
  late final GeneratedColumn<String> bqtire = GeneratedColumn<String>(
      'bqtire', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _montantMeta =
      const VerificationMeta('montant');
  @override
  late final GeneratedColumn<double> montant = GeneratedColumn<double>(
      'montant', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _datechqMeta =
      const VerificationMeta('datechq');
  @override
  late final GeneratedColumn<DateTime> datechq = GeneratedColumn<DateTime>(
      'datechq', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _daterecepMeta =
      const VerificationMeta('daterecep');
  @override
  late final GeneratedColumn<DateTime> daterecep = GeneratedColumn<DateTime>(
      'daterecep', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _actionMeta = const VerificationMeta('action');
  @override
  late final GeneratedColumn<String> action = GeneratedColumn<String>(
      'action', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _nonactionMeta =
      const VerificationMeta('nonaction');
  @override
  late final GeneratedColumn<String> nonaction = GeneratedColumn<String>(
      'nonaction', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _numventesMeta =
      const VerificationMeta('numventes');
  @override
  late final GeneratedColumn<String> numventes = GeneratedColumn<String>(
      'numventes', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _verificationMeta =
      const VerificationMeta('verification');
  @override
  late final GeneratedColumn<String> verification = GeneratedColumn<String>(
      'verification', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        a,
        nop,
        ncheq,
        tire,
        bqtire,
        montant,
        datechq,
        daterecep,
        action,
        nonaction,
        numventes,
        verification
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'chequier';
  @override
  VerificationContext validateIntegrity(Insertable<ChequierData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('a')) {
      context.handle(_aMeta, a.isAcceptableOrUnknown(data['a']!, _aMeta));
    }
    if (data.containsKey('nop')) {
      context.handle(
          _nopMeta, nop.isAcceptableOrUnknown(data['nop']!, _nopMeta));
    }
    if (data.containsKey('ncheq')) {
      context.handle(
          _ncheqMeta, ncheq.isAcceptableOrUnknown(data['ncheq']!, _ncheqMeta));
    }
    if (data.containsKey('tire')) {
      context.handle(
          _tireMeta, tire.isAcceptableOrUnknown(data['tire']!, _tireMeta));
    }
    if (data.containsKey('bqtire')) {
      context.handle(_bqtireMeta,
          bqtire.isAcceptableOrUnknown(data['bqtire']!, _bqtireMeta));
    }
    if (data.containsKey('montant')) {
      context.handle(_montantMeta,
          montant.isAcceptableOrUnknown(data['montant']!, _montantMeta));
    }
    if (data.containsKey('datechq')) {
      context.handle(_datechqMeta,
          datechq.isAcceptableOrUnknown(data['datechq']!, _datechqMeta));
    }
    if (data.containsKey('daterecep')) {
      context.handle(_daterecepMeta,
          daterecep.isAcceptableOrUnknown(data['daterecep']!, _daterecepMeta));
    }
    if (data.containsKey('action')) {
      context.handle(_actionMeta,
          action.isAcceptableOrUnknown(data['action']!, _actionMeta));
    }
    if (data.containsKey('nonaction')) {
      context.handle(_nonactionMeta,
          nonaction.isAcceptableOrUnknown(data['nonaction']!, _nonactionMeta));
    }
    if (data.containsKey('numventes')) {
      context.handle(_numventesMeta,
          numventes.isAcceptableOrUnknown(data['numventes']!, _numventesMeta));
    }
    if (data.containsKey('verification')) {
      context.handle(
          _verificationMeta,
          verification.isAcceptableOrUnknown(
              data['verification']!, _verificationMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => const {};
  @override
  ChequierData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ChequierData(
      a: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}a']),
      nop: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}nop']),
      ncheq: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}ncheq']),
      tire: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tire']),
      bqtire: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}bqtire']),
      montant: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}montant']),
      datechq: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}datechq']),
      daterecep: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}daterecep']),
      action: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}action']),
      nonaction: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}nonaction']),
      numventes: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}numventes']),
      verification: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}verification']),
    );
  }

  @override
  $ChequierTable createAlias(String alias) {
    return $ChequierTable(attachedDatabase, alias);
  }
}

class ChequierData extends DataClass implements Insertable<ChequierData> {
  final int? a;
  final int? nop;
  final String? ncheq;
  final String? tire;
  final String? bqtire;
  final double? montant;
  final DateTime? datechq;
  final DateTime? daterecep;
  final String? action;
  final String? nonaction;
  final String? numventes;
  final String? verification;
  const ChequierData(
      {this.a,
      this.nop,
      this.ncheq,
      this.tire,
      this.bqtire,
      this.montant,
      this.datechq,
      this.daterecep,
      this.action,
      this.nonaction,
      this.numventes,
      this.verification});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || a != null) {
      map['a'] = Variable<int>(a);
    }
    if (!nullToAbsent || nop != null) {
      map['nop'] = Variable<int>(nop);
    }
    if (!nullToAbsent || ncheq != null) {
      map['ncheq'] = Variable<String>(ncheq);
    }
    if (!nullToAbsent || tire != null) {
      map['tire'] = Variable<String>(tire);
    }
    if (!nullToAbsent || bqtire != null) {
      map['bqtire'] = Variable<String>(bqtire);
    }
    if (!nullToAbsent || montant != null) {
      map['montant'] = Variable<double>(montant);
    }
    if (!nullToAbsent || datechq != null) {
      map['datechq'] = Variable<DateTime>(datechq);
    }
    if (!nullToAbsent || daterecep != null) {
      map['daterecep'] = Variable<DateTime>(daterecep);
    }
    if (!nullToAbsent || action != null) {
      map['action'] = Variable<String>(action);
    }
    if (!nullToAbsent || nonaction != null) {
      map['nonaction'] = Variable<String>(nonaction);
    }
    if (!nullToAbsent || numventes != null) {
      map['numventes'] = Variable<String>(numventes);
    }
    if (!nullToAbsent || verification != null) {
      map['verification'] = Variable<String>(verification);
    }
    return map;
  }

  ChequierCompanion toCompanion(bool nullToAbsent) {
    return ChequierCompanion(
      a: a == null && nullToAbsent ? const Value.absent() : Value(a),
      nop: nop == null && nullToAbsent ? const Value.absent() : Value(nop),
      ncheq:
          ncheq == null && nullToAbsent ? const Value.absent() : Value(ncheq),
      tire: tire == null && nullToAbsent ? const Value.absent() : Value(tire),
      bqtire:
          bqtire == null && nullToAbsent ? const Value.absent() : Value(bqtire),
      montant: montant == null && nullToAbsent
          ? const Value.absent()
          : Value(montant),
      datechq: datechq == null && nullToAbsent
          ? const Value.absent()
          : Value(datechq),
      daterecep: daterecep == null && nullToAbsent
          ? const Value.absent()
          : Value(daterecep),
      action:
          action == null && nullToAbsent ? const Value.absent() : Value(action),
      nonaction: nonaction == null && nullToAbsent
          ? const Value.absent()
          : Value(nonaction),
      numventes: numventes == null && nullToAbsent
          ? const Value.absent()
          : Value(numventes),
      verification: verification == null && nullToAbsent
          ? const Value.absent()
          : Value(verification),
    );
  }

  factory ChequierData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ChequierData(
      a: serializer.fromJson<int?>(json['a']),
      nop: serializer.fromJson<int?>(json['nop']),
      ncheq: serializer.fromJson<String?>(json['ncheq']),
      tire: serializer.fromJson<String?>(json['tire']),
      bqtire: serializer.fromJson<String?>(json['bqtire']),
      montant: serializer.fromJson<double?>(json['montant']),
      datechq: serializer.fromJson<DateTime?>(json['datechq']),
      daterecep: serializer.fromJson<DateTime?>(json['daterecep']),
      action: serializer.fromJson<String?>(json['action']),
      nonaction: serializer.fromJson<String?>(json['nonaction']),
      numventes: serializer.fromJson<String?>(json['numventes']),
      verification: serializer.fromJson<String?>(json['verification']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'a': serializer.toJson<int?>(a),
      'nop': serializer.toJson<int?>(nop),
      'ncheq': serializer.toJson<String?>(ncheq),
      'tire': serializer.toJson<String?>(tire),
      'bqtire': serializer.toJson<String?>(bqtire),
      'montant': serializer.toJson<double?>(montant),
      'datechq': serializer.toJson<DateTime?>(datechq),
      'daterecep': serializer.toJson<DateTime?>(daterecep),
      'action': serializer.toJson<String?>(action),
      'nonaction': serializer.toJson<String?>(nonaction),
      'numventes': serializer.toJson<String?>(numventes),
      'verification': serializer.toJson<String?>(verification),
    };
  }

  ChequierData copyWith(
          {Value<int?> a = const Value.absent(),
          Value<int?> nop = const Value.absent(),
          Value<String?> ncheq = const Value.absent(),
          Value<String?> tire = const Value.absent(),
          Value<String?> bqtire = const Value.absent(),
          Value<double?> montant = const Value.absent(),
          Value<DateTime?> datechq = const Value.absent(),
          Value<DateTime?> daterecep = const Value.absent(),
          Value<String?> action = const Value.absent(),
          Value<String?> nonaction = const Value.absent(),
          Value<String?> numventes = const Value.absent(),
          Value<String?> verification = const Value.absent()}) =>
      ChequierData(
        a: a.present ? a.value : this.a,
        nop: nop.present ? nop.value : this.nop,
        ncheq: ncheq.present ? ncheq.value : this.ncheq,
        tire: tire.present ? tire.value : this.tire,
        bqtire: bqtire.present ? bqtire.value : this.bqtire,
        montant: montant.present ? montant.value : this.montant,
        datechq: datechq.present ? datechq.value : this.datechq,
        daterecep: daterecep.present ? daterecep.value : this.daterecep,
        action: action.present ? action.value : this.action,
        nonaction: nonaction.present ? nonaction.value : this.nonaction,
        numventes: numventes.present ? numventes.value : this.numventes,
        verification:
            verification.present ? verification.value : this.verification,
      );
  ChequierData copyWithCompanion(ChequierCompanion data) {
    return ChequierData(
      a: data.a.present ? data.a.value : this.a,
      nop: data.nop.present ? data.nop.value : this.nop,
      ncheq: data.ncheq.present ? data.ncheq.value : this.ncheq,
      tire: data.tire.present ? data.tire.value : this.tire,
      bqtire: data.bqtire.present ? data.bqtire.value : this.bqtire,
      montant: data.montant.present ? data.montant.value : this.montant,
      datechq: data.datechq.present ? data.datechq.value : this.datechq,
      daterecep: data.daterecep.present ? data.daterecep.value : this.daterecep,
      action: data.action.present ? data.action.value : this.action,
      nonaction: data.nonaction.present ? data.nonaction.value : this.nonaction,
      numventes: data.numventes.present ? data.numventes.value : this.numventes,
      verification: data.verification.present
          ? data.verification.value
          : this.verification,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ChequierData(')
          ..write('a: $a, ')
          ..write('nop: $nop, ')
          ..write('ncheq: $ncheq, ')
          ..write('tire: $tire, ')
          ..write('bqtire: $bqtire, ')
          ..write('montant: $montant, ')
          ..write('datechq: $datechq, ')
          ..write('daterecep: $daterecep, ')
          ..write('action: $action, ')
          ..write('nonaction: $nonaction, ')
          ..write('numventes: $numventes, ')
          ..write('verification: $verification')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(a, nop, ncheq, tire, bqtire, montant, datechq,
      daterecep, action, nonaction, numventes, verification);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ChequierData &&
          other.a == this.a &&
          other.nop == this.nop &&
          other.ncheq == this.ncheq &&
          other.tire == this.tire &&
          other.bqtire == this.bqtire &&
          other.montant == this.montant &&
          other.datechq == this.datechq &&
          other.daterecep == this.daterecep &&
          other.action == this.action &&
          other.nonaction == this.nonaction &&
          other.numventes == this.numventes &&
          other.verification == this.verification);
}

class ChequierCompanion extends UpdateCompanion<ChequierData> {
  final Value<int?> a;
  final Value<int?> nop;
  final Value<String?> ncheq;
  final Value<String?> tire;
  final Value<String?> bqtire;
  final Value<double?> montant;
  final Value<DateTime?> datechq;
  final Value<DateTime?> daterecep;
  final Value<String?> action;
  final Value<String?> nonaction;
  final Value<String?> numventes;
  final Value<String?> verification;
  final Value<int> rowid;
  const ChequierCompanion({
    this.a = const Value.absent(),
    this.nop = const Value.absent(),
    this.ncheq = const Value.absent(),
    this.tire = const Value.absent(),
    this.bqtire = const Value.absent(),
    this.montant = const Value.absent(),
    this.datechq = const Value.absent(),
    this.daterecep = const Value.absent(),
    this.action = const Value.absent(),
    this.nonaction = const Value.absent(),
    this.numventes = const Value.absent(),
    this.verification = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ChequierCompanion.insert({
    this.a = const Value.absent(),
    this.nop = const Value.absent(),
    this.ncheq = const Value.absent(),
    this.tire = const Value.absent(),
    this.bqtire = const Value.absent(),
    this.montant = const Value.absent(),
    this.datechq = const Value.absent(),
    this.daterecep = const Value.absent(),
    this.action = const Value.absent(),
    this.nonaction = const Value.absent(),
    this.numventes = const Value.absent(),
    this.verification = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  static Insertable<ChequierData> custom({
    Expression<int>? a,
    Expression<int>? nop,
    Expression<String>? ncheq,
    Expression<String>? tire,
    Expression<String>? bqtire,
    Expression<double>? montant,
    Expression<DateTime>? datechq,
    Expression<DateTime>? daterecep,
    Expression<String>? action,
    Expression<String>? nonaction,
    Expression<String>? numventes,
    Expression<String>? verification,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (a != null) 'a': a,
      if (nop != null) 'nop': nop,
      if (ncheq != null) 'ncheq': ncheq,
      if (tire != null) 'tire': tire,
      if (bqtire != null) 'bqtire': bqtire,
      if (montant != null) 'montant': montant,
      if (datechq != null) 'datechq': datechq,
      if (daterecep != null) 'daterecep': daterecep,
      if (action != null) 'action': action,
      if (nonaction != null) 'nonaction': nonaction,
      if (numventes != null) 'numventes': numventes,
      if (verification != null) 'verification': verification,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ChequierCompanion copyWith(
      {Value<int?>? a,
      Value<int?>? nop,
      Value<String?>? ncheq,
      Value<String?>? tire,
      Value<String?>? bqtire,
      Value<double?>? montant,
      Value<DateTime?>? datechq,
      Value<DateTime?>? daterecep,
      Value<String?>? action,
      Value<String?>? nonaction,
      Value<String?>? numventes,
      Value<String?>? verification,
      Value<int>? rowid}) {
    return ChequierCompanion(
      a: a ?? this.a,
      nop: nop ?? this.nop,
      ncheq: ncheq ?? this.ncheq,
      tire: tire ?? this.tire,
      bqtire: bqtire ?? this.bqtire,
      montant: montant ?? this.montant,
      datechq: datechq ?? this.datechq,
      daterecep: daterecep ?? this.daterecep,
      action: action ?? this.action,
      nonaction: nonaction ?? this.nonaction,
      numventes: numventes ?? this.numventes,
      verification: verification ?? this.verification,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (a.present) {
      map['a'] = Variable<int>(a.value);
    }
    if (nop.present) {
      map['nop'] = Variable<int>(nop.value);
    }
    if (ncheq.present) {
      map['ncheq'] = Variable<String>(ncheq.value);
    }
    if (tire.present) {
      map['tire'] = Variable<String>(tire.value);
    }
    if (bqtire.present) {
      map['bqtire'] = Variable<String>(bqtire.value);
    }
    if (montant.present) {
      map['montant'] = Variable<double>(montant.value);
    }
    if (datechq.present) {
      map['datechq'] = Variable<DateTime>(datechq.value);
    }
    if (daterecep.present) {
      map['daterecep'] = Variable<DateTime>(daterecep.value);
    }
    if (action.present) {
      map['action'] = Variable<String>(action.value);
    }
    if (nonaction.present) {
      map['nonaction'] = Variable<String>(nonaction.value);
    }
    if (numventes.present) {
      map['numventes'] = Variable<String>(numventes.value);
    }
    if (verification.present) {
      map['verification'] = Variable<String>(verification.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ChequierCompanion(')
          ..write('a: $a, ')
          ..write('nop: $nop, ')
          ..write('ncheq: $ncheq, ')
          ..write('tire: $tire, ')
          ..write('bqtire: $bqtire, ')
          ..write('montant: $montant, ')
          ..write('datechq: $datechq, ')
          ..write('daterecep: $daterecep, ')
          ..write('action: $action, ')
          ..write('nonaction: $nonaction, ')
          ..write('numventes: $numventes, ')
          ..write('verification: $verification, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $CltiTable extends Clti with TableInfo<$CltiTable, CltiData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CltiTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _rsocMeta = const VerificationMeta('rsoc');
  @override
  late final GeneratedColumn<String> rsoc = GeneratedColumn<String>(
      'rsoc', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _soldesMeta = const VerificationMeta('soldes');
  @override
  late final GeneratedColumn<double> soldes = GeneratedColumn<double>(
      'soldes', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _soldes1Meta =
      const VerificationMeta('soldes1');
  @override
  late final GeneratedColumn<double> soldes1 = GeneratedColumn<double>(
      'soldes1', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _zanakaMeta = const VerificationMeta('zanaka');
  @override
  late final GeneratedColumn<int> zanaka = GeneratedColumn<int>(
      'zanaka', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [rsoc, soldes, soldes1, zanaka];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'clti';
  @override
  VerificationContext validateIntegrity(Insertable<CltiData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('rsoc')) {
      context.handle(
          _rsocMeta, rsoc.isAcceptableOrUnknown(data['rsoc']!, _rsocMeta));
    } else if (isInserting) {
      context.missing(_rsocMeta);
    }
    if (data.containsKey('soldes')) {
      context.handle(_soldesMeta,
          soldes.isAcceptableOrUnknown(data['soldes']!, _soldesMeta));
    }
    if (data.containsKey('soldes1')) {
      context.handle(_soldes1Meta,
          soldes1.isAcceptableOrUnknown(data['soldes1']!, _soldes1Meta));
    }
    if (data.containsKey('zanaka')) {
      context.handle(_zanakaMeta,
          zanaka.isAcceptableOrUnknown(data['zanaka']!, _zanakaMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {rsoc};
  @override
  CltiData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CltiData(
      rsoc: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}rsoc'])!,
      soldes: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}soldes']),
      soldes1: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}soldes1']),
      zanaka: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}zanaka']),
    );
  }

  @override
  $CltiTable createAlias(String alias) {
    return $CltiTable(attachedDatabase, alias);
  }
}

class CltiData extends DataClass implements Insertable<CltiData> {
  final String rsoc;
  final double? soldes;
  final double? soldes1;
  final int? zanaka;
  const CltiData({required this.rsoc, this.soldes, this.soldes1, this.zanaka});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['rsoc'] = Variable<String>(rsoc);
    if (!nullToAbsent || soldes != null) {
      map['soldes'] = Variable<double>(soldes);
    }
    if (!nullToAbsent || soldes1 != null) {
      map['soldes1'] = Variable<double>(soldes1);
    }
    if (!nullToAbsent || zanaka != null) {
      map['zanaka'] = Variable<int>(zanaka);
    }
    return map;
  }

  CltiCompanion toCompanion(bool nullToAbsent) {
    return CltiCompanion(
      rsoc: Value(rsoc),
      soldes:
          soldes == null && nullToAbsent ? const Value.absent() : Value(soldes),
      soldes1: soldes1 == null && nullToAbsent
          ? const Value.absent()
          : Value(soldes1),
      zanaka:
          zanaka == null && nullToAbsent ? const Value.absent() : Value(zanaka),
    );
  }

  factory CltiData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CltiData(
      rsoc: serializer.fromJson<String>(json['rsoc']),
      soldes: serializer.fromJson<double?>(json['soldes']),
      soldes1: serializer.fromJson<double?>(json['soldes1']),
      zanaka: serializer.fromJson<int?>(json['zanaka']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'rsoc': serializer.toJson<String>(rsoc),
      'soldes': serializer.toJson<double?>(soldes),
      'soldes1': serializer.toJson<double?>(soldes1),
      'zanaka': serializer.toJson<int?>(zanaka),
    };
  }

  CltiData copyWith(
          {String? rsoc,
          Value<double?> soldes = const Value.absent(),
          Value<double?> soldes1 = const Value.absent(),
          Value<int?> zanaka = const Value.absent()}) =>
      CltiData(
        rsoc: rsoc ?? this.rsoc,
        soldes: soldes.present ? soldes.value : this.soldes,
        soldes1: soldes1.present ? soldes1.value : this.soldes1,
        zanaka: zanaka.present ? zanaka.value : this.zanaka,
      );
  CltiData copyWithCompanion(CltiCompanion data) {
    return CltiData(
      rsoc: data.rsoc.present ? data.rsoc.value : this.rsoc,
      soldes: data.soldes.present ? data.soldes.value : this.soldes,
      soldes1: data.soldes1.present ? data.soldes1.value : this.soldes1,
      zanaka: data.zanaka.present ? data.zanaka.value : this.zanaka,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CltiData(')
          ..write('rsoc: $rsoc, ')
          ..write('soldes: $soldes, ')
          ..write('soldes1: $soldes1, ')
          ..write('zanaka: $zanaka')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(rsoc, soldes, soldes1, zanaka);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CltiData &&
          other.rsoc == this.rsoc &&
          other.soldes == this.soldes &&
          other.soldes1 == this.soldes1 &&
          other.zanaka == this.zanaka);
}

class CltiCompanion extends UpdateCompanion<CltiData> {
  final Value<String> rsoc;
  final Value<double?> soldes;
  final Value<double?> soldes1;
  final Value<int?> zanaka;
  final Value<int> rowid;
  const CltiCompanion({
    this.rsoc = const Value.absent(),
    this.soldes = const Value.absent(),
    this.soldes1 = const Value.absent(),
    this.zanaka = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  CltiCompanion.insert({
    required String rsoc,
    this.soldes = const Value.absent(),
    this.soldes1 = const Value.absent(),
    this.zanaka = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : rsoc = Value(rsoc);
  static Insertable<CltiData> custom({
    Expression<String>? rsoc,
    Expression<double>? soldes,
    Expression<double>? soldes1,
    Expression<int>? zanaka,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (rsoc != null) 'rsoc': rsoc,
      if (soldes != null) 'soldes': soldes,
      if (soldes1 != null) 'soldes1': soldes1,
      if (zanaka != null) 'zanaka': zanaka,
      if (rowid != null) 'rowid': rowid,
    });
  }

  CltiCompanion copyWith(
      {Value<String>? rsoc,
      Value<double?>? soldes,
      Value<double?>? soldes1,
      Value<int?>? zanaka,
      Value<int>? rowid}) {
    return CltiCompanion(
      rsoc: rsoc ?? this.rsoc,
      soldes: soldes ?? this.soldes,
      soldes1: soldes1 ?? this.soldes1,
      zanaka: zanaka ?? this.zanaka,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (rsoc.present) {
      map['rsoc'] = Variable<String>(rsoc.value);
    }
    if (soldes.present) {
      map['soldes'] = Variable<double>(soldes.value);
    }
    if (soldes1.present) {
      map['soldes1'] = Variable<double>(soldes1.value);
    }
    if (zanaka.present) {
      map['zanaka'] = Variable<int>(zanaka.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CltiCompanion(')
          ..write('rsoc: $rsoc, ')
          ..write('soldes: $soldes, ')
          ..write('soldes1: $soldes1, ')
          ..write('zanaka: $zanaka, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ComptecltTable extends Compteclt
    with TableInfo<$ComptecltTable, ComptecltData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ComptecltTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _refMeta = const VerificationMeta('ref');
  @override
  late final GeneratedColumn<String> ref = GeneratedColumn<String>(
      'ref', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _datyMeta = const VerificationMeta('daty');
  @override
  late final GeneratedColumn<DateTime> daty = GeneratedColumn<DateTime>(
      'daty', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _libMeta = const VerificationMeta('lib');
  @override
  late final GeneratedColumn<String> lib = GeneratedColumn<String>(
      'lib', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _numventesMeta =
      const VerificationMeta('numventes');
  @override
  late final GeneratedColumn<String> numventes = GeneratedColumn<String>(
      'numventes', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _nfactMeta = const VerificationMeta('nfact');
  @override
  late final GeneratedColumn<String> nfact = GeneratedColumn<String>(
      'nfact', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _refartMeta = const VerificationMeta('refart');
  @override
  late final GeneratedColumn<String> refart = GeneratedColumn<String>(
      'refart', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _qsMeta = const VerificationMeta('qs');
  @override
  late final GeneratedColumn<double> qs = GeneratedColumn<double>(
      'qs', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _pusMeta = const VerificationMeta('pus');
  @override
  late final GeneratedColumn<double> pus = GeneratedColumn<double>(
      'pus', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _entresMeta = const VerificationMeta('entres');
  @override
  late final GeneratedColumn<double> entres = GeneratedColumn<double>(
      'entres', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _sortiesMeta =
      const VerificationMeta('sorties');
  @override
  late final GeneratedColumn<double> sorties = GeneratedColumn<double>(
      'sorties', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _soldeMeta = const VerificationMeta('solde');
  @override
  late final GeneratedColumn<double> solde = GeneratedColumn<double>(
      'solde', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _cltMeta = const VerificationMeta('clt');
  @override
  late final GeneratedColumn<String> clt = GeneratedColumn<String>(
      'clt', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _verificationMeta =
      const VerificationMeta('verification');
  @override
  late final GeneratedColumn<String> verification = GeneratedColumn<String>(
      'verification', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        ref,
        daty,
        lib,
        numventes,
        nfact,
        refart,
        qs,
        pus,
        entres,
        sorties,
        solde,
        clt,
        verification
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'compteclt';
  @override
  VerificationContext validateIntegrity(Insertable<ComptecltData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('ref')) {
      context.handle(
          _refMeta, ref.isAcceptableOrUnknown(data['ref']!, _refMeta));
    } else if (isInserting) {
      context.missing(_refMeta);
    }
    if (data.containsKey('daty')) {
      context.handle(
          _datyMeta, daty.isAcceptableOrUnknown(data['daty']!, _datyMeta));
    }
    if (data.containsKey('lib')) {
      context.handle(
          _libMeta, lib.isAcceptableOrUnknown(data['lib']!, _libMeta));
    }
    if (data.containsKey('numventes')) {
      context.handle(_numventesMeta,
          numventes.isAcceptableOrUnknown(data['numventes']!, _numventesMeta));
    }
    if (data.containsKey('nfact')) {
      context.handle(
          _nfactMeta, nfact.isAcceptableOrUnknown(data['nfact']!, _nfactMeta));
    }
    if (data.containsKey('refart')) {
      context.handle(_refartMeta,
          refart.isAcceptableOrUnknown(data['refart']!, _refartMeta));
    }
    if (data.containsKey('qs')) {
      context.handle(_qsMeta, qs.isAcceptableOrUnknown(data['qs']!, _qsMeta));
    }
    if (data.containsKey('pus')) {
      context.handle(
          _pusMeta, pus.isAcceptableOrUnknown(data['pus']!, _pusMeta));
    }
    if (data.containsKey('entres')) {
      context.handle(_entresMeta,
          entres.isAcceptableOrUnknown(data['entres']!, _entresMeta));
    }
    if (data.containsKey('sorties')) {
      context.handle(_sortiesMeta,
          sorties.isAcceptableOrUnknown(data['sorties']!, _sortiesMeta));
    }
    if (data.containsKey('solde')) {
      context.handle(
          _soldeMeta, solde.isAcceptableOrUnknown(data['solde']!, _soldeMeta));
    }
    if (data.containsKey('clt')) {
      context.handle(
          _cltMeta, clt.isAcceptableOrUnknown(data['clt']!, _cltMeta));
    }
    if (data.containsKey('verification')) {
      context.handle(
          _verificationMeta,
          verification.isAcceptableOrUnknown(
              data['verification']!, _verificationMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {ref};
  @override
  ComptecltData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ComptecltData(
      ref: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}ref'])!,
      daty: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}daty']),
      lib: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}lib']),
      numventes: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}numventes']),
      nfact: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}nfact']),
      refart: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}refart']),
      qs: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}qs']),
      pus: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}pus']),
      entres: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}entres']),
      sorties: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}sorties']),
      solde: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}solde']),
      clt: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}clt']),
      verification: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}verification']),
    );
  }

  @override
  $ComptecltTable createAlias(String alias) {
    return $ComptecltTable(attachedDatabase, alias);
  }
}

class ComptecltData extends DataClass implements Insertable<ComptecltData> {
  final String ref;
  final DateTime? daty;
  final String? lib;
  final String? numventes;
  final String? nfact;
  final String? refart;
  final double? qs;
  final double? pus;
  final double? entres;
  final double? sorties;
  final double? solde;
  final String? clt;
  final String? verification;
  const ComptecltData(
      {required this.ref,
      this.daty,
      this.lib,
      this.numventes,
      this.nfact,
      this.refart,
      this.qs,
      this.pus,
      this.entres,
      this.sorties,
      this.solde,
      this.clt,
      this.verification});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['ref'] = Variable<String>(ref);
    if (!nullToAbsent || daty != null) {
      map['daty'] = Variable<DateTime>(daty);
    }
    if (!nullToAbsent || lib != null) {
      map['lib'] = Variable<String>(lib);
    }
    if (!nullToAbsent || numventes != null) {
      map['numventes'] = Variable<String>(numventes);
    }
    if (!nullToAbsent || nfact != null) {
      map['nfact'] = Variable<String>(nfact);
    }
    if (!nullToAbsent || refart != null) {
      map['refart'] = Variable<String>(refart);
    }
    if (!nullToAbsent || qs != null) {
      map['qs'] = Variable<double>(qs);
    }
    if (!nullToAbsent || pus != null) {
      map['pus'] = Variable<double>(pus);
    }
    if (!nullToAbsent || entres != null) {
      map['entres'] = Variable<double>(entres);
    }
    if (!nullToAbsent || sorties != null) {
      map['sorties'] = Variable<double>(sorties);
    }
    if (!nullToAbsent || solde != null) {
      map['solde'] = Variable<double>(solde);
    }
    if (!nullToAbsent || clt != null) {
      map['clt'] = Variable<String>(clt);
    }
    if (!nullToAbsent || verification != null) {
      map['verification'] = Variable<String>(verification);
    }
    return map;
  }

  ComptecltCompanion toCompanion(bool nullToAbsent) {
    return ComptecltCompanion(
      ref: Value(ref),
      daty: daty == null && nullToAbsent ? const Value.absent() : Value(daty),
      lib: lib == null && nullToAbsent ? const Value.absent() : Value(lib),
      numventes: numventes == null && nullToAbsent
          ? const Value.absent()
          : Value(numventes),
      nfact:
          nfact == null && nullToAbsent ? const Value.absent() : Value(nfact),
      refart:
          refart == null && nullToAbsent ? const Value.absent() : Value(refart),
      qs: qs == null && nullToAbsent ? const Value.absent() : Value(qs),
      pus: pus == null && nullToAbsent ? const Value.absent() : Value(pus),
      entres:
          entres == null && nullToAbsent ? const Value.absent() : Value(entres),
      sorties: sorties == null && nullToAbsent
          ? const Value.absent()
          : Value(sorties),
      solde:
          solde == null && nullToAbsent ? const Value.absent() : Value(solde),
      clt: clt == null && nullToAbsent ? const Value.absent() : Value(clt),
      verification: verification == null && nullToAbsent
          ? const Value.absent()
          : Value(verification),
    );
  }

  factory ComptecltData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ComptecltData(
      ref: serializer.fromJson<String>(json['ref']),
      daty: serializer.fromJson<DateTime?>(json['daty']),
      lib: serializer.fromJson<String?>(json['lib']),
      numventes: serializer.fromJson<String?>(json['numventes']),
      nfact: serializer.fromJson<String?>(json['nfact']),
      refart: serializer.fromJson<String?>(json['refart']),
      qs: serializer.fromJson<double?>(json['qs']),
      pus: serializer.fromJson<double?>(json['pus']),
      entres: serializer.fromJson<double?>(json['entres']),
      sorties: serializer.fromJson<double?>(json['sorties']),
      solde: serializer.fromJson<double?>(json['solde']),
      clt: serializer.fromJson<String?>(json['clt']),
      verification: serializer.fromJson<String?>(json['verification']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'ref': serializer.toJson<String>(ref),
      'daty': serializer.toJson<DateTime?>(daty),
      'lib': serializer.toJson<String?>(lib),
      'numventes': serializer.toJson<String?>(numventes),
      'nfact': serializer.toJson<String?>(nfact),
      'refart': serializer.toJson<String?>(refart),
      'qs': serializer.toJson<double?>(qs),
      'pus': serializer.toJson<double?>(pus),
      'entres': serializer.toJson<double?>(entres),
      'sorties': serializer.toJson<double?>(sorties),
      'solde': serializer.toJson<double?>(solde),
      'clt': serializer.toJson<String?>(clt),
      'verification': serializer.toJson<String?>(verification),
    };
  }

  ComptecltData copyWith(
          {String? ref,
          Value<DateTime?> daty = const Value.absent(),
          Value<String?> lib = const Value.absent(),
          Value<String?> numventes = const Value.absent(),
          Value<String?> nfact = const Value.absent(),
          Value<String?> refart = const Value.absent(),
          Value<double?> qs = const Value.absent(),
          Value<double?> pus = const Value.absent(),
          Value<double?> entres = const Value.absent(),
          Value<double?> sorties = const Value.absent(),
          Value<double?> solde = const Value.absent(),
          Value<String?> clt = const Value.absent(),
          Value<String?> verification = const Value.absent()}) =>
      ComptecltData(
        ref: ref ?? this.ref,
        daty: daty.present ? daty.value : this.daty,
        lib: lib.present ? lib.value : this.lib,
        numventes: numventes.present ? numventes.value : this.numventes,
        nfact: nfact.present ? nfact.value : this.nfact,
        refart: refart.present ? refart.value : this.refart,
        qs: qs.present ? qs.value : this.qs,
        pus: pus.present ? pus.value : this.pus,
        entres: entres.present ? entres.value : this.entres,
        sorties: sorties.present ? sorties.value : this.sorties,
        solde: solde.present ? solde.value : this.solde,
        clt: clt.present ? clt.value : this.clt,
        verification:
            verification.present ? verification.value : this.verification,
      );
  ComptecltData copyWithCompanion(ComptecltCompanion data) {
    return ComptecltData(
      ref: data.ref.present ? data.ref.value : this.ref,
      daty: data.daty.present ? data.daty.value : this.daty,
      lib: data.lib.present ? data.lib.value : this.lib,
      numventes: data.numventes.present ? data.numventes.value : this.numventes,
      nfact: data.nfact.present ? data.nfact.value : this.nfact,
      refart: data.refart.present ? data.refart.value : this.refart,
      qs: data.qs.present ? data.qs.value : this.qs,
      pus: data.pus.present ? data.pus.value : this.pus,
      entres: data.entres.present ? data.entres.value : this.entres,
      sorties: data.sorties.present ? data.sorties.value : this.sorties,
      solde: data.solde.present ? data.solde.value : this.solde,
      clt: data.clt.present ? data.clt.value : this.clt,
      verification: data.verification.present
          ? data.verification.value
          : this.verification,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ComptecltData(')
          ..write('ref: $ref, ')
          ..write('daty: $daty, ')
          ..write('lib: $lib, ')
          ..write('numventes: $numventes, ')
          ..write('nfact: $nfact, ')
          ..write('refart: $refart, ')
          ..write('qs: $qs, ')
          ..write('pus: $pus, ')
          ..write('entres: $entres, ')
          ..write('sorties: $sorties, ')
          ..write('solde: $solde, ')
          ..write('clt: $clt, ')
          ..write('verification: $verification')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(ref, daty, lib, numventes, nfact, refart, qs,
      pus, entres, sorties, solde, clt, verification);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ComptecltData &&
          other.ref == this.ref &&
          other.daty == this.daty &&
          other.lib == this.lib &&
          other.numventes == this.numventes &&
          other.nfact == this.nfact &&
          other.refart == this.refart &&
          other.qs == this.qs &&
          other.pus == this.pus &&
          other.entres == this.entres &&
          other.sorties == this.sorties &&
          other.solde == this.solde &&
          other.clt == this.clt &&
          other.verification == this.verification);
}

class ComptecltCompanion extends UpdateCompanion<ComptecltData> {
  final Value<String> ref;
  final Value<DateTime?> daty;
  final Value<String?> lib;
  final Value<String?> numventes;
  final Value<String?> nfact;
  final Value<String?> refart;
  final Value<double?> qs;
  final Value<double?> pus;
  final Value<double?> entres;
  final Value<double?> sorties;
  final Value<double?> solde;
  final Value<String?> clt;
  final Value<String?> verification;
  final Value<int> rowid;
  const ComptecltCompanion({
    this.ref = const Value.absent(),
    this.daty = const Value.absent(),
    this.lib = const Value.absent(),
    this.numventes = const Value.absent(),
    this.nfact = const Value.absent(),
    this.refart = const Value.absent(),
    this.qs = const Value.absent(),
    this.pus = const Value.absent(),
    this.entres = const Value.absent(),
    this.sorties = const Value.absent(),
    this.solde = const Value.absent(),
    this.clt = const Value.absent(),
    this.verification = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ComptecltCompanion.insert({
    required String ref,
    this.daty = const Value.absent(),
    this.lib = const Value.absent(),
    this.numventes = const Value.absent(),
    this.nfact = const Value.absent(),
    this.refart = const Value.absent(),
    this.qs = const Value.absent(),
    this.pus = const Value.absent(),
    this.entres = const Value.absent(),
    this.sorties = const Value.absent(),
    this.solde = const Value.absent(),
    this.clt = const Value.absent(),
    this.verification = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : ref = Value(ref);
  static Insertable<ComptecltData> custom({
    Expression<String>? ref,
    Expression<DateTime>? daty,
    Expression<String>? lib,
    Expression<String>? numventes,
    Expression<String>? nfact,
    Expression<String>? refart,
    Expression<double>? qs,
    Expression<double>? pus,
    Expression<double>? entres,
    Expression<double>? sorties,
    Expression<double>? solde,
    Expression<String>? clt,
    Expression<String>? verification,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (ref != null) 'ref': ref,
      if (daty != null) 'daty': daty,
      if (lib != null) 'lib': lib,
      if (numventes != null) 'numventes': numventes,
      if (nfact != null) 'nfact': nfact,
      if (refart != null) 'refart': refart,
      if (qs != null) 'qs': qs,
      if (pus != null) 'pus': pus,
      if (entres != null) 'entres': entres,
      if (sorties != null) 'sorties': sorties,
      if (solde != null) 'solde': solde,
      if (clt != null) 'clt': clt,
      if (verification != null) 'verification': verification,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ComptecltCompanion copyWith(
      {Value<String>? ref,
      Value<DateTime?>? daty,
      Value<String?>? lib,
      Value<String?>? numventes,
      Value<String?>? nfact,
      Value<String?>? refart,
      Value<double?>? qs,
      Value<double?>? pus,
      Value<double?>? entres,
      Value<double?>? sorties,
      Value<double?>? solde,
      Value<String?>? clt,
      Value<String?>? verification,
      Value<int>? rowid}) {
    return ComptecltCompanion(
      ref: ref ?? this.ref,
      daty: daty ?? this.daty,
      lib: lib ?? this.lib,
      numventes: numventes ?? this.numventes,
      nfact: nfact ?? this.nfact,
      refart: refart ?? this.refart,
      qs: qs ?? this.qs,
      pus: pus ?? this.pus,
      entres: entres ?? this.entres,
      sorties: sorties ?? this.sorties,
      solde: solde ?? this.solde,
      clt: clt ?? this.clt,
      verification: verification ?? this.verification,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (ref.present) {
      map['ref'] = Variable<String>(ref.value);
    }
    if (daty.present) {
      map['daty'] = Variable<DateTime>(daty.value);
    }
    if (lib.present) {
      map['lib'] = Variable<String>(lib.value);
    }
    if (numventes.present) {
      map['numventes'] = Variable<String>(numventes.value);
    }
    if (nfact.present) {
      map['nfact'] = Variable<String>(nfact.value);
    }
    if (refart.present) {
      map['refart'] = Variable<String>(refart.value);
    }
    if (qs.present) {
      map['qs'] = Variable<double>(qs.value);
    }
    if (pus.present) {
      map['pus'] = Variable<double>(pus.value);
    }
    if (entres.present) {
      map['entres'] = Variable<double>(entres.value);
    }
    if (sorties.present) {
      map['sorties'] = Variable<double>(sorties.value);
    }
    if (solde.present) {
      map['solde'] = Variable<double>(solde.value);
    }
    if (clt.present) {
      map['clt'] = Variable<String>(clt.value);
    }
    if (verification.present) {
      map['verification'] = Variable<String>(verification.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ComptecltCompanion(')
          ..write('ref: $ref, ')
          ..write('daty: $daty, ')
          ..write('lib: $lib, ')
          ..write('numventes: $numventes, ')
          ..write('nfact: $nfact, ')
          ..write('refart: $refart, ')
          ..write('qs: $qs, ')
          ..write('pus: $pus, ')
          ..write('entres: $entres, ')
          ..write('sorties: $sorties, ')
          ..write('solde: $solde, ')
          ..write('clt: $clt, ')
          ..write('verification: $verification, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ComptecomTable extends Comptecom
    with TableInfo<$ComptecomTable, ComptecomData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ComptecomTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _refMeta = const VerificationMeta('ref');
  @override
  late final GeneratedColumn<String> ref = GeneratedColumn<String>(
      'ref', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _datyMeta = const VerificationMeta('daty');
  @override
  late final GeneratedColumn<DateTime> daty = GeneratedColumn<DateTime>(
      'daty', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _libMeta = const VerificationMeta('lib');
  @override
  late final GeneratedColumn<String> lib = GeneratedColumn<String>(
      'lib', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _numventesMeta =
      const VerificationMeta('numventes');
  @override
  late final GeneratedColumn<String> numventes = GeneratedColumn<String>(
      'numventes', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _nfactMeta = const VerificationMeta('nfact');
  @override
  late final GeneratedColumn<String> nfact = GeneratedColumn<String>(
      'nfact', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _entresMeta = const VerificationMeta('entres');
  @override
  late final GeneratedColumn<double> entres = GeneratedColumn<double>(
      'entres', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _sortiesMeta =
      const VerificationMeta('sorties');
  @override
  late final GeneratedColumn<double> sorties = GeneratedColumn<double>(
      'sorties', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _soldeMeta = const VerificationMeta('solde');
  @override
  late final GeneratedColumn<double> solde = GeneratedColumn<double>(
      'solde', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _comMeta = const VerificationMeta('com');
  @override
  late final GeneratedColumn<String> com = GeneratedColumn<String>(
      'com', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _verificationMeta =
      const VerificationMeta('verification');
  @override
  late final GeneratedColumn<String> verification = GeneratedColumn<String>(
      'verification', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _montantMeta =
      const VerificationMeta('montant');
  @override
  late final GeneratedColumn<double> montant = GeneratedColumn<double>(
      'montant', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        ref,
        daty,
        lib,
        numventes,
        nfact,
        entres,
        sorties,
        solde,
        com,
        verification,
        montant
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'comptecom';
  @override
  VerificationContext validateIntegrity(Insertable<ComptecomData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('ref')) {
      context.handle(
          _refMeta, ref.isAcceptableOrUnknown(data['ref']!, _refMeta));
    } else if (isInserting) {
      context.missing(_refMeta);
    }
    if (data.containsKey('daty')) {
      context.handle(
          _datyMeta, daty.isAcceptableOrUnknown(data['daty']!, _datyMeta));
    }
    if (data.containsKey('lib')) {
      context.handle(
          _libMeta, lib.isAcceptableOrUnknown(data['lib']!, _libMeta));
    }
    if (data.containsKey('numventes')) {
      context.handle(_numventesMeta,
          numventes.isAcceptableOrUnknown(data['numventes']!, _numventesMeta));
    }
    if (data.containsKey('nfact')) {
      context.handle(
          _nfactMeta, nfact.isAcceptableOrUnknown(data['nfact']!, _nfactMeta));
    }
    if (data.containsKey('entres')) {
      context.handle(_entresMeta,
          entres.isAcceptableOrUnknown(data['entres']!, _entresMeta));
    }
    if (data.containsKey('sorties')) {
      context.handle(_sortiesMeta,
          sorties.isAcceptableOrUnknown(data['sorties']!, _sortiesMeta));
    }
    if (data.containsKey('solde')) {
      context.handle(
          _soldeMeta, solde.isAcceptableOrUnknown(data['solde']!, _soldeMeta));
    }
    if (data.containsKey('com')) {
      context.handle(
          _comMeta, com.isAcceptableOrUnknown(data['com']!, _comMeta));
    }
    if (data.containsKey('verification')) {
      context.handle(
          _verificationMeta,
          verification.isAcceptableOrUnknown(
              data['verification']!, _verificationMeta));
    }
    if (data.containsKey('montant')) {
      context.handle(_montantMeta,
          montant.isAcceptableOrUnknown(data['montant']!, _montantMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {ref};
  @override
  ComptecomData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ComptecomData(
      ref: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}ref'])!,
      daty: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}daty']),
      lib: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}lib']),
      numventes: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}numventes']),
      nfact: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}nfact']),
      entres: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}entres']),
      sorties: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}sorties']),
      solde: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}solde']),
      com: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}com']),
      verification: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}verification']),
      montant: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}montant']),
    );
  }

  @override
  $ComptecomTable createAlias(String alias) {
    return $ComptecomTable(attachedDatabase, alias);
  }
}

class ComptecomData extends DataClass implements Insertable<ComptecomData> {
  final String ref;
  final DateTime? daty;
  final String? lib;
  final String? numventes;
  final String? nfact;
  final double? entres;
  final double? sorties;
  final double? solde;
  final String? com;
  final String? verification;
  final double? montant;
  const ComptecomData(
      {required this.ref,
      this.daty,
      this.lib,
      this.numventes,
      this.nfact,
      this.entres,
      this.sorties,
      this.solde,
      this.com,
      this.verification,
      this.montant});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['ref'] = Variable<String>(ref);
    if (!nullToAbsent || daty != null) {
      map['daty'] = Variable<DateTime>(daty);
    }
    if (!nullToAbsent || lib != null) {
      map['lib'] = Variable<String>(lib);
    }
    if (!nullToAbsent || numventes != null) {
      map['numventes'] = Variable<String>(numventes);
    }
    if (!nullToAbsent || nfact != null) {
      map['nfact'] = Variable<String>(nfact);
    }
    if (!nullToAbsent || entres != null) {
      map['entres'] = Variable<double>(entres);
    }
    if (!nullToAbsent || sorties != null) {
      map['sorties'] = Variable<double>(sorties);
    }
    if (!nullToAbsent || solde != null) {
      map['solde'] = Variable<double>(solde);
    }
    if (!nullToAbsent || com != null) {
      map['com'] = Variable<String>(com);
    }
    if (!nullToAbsent || verification != null) {
      map['verification'] = Variable<String>(verification);
    }
    if (!nullToAbsent || montant != null) {
      map['montant'] = Variable<double>(montant);
    }
    return map;
  }

  ComptecomCompanion toCompanion(bool nullToAbsent) {
    return ComptecomCompanion(
      ref: Value(ref),
      daty: daty == null && nullToAbsent ? const Value.absent() : Value(daty),
      lib: lib == null && nullToAbsent ? const Value.absent() : Value(lib),
      numventes: numventes == null && nullToAbsent
          ? const Value.absent()
          : Value(numventes),
      nfact:
          nfact == null && nullToAbsent ? const Value.absent() : Value(nfact),
      entres:
          entres == null && nullToAbsent ? const Value.absent() : Value(entres),
      sorties: sorties == null && nullToAbsent
          ? const Value.absent()
          : Value(sorties),
      solde:
          solde == null && nullToAbsent ? const Value.absent() : Value(solde),
      com: com == null && nullToAbsent ? const Value.absent() : Value(com),
      verification: verification == null && nullToAbsent
          ? const Value.absent()
          : Value(verification),
      montant: montant == null && nullToAbsent
          ? const Value.absent()
          : Value(montant),
    );
  }

  factory ComptecomData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ComptecomData(
      ref: serializer.fromJson<String>(json['ref']),
      daty: serializer.fromJson<DateTime?>(json['daty']),
      lib: serializer.fromJson<String?>(json['lib']),
      numventes: serializer.fromJson<String?>(json['numventes']),
      nfact: serializer.fromJson<String?>(json['nfact']),
      entres: serializer.fromJson<double?>(json['entres']),
      sorties: serializer.fromJson<double?>(json['sorties']),
      solde: serializer.fromJson<double?>(json['solde']),
      com: serializer.fromJson<String?>(json['com']),
      verification: serializer.fromJson<String?>(json['verification']),
      montant: serializer.fromJson<double?>(json['montant']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'ref': serializer.toJson<String>(ref),
      'daty': serializer.toJson<DateTime?>(daty),
      'lib': serializer.toJson<String?>(lib),
      'numventes': serializer.toJson<String?>(numventes),
      'nfact': serializer.toJson<String?>(nfact),
      'entres': serializer.toJson<double?>(entres),
      'sorties': serializer.toJson<double?>(sorties),
      'solde': serializer.toJson<double?>(solde),
      'com': serializer.toJson<String?>(com),
      'verification': serializer.toJson<String?>(verification),
      'montant': serializer.toJson<double?>(montant),
    };
  }

  ComptecomData copyWith(
          {String? ref,
          Value<DateTime?> daty = const Value.absent(),
          Value<String?> lib = const Value.absent(),
          Value<String?> numventes = const Value.absent(),
          Value<String?> nfact = const Value.absent(),
          Value<double?> entres = const Value.absent(),
          Value<double?> sorties = const Value.absent(),
          Value<double?> solde = const Value.absent(),
          Value<String?> com = const Value.absent(),
          Value<String?> verification = const Value.absent(),
          Value<double?> montant = const Value.absent()}) =>
      ComptecomData(
        ref: ref ?? this.ref,
        daty: daty.present ? daty.value : this.daty,
        lib: lib.present ? lib.value : this.lib,
        numventes: numventes.present ? numventes.value : this.numventes,
        nfact: nfact.present ? nfact.value : this.nfact,
        entres: entres.present ? entres.value : this.entres,
        sorties: sorties.present ? sorties.value : this.sorties,
        solde: solde.present ? solde.value : this.solde,
        com: com.present ? com.value : this.com,
        verification:
            verification.present ? verification.value : this.verification,
        montant: montant.present ? montant.value : this.montant,
      );
  ComptecomData copyWithCompanion(ComptecomCompanion data) {
    return ComptecomData(
      ref: data.ref.present ? data.ref.value : this.ref,
      daty: data.daty.present ? data.daty.value : this.daty,
      lib: data.lib.present ? data.lib.value : this.lib,
      numventes: data.numventes.present ? data.numventes.value : this.numventes,
      nfact: data.nfact.present ? data.nfact.value : this.nfact,
      entres: data.entres.present ? data.entres.value : this.entres,
      sorties: data.sorties.present ? data.sorties.value : this.sorties,
      solde: data.solde.present ? data.solde.value : this.solde,
      com: data.com.present ? data.com.value : this.com,
      verification: data.verification.present
          ? data.verification.value
          : this.verification,
      montant: data.montant.present ? data.montant.value : this.montant,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ComptecomData(')
          ..write('ref: $ref, ')
          ..write('daty: $daty, ')
          ..write('lib: $lib, ')
          ..write('numventes: $numventes, ')
          ..write('nfact: $nfact, ')
          ..write('entres: $entres, ')
          ..write('sorties: $sorties, ')
          ..write('solde: $solde, ')
          ..write('com: $com, ')
          ..write('verification: $verification, ')
          ..write('montant: $montant')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(ref, daty, lib, numventes, nfact, entres,
      sorties, solde, com, verification, montant);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ComptecomData &&
          other.ref == this.ref &&
          other.daty == this.daty &&
          other.lib == this.lib &&
          other.numventes == this.numventes &&
          other.nfact == this.nfact &&
          other.entres == this.entres &&
          other.sorties == this.sorties &&
          other.solde == this.solde &&
          other.com == this.com &&
          other.verification == this.verification &&
          other.montant == this.montant);
}

class ComptecomCompanion extends UpdateCompanion<ComptecomData> {
  final Value<String> ref;
  final Value<DateTime?> daty;
  final Value<String?> lib;
  final Value<String?> numventes;
  final Value<String?> nfact;
  final Value<double?> entres;
  final Value<double?> sorties;
  final Value<double?> solde;
  final Value<String?> com;
  final Value<String?> verification;
  final Value<double?> montant;
  final Value<int> rowid;
  const ComptecomCompanion({
    this.ref = const Value.absent(),
    this.daty = const Value.absent(),
    this.lib = const Value.absent(),
    this.numventes = const Value.absent(),
    this.nfact = const Value.absent(),
    this.entres = const Value.absent(),
    this.sorties = const Value.absent(),
    this.solde = const Value.absent(),
    this.com = const Value.absent(),
    this.verification = const Value.absent(),
    this.montant = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ComptecomCompanion.insert({
    required String ref,
    this.daty = const Value.absent(),
    this.lib = const Value.absent(),
    this.numventes = const Value.absent(),
    this.nfact = const Value.absent(),
    this.entres = const Value.absent(),
    this.sorties = const Value.absent(),
    this.solde = const Value.absent(),
    this.com = const Value.absent(),
    this.verification = const Value.absent(),
    this.montant = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : ref = Value(ref);
  static Insertable<ComptecomData> custom({
    Expression<String>? ref,
    Expression<DateTime>? daty,
    Expression<String>? lib,
    Expression<String>? numventes,
    Expression<String>? nfact,
    Expression<double>? entres,
    Expression<double>? sorties,
    Expression<double>? solde,
    Expression<String>? com,
    Expression<String>? verification,
    Expression<double>? montant,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (ref != null) 'ref': ref,
      if (daty != null) 'daty': daty,
      if (lib != null) 'lib': lib,
      if (numventes != null) 'numventes': numventes,
      if (nfact != null) 'nfact': nfact,
      if (entres != null) 'entres': entres,
      if (sorties != null) 'sorties': sorties,
      if (solde != null) 'solde': solde,
      if (com != null) 'com': com,
      if (verification != null) 'verification': verification,
      if (montant != null) 'montant': montant,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ComptecomCompanion copyWith(
      {Value<String>? ref,
      Value<DateTime?>? daty,
      Value<String?>? lib,
      Value<String?>? numventes,
      Value<String?>? nfact,
      Value<double?>? entres,
      Value<double?>? sorties,
      Value<double?>? solde,
      Value<String?>? com,
      Value<String?>? verification,
      Value<double?>? montant,
      Value<int>? rowid}) {
    return ComptecomCompanion(
      ref: ref ?? this.ref,
      daty: daty ?? this.daty,
      lib: lib ?? this.lib,
      numventes: numventes ?? this.numventes,
      nfact: nfact ?? this.nfact,
      entres: entres ?? this.entres,
      sorties: sorties ?? this.sorties,
      solde: solde ?? this.solde,
      com: com ?? this.com,
      verification: verification ?? this.verification,
      montant: montant ?? this.montant,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (ref.present) {
      map['ref'] = Variable<String>(ref.value);
    }
    if (daty.present) {
      map['daty'] = Variable<DateTime>(daty.value);
    }
    if (lib.present) {
      map['lib'] = Variable<String>(lib.value);
    }
    if (numventes.present) {
      map['numventes'] = Variable<String>(numventes.value);
    }
    if (nfact.present) {
      map['nfact'] = Variable<String>(nfact.value);
    }
    if (entres.present) {
      map['entres'] = Variable<double>(entres.value);
    }
    if (sorties.present) {
      map['sorties'] = Variable<double>(sorties.value);
    }
    if (solde.present) {
      map['solde'] = Variable<double>(solde.value);
    }
    if (com.present) {
      map['com'] = Variable<String>(com.value);
    }
    if (verification.present) {
      map['verification'] = Variable<String>(verification.value);
    }
    if (montant.present) {
      map['montant'] = Variable<double>(montant.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ComptecomCompanion(')
          ..write('ref: $ref, ')
          ..write('daty: $daty, ')
          ..write('lib: $lib, ')
          ..write('numventes: $numventes, ')
          ..write('nfact: $nfact, ')
          ..write('entres: $entres, ')
          ..write('sorties: $sorties, ')
          ..write('solde: $solde, ')
          ..write('com: $com, ')
          ..write('verification: $verification, ')
          ..write('montant: $montant, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ComptefrnsTable extends Comptefrns
    with TableInfo<$ComptefrnsTable, Comptefrn> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ComptefrnsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _refMeta = const VerificationMeta('ref');
  @override
  late final GeneratedColumn<String> ref = GeneratedColumn<String>(
      'ref', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _datyMeta = const VerificationMeta('daty');
  @override
  late final GeneratedColumn<DateTime> daty = GeneratedColumn<DateTime>(
      'daty', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _libMeta = const VerificationMeta('lib');
  @override
  late final GeneratedColumn<String> lib = GeneratedColumn<String>(
      'lib', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _numachatsMeta =
      const VerificationMeta('numachats');
  @override
  late final GeneratedColumn<String> numachats = GeneratedColumn<String>(
      'numachats', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _nfactMeta = const VerificationMeta('nfact');
  @override
  late final GeneratedColumn<String> nfact = GeneratedColumn<String>(
      'nfact', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _refartMeta = const VerificationMeta('refart');
  @override
  late final GeneratedColumn<String> refart = GeneratedColumn<String>(
      'refart', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _qeMeta = const VerificationMeta('qe');
  @override
  late final GeneratedColumn<double> qe = GeneratedColumn<double>(
      'qe', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _puMeta = const VerificationMeta('pu');
  @override
  late final GeneratedColumn<double> pu = GeneratedColumn<double>(
      'pu', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _entresMeta = const VerificationMeta('entres');
  @override
  late final GeneratedColumn<double> entres = GeneratedColumn<double>(
      'entres', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _sortieMeta = const VerificationMeta('sortie');
  @override
  late final GeneratedColumn<double> sortie = GeneratedColumn<double>(
      'sortie', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _soldeMeta = const VerificationMeta('solde');
  @override
  late final GeneratedColumn<double> solde = GeneratedColumn<double>(
      'solde', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _frnsMeta = const VerificationMeta('frns');
  @override
  late final GeneratedColumn<String> frns = GeneratedColumn<String>(
      'frns', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _verificationMeta =
      const VerificationMeta('verification');
  @override
  late final GeneratedColumn<String> verification = GeneratedColumn<String>(
      'verification', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        ref,
        daty,
        lib,
        numachats,
        nfact,
        refart,
        qe,
        pu,
        entres,
        sortie,
        solde,
        frns,
        verification
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'comptefrns';
  @override
  VerificationContext validateIntegrity(Insertable<Comptefrn> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('ref')) {
      context.handle(
          _refMeta, ref.isAcceptableOrUnknown(data['ref']!, _refMeta));
    } else if (isInserting) {
      context.missing(_refMeta);
    }
    if (data.containsKey('daty')) {
      context.handle(
          _datyMeta, daty.isAcceptableOrUnknown(data['daty']!, _datyMeta));
    }
    if (data.containsKey('lib')) {
      context.handle(
          _libMeta, lib.isAcceptableOrUnknown(data['lib']!, _libMeta));
    }
    if (data.containsKey('numachats')) {
      context.handle(_numachatsMeta,
          numachats.isAcceptableOrUnknown(data['numachats']!, _numachatsMeta));
    }
    if (data.containsKey('nfact')) {
      context.handle(
          _nfactMeta, nfact.isAcceptableOrUnknown(data['nfact']!, _nfactMeta));
    }
    if (data.containsKey('refart')) {
      context.handle(_refartMeta,
          refart.isAcceptableOrUnknown(data['refart']!, _refartMeta));
    }
    if (data.containsKey('qe')) {
      context.handle(_qeMeta, qe.isAcceptableOrUnknown(data['qe']!, _qeMeta));
    }
    if (data.containsKey('pu')) {
      context.handle(_puMeta, pu.isAcceptableOrUnknown(data['pu']!, _puMeta));
    }
    if (data.containsKey('entres')) {
      context.handle(_entresMeta,
          entres.isAcceptableOrUnknown(data['entres']!, _entresMeta));
    }
    if (data.containsKey('sortie')) {
      context.handle(_sortieMeta,
          sortie.isAcceptableOrUnknown(data['sortie']!, _sortieMeta));
    }
    if (data.containsKey('solde')) {
      context.handle(
          _soldeMeta, solde.isAcceptableOrUnknown(data['solde']!, _soldeMeta));
    }
    if (data.containsKey('frns')) {
      context.handle(
          _frnsMeta, frns.isAcceptableOrUnknown(data['frns']!, _frnsMeta));
    }
    if (data.containsKey('verification')) {
      context.handle(
          _verificationMeta,
          verification.isAcceptableOrUnknown(
              data['verification']!, _verificationMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {ref};
  @override
  Comptefrn map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Comptefrn(
      ref: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}ref'])!,
      daty: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}daty']),
      lib: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}lib']),
      numachats: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}numachats']),
      nfact: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}nfact']),
      refart: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}refart']),
      qe: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}qe']),
      pu: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}pu']),
      entres: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}entres']),
      sortie: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}sortie']),
      solde: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}solde']),
      frns: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}frns']),
      verification: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}verification']),
    );
  }

  @override
  $ComptefrnsTable createAlias(String alias) {
    return $ComptefrnsTable(attachedDatabase, alias);
  }
}

class Comptefrn extends DataClass implements Insertable<Comptefrn> {
  final String ref;
  final DateTime? daty;
  final String? lib;
  final String? numachats;
  final String? nfact;
  final String? refart;
  final double? qe;
  final double? pu;
  final double? entres;
  final double? sortie;
  final double? solde;
  final String? frns;
  final String? verification;
  const Comptefrn(
      {required this.ref,
      this.daty,
      this.lib,
      this.numachats,
      this.nfact,
      this.refart,
      this.qe,
      this.pu,
      this.entres,
      this.sortie,
      this.solde,
      this.frns,
      this.verification});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['ref'] = Variable<String>(ref);
    if (!nullToAbsent || daty != null) {
      map['daty'] = Variable<DateTime>(daty);
    }
    if (!nullToAbsent || lib != null) {
      map['lib'] = Variable<String>(lib);
    }
    if (!nullToAbsent || numachats != null) {
      map['numachats'] = Variable<String>(numachats);
    }
    if (!nullToAbsent || nfact != null) {
      map['nfact'] = Variable<String>(nfact);
    }
    if (!nullToAbsent || refart != null) {
      map['refart'] = Variable<String>(refart);
    }
    if (!nullToAbsent || qe != null) {
      map['qe'] = Variable<double>(qe);
    }
    if (!nullToAbsent || pu != null) {
      map['pu'] = Variable<double>(pu);
    }
    if (!nullToAbsent || entres != null) {
      map['entres'] = Variable<double>(entres);
    }
    if (!nullToAbsent || sortie != null) {
      map['sortie'] = Variable<double>(sortie);
    }
    if (!nullToAbsent || solde != null) {
      map['solde'] = Variable<double>(solde);
    }
    if (!nullToAbsent || frns != null) {
      map['frns'] = Variable<String>(frns);
    }
    if (!nullToAbsent || verification != null) {
      map['verification'] = Variable<String>(verification);
    }
    return map;
  }

  ComptefrnsCompanion toCompanion(bool nullToAbsent) {
    return ComptefrnsCompanion(
      ref: Value(ref),
      daty: daty == null && nullToAbsent ? const Value.absent() : Value(daty),
      lib: lib == null && nullToAbsent ? const Value.absent() : Value(lib),
      numachats: numachats == null && nullToAbsent
          ? const Value.absent()
          : Value(numachats),
      nfact:
          nfact == null && nullToAbsent ? const Value.absent() : Value(nfact),
      refart:
          refart == null && nullToAbsent ? const Value.absent() : Value(refart),
      qe: qe == null && nullToAbsent ? const Value.absent() : Value(qe),
      pu: pu == null && nullToAbsent ? const Value.absent() : Value(pu),
      entres:
          entres == null && nullToAbsent ? const Value.absent() : Value(entres),
      sortie:
          sortie == null && nullToAbsent ? const Value.absent() : Value(sortie),
      solde:
          solde == null && nullToAbsent ? const Value.absent() : Value(solde),
      frns: frns == null && nullToAbsent ? const Value.absent() : Value(frns),
      verification: verification == null && nullToAbsent
          ? const Value.absent()
          : Value(verification),
    );
  }

  factory Comptefrn.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Comptefrn(
      ref: serializer.fromJson<String>(json['ref']),
      daty: serializer.fromJson<DateTime?>(json['daty']),
      lib: serializer.fromJson<String?>(json['lib']),
      numachats: serializer.fromJson<String?>(json['numachats']),
      nfact: serializer.fromJson<String?>(json['nfact']),
      refart: serializer.fromJson<String?>(json['refart']),
      qe: serializer.fromJson<double?>(json['qe']),
      pu: serializer.fromJson<double?>(json['pu']),
      entres: serializer.fromJson<double?>(json['entres']),
      sortie: serializer.fromJson<double?>(json['sortie']),
      solde: serializer.fromJson<double?>(json['solde']),
      frns: serializer.fromJson<String?>(json['frns']),
      verification: serializer.fromJson<String?>(json['verification']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'ref': serializer.toJson<String>(ref),
      'daty': serializer.toJson<DateTime?>(daty),
      'lib': serializer.toJson<String?>(lib),
      'numachats': serializer.toJson<String?>(numachats),
      'nfact': serializer.toJson<String?>(nfact),
      'refart': serializer.toJson<String?>(refart),
      'qe': serializer.toJson<double?>(qe),
      'pu': serializer.toJson<double?>(pu),
      'entres': serializer.toJson<double?>(entres),
      'sortie': serializer.toJson<double?>(sortie),
      'solde': serializer.toJson<double?>(solde),
      'frns': serializer.toJson<String?>(frns),
      'verification': serializer.toJson<String?>(verification),
    };
  }

  Comptefrn copyWith(
          {String? ref,
          Value<DateTime?> daty = const Value.absent(),
          Value<String?> lib = const Value.absent(),
          Value<String?> numachats = const Value.absent(),
          Value<String?> nfact = const Value.absent(),
          Value<String?> refart = const Value.absent(),
          Value<double?> qe = const Value.absent(),
          Value<double?> pu = const Value.absent(),
          Value<double?> entres = const Value.absent(),
          Value<double?> sortie = const Value.absent(),
          Value<double?> solde = const Value.absent(),
          Value<String?> frns = const Value.absent(),
          Value<String?> verification = const Value.absent()}) =>
      Comptefrn(
        ref: ref ?? this.ref,
        daty: daty.present ? daty.value : this.daty,
        lib: lib.present ? lib.value : this.lib,
        numachats: numachats.present ? numachats.value : this.numachats,
        nfact: nfact.present ? nfact.value : this.nfact,
        refart: refart.present ? refart.value : this.refart,
        qe: qe.present ? qe.value : this.qe,
        pu: pu.present ? pu.value : this.pu,
        entres: entres.present ? entres.value : this.entres,
        sortie: sortie.present ? sortie.value : this.sortie,
        solde: solde.present ? solde.value : this.solde,
        frns: frns.present ? frns.value : this.frns,
        verification:
            verification.present ? verification.value : this.verification,
      );
  Comptefrn copyWithCompanion(ComptefrnsCompanion data) {
    return Comptefrn(
      ref: data.ref.present ? data.ref.value : this.ref,
      daty: data.daty.present ? data.daty.value : this.daty,
      lib: data.lib.present ? data.lib.value : this.lib,
      numachats: data.numachats.present ? data.numachats.value : this.numachats,
      nfact: data.nfact.present ? data.nfact.value : this.nfact,
      refart: data.refart.present ? data.refart.value : this.refart,
      qe: data.qe.present ? data.qe.value : this.qe,
      pu: data.pu.present ? data.pu.value : this.pu,
      entres: data.entres.present ? data.entres.value : this.entres,
      sortie: data.sortie.present ? data.sortie.value : this.sortie,
      solde: data.solde.present ? data.solde.value : this.solde,
      frns: data.frns.present ? data.frns.value : this.frns,
      verification: data.verification.present
          ? data.verification.value
          : this.verification,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Comptefrn(')
          ..write('ref: $ref, ')
          ..write('daty: $daty, ')
          ..write('lib: $lib, ')
          ..write('numachats: $numachats, ')
          ..write('nfact: $nfact, ')
          ..write('refart: $refart, ')
          ..write('qe: $qe, ')
          ..write('pu: $pu, ')
          ..write('entres: $entres, ')
          ..write('sortie: $sortie, ')
          ..write('solde: $solde, ')
          ..write('frns: $frns, ')
          ..write('verification: $verification')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(ref, daty, lib, numachats, nfact, refart, qe,
      pu, entres, sortie, solde, frns, verification);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Comptefrn &&
          other.ref == this.ref &&
          other.daty == this.daty &&
          other.lib == this.lib &&
          other.numachats == this.numachats &&
          other.nfact == this.nfact &&
          other.refart == this.refart &&
          other.qe == this.qe &&
          other.pu == this.pu &&
          other.entres == this.entres &&
          other.sortie == this.sortie &&
          other.solde == this.solde &&
          other.frns == this.frns &&
          other.verification == this.verification);
}

class ComptefrnsCompanion extends UpdateCompanion<Comptefrn> {
  final Value<String> ref;
  final Value<DateTime?> daty;
  final Value<String?> lib;
  final Value<String?> numachats;
  final Value<String?> nfact;
  final Value<String?> refart;
  final Value<double?> qe;
  final Value<double?> pu;
  final Value<double?> entres;
  final Value<double?> sortie;
  final Value<double?> solde;
  final Value<String?> frns;
  final Value<String?> verification;
  final Value<int> rowid;
  const ComptefrnsCompanion({
    this.ref = const Value.absent(),
    this.daty = const Value.absent(),
    this.lib = const Value.absent(),
    this.numachats = const Value.absent(),
    this.nfact = const Value.absent(),
    this.refart = const Value.absent(),
    this.qe = const Value.absent(),
    this.pu = const Value.absent(),
    this.entres = const Value.absent(),
    this.sortie = const Value.absent(),
    this.solde = const Value.absent(),
    this.frns = const Value.absent(),
    this.verification = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ComptefrnsCompanion.insert({
    required String ref,
    this.daty = const Value.absent(),
    this.lib = const Value.absent(),
    this.numachats = const Value.absent(),
    this.nfact = const Value.absent(),
    this.refart = const Value.absent(),
    this.qe = const Value.absent(),
    this.pu = const Value.absent(),
    this.entres = const Value.absent(),
    this.sortie = const Value.absent(),
    this.solde = const Value.absent(),
    this.frns = const Value.absent(),
    this.verification = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : ref = Value(ref);
  static Insertable<Comptefrn> custom({
    Expression<String>? ref,
    Expression<DateTime>? daty,
    Expression<String>? lib,
    Expression<String>? numachats,
    Expression<String>? nfact,
    Expression<String>? refart,
    Expression<double>? qe,
    Expression<double>? pu,
    Expression<double>? entres,
    Expression<double>? sortie,
    Expression<double>? solde,
    Expression<String>? frns,
    Expression<String>? verification,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (ref != null) 'ref': ref,
      if (daty != null) 'daty': daty,
      if (lib != null) 'lib': lib,
      if (numachats != null) 'numachats': numachats,
      if (nfact != null) 'nfact': nfact,
      if (refart != null) 'refart': refart,
      if (qe != null) 'qe': qe,
      if (pu != null) 'pu': pu,
      if (entres != null) 'entres': entres,
      if (sortie != null) 'sortie': sortie,
      if (solde != null) 'solde': solde,
      if (frns != null) 'frns': frns,
      if (verification != null) 'verification': verification,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ComptefrnsCompanion copyWith(
      {Value<String>? ref,
      Value<DateTime?>? daty,
      Value<String?>? lib,
      Value<String?>? numachats,
      Value<String?>? nfact,
      Value<String?>? refart,
      Value<double?>? qe,
      Value<double?>? pu,
      Value<double?>? entres,
      Value<double?>? sortie,
      Value<double?>? solde,
      Value<String?>? frns,
      Value<String?>? verification,
      Value<int>? rowid}) {
    return ComptefrnsCompanion(
      ref: ref ?? this.ref,
      daty: daty ?? this.daty,
      lib: lib ?? this.lib,
      numachats: numachats ?? this.numachats,
      nfact: nfact ?? this.nfact,
      refart: refart ?? this.refart,
      qe: qe ?? this.qe,
      pu: pu ?? this.pu,
      entres: entres ?? this.entres,
      sortie: sortie ?? this.sortie,
      solde: solde ?? this.solde,
      frns: frns ?? this.frns,
      verification: verification ?? this.verification,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (ref.present) {
      map['ref'] = Variable<String>(ref.value);
    }
    if (daty.present) {
      map['daty'] = Variable<DateTime>(daty.value);
    }
    if (lib.present) {
      map['lib'] = Variable<String>(lib.value);
    }
    if (numachats.present) {
      map['numachats'] = Variable<String>(numachats.value);
    }
    if (nfact.present) {
      map['nfact'] = Variable<String>(nfact.value);
    }
    if (refart.present) {
      map['refart'] = Variable<String>(refart.value);
    }
    if (qe.present) {
      map['qe'] = Variable<double>(qe.value);
    }
    if (pu.present) {
      map['pu'] = Variable<double>(pu.value);
    }
    if (entres.present) {
      map['entres'] = Variable<double>(entres.value);
    }
    if (sortie.present) {
      map['sortie'] = Variable<double>(sortie.value);
    }
    if (solde.present) {
      map['solde'] = Variable<double>(solde.value);
    }
    if (frns.present) {
      map['frns'] = Variable<String>(frns.value);
    }
    if (verification.present) {
      map['verification'] = Variable<String>(verification.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ComptefrnsCompanion(')
          ..write('ref: $ref, ')
          ..write('daty: $daty, ')
          ..write('lib: $lib, ')
          ..write('numachats: $numachats, ')
          ..write('nfact: $nfact, ')
          ..write('refart: $refart, ')
          ..write('qe: $qe, ')
          ..write('pu: $pu, ')
          ..write('entres: $entres, ')
          ..write('sortie: $sortie, ')
          ..write('solde: $solde, ')
          ..write('frns: $frns, ')
          ..write('verification: $verification, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $DepartTable extends Depart with TableInfo<$DepartTable, DepartData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DepartTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _designationMeta =
      const VerificationMeta('designation');
  @override
  late final GeneratedColumn<String> designation = GeneratedColumn<String>(
      'designation', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _depotsMeta = const VerificationMeta('depots');
  @override
  late final GeneratedColumn<String> depots = GeneratedColumn<String>(
      'depots', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _stocksu1Meta =
      const VerificationMeta('stocksu1');
  @override
  late final GeneratedColumn<double> stocksu1 = GeneratedColumn<double>(
      'stocksu1', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _stocksu2Meta =
      const VerificationMeta('stocksu2');
  @override
  late final GeneratedColumn<double> stocksu2 = GeneratedColumn<double>(
      'stocksu2', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _stocksu3Meta =
      const VerificationMeta('stocksu3');
  @override
  late final GeneratedColumn<double> stocksu3 = GeneratedColumn<double>(
      'stocksu3', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns =>
      [designation, depots, stocksu1, stocksu2, stocksu3];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'depart';
  @override
  VerificationContext validateIntegrity(Insertable<DepartData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('designation')) {
      context.handle(
          _designationMeta,
          designation.isAcceptableOrUnknown(
              data['designation']!, _designationMeta));
    } else if (isInserting) {
      context.missing(_designationMeta);
    }
    if (data.containsKey('depots')) {
      context.handle(_depotsMeta,
          depots.isAcceptableOrUnknown(data['depots']!, _depotsMeta));
    }
    if (data.containsKey('stocksu1')) {
      context.handle(_stocksu1Meta,
          stocksu1.isAcceptableOrUnknown(data['stocksu1']!, _stocksu1Meta));
    }
    if (data.containsKey('stocksu2')) {
      context.handle(_stocksu2Meta,
          stocksu2.isAcceptableOrUnknown(data['stocksu2']!, _stocksu2Meta));
    }
    if (data.containsKey('stocksu3')) {
      context.handle(_stocksu3Meta,
          stocksu3.isAcceptableOrUnknown(data['stocksu3']!, _stocksu3Meta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {designation};
  @override
  DepartData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return DepartData(
      designation: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}designation'])!,
      depots: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}depots']),
      stocksu1: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}stocksu1']),
      stocksu2: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}stocksu2']),
      stocksu3: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}stocksu3']),
    );
  }

  @override
  $DepartTable createAlias(String alias) {
    return $DepartTable(attachedDatabase, alias);
  }
}

class DepartData extends DataClass implements Insertable<DepartData> {
  final String designation;
  final String? depots;
  final double? stocksu1;
  final double? stocksu2;
  final double? stocksu3;
  const DepartData(
      {required this.designation,
      this.depots,
      this.stocksu1,
      this.stocksu2,
      this.stocksu3});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['designation'] = Variable<String>(designation);
    if (!nullToAbsent || depots != null) {
      map['depots'] = Variable<String>(depots);
    }
    if (!nullToAbsent || stocksu1 != null) {
      map['stocksu1'] = Variable<double>(stocksu1);
    }
    if (!nullToAbsent || stocksu2 != null) {
      map['stocksu2'] = Variable<double>(stocksu2);
    }
    if (!nullToAbsent || stocksu3 != null) {
      map['stocksu3'] = Variable<double>(stocksu3);
    }
    return map;
  }

  DepartCompanion toCompanion(bool nullToAbsent) {
    return DepartCompanion(
      designation: Value(designation),
      depots:
          depots == null && nullToAbsent ? const Value.absent() : Value(depots),
      stocksu1: stocksu1 == null && nullToAbsent
          ? const Value.absent()
          : Value(stocksu1),
      stocksu2: stocksu2 == null && nullToAbsent
          ? const Value.absent()
          : Value(stocksu2),
      stocksu3: stocksu3 == null && nullToAbsent
          ? const Value.absent()
          : Value(stocksu3),
    );
  }

  factory DepartData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return DepartData(
      designation: serializer.fromJson<String>(json['designation']),
      depots: serializer.fromJson<String?>(json['depots']),
      stocksu1: serializer.fromJson<double?>(json['stocksu1']),
      stocksu2: serializer.fromJson<double?>(json['stocksu2']),
      stocksu3: serializer.fromJson<double?>(json['stocksu3']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'designation': serializer.toJson<String>(designation),
      'depots': serializer.toJson<String?>(depots),
      'stocksu1': serializer.toJson<double?>(stocksu1),
      'stocksu2': serializer.toJson<double?>(stocksu2),
      'stocksu3': serializer.toJson<double?>(stocksu3),
    };
  }

  DepartData copyWith(
          {String? designation,
          Value<String?> depots = const Value.absent(),
          Value<double?> stocksu1 = const Value.absent(),
          Value<double?> stocksu2 = const Value.absent(),
          Value<double?> stocksu3 = const Value.absent()}) =>
      DepartData(
        designation: designation ?? this.designation,
        depots: depots.present ? depots.value : this.depots,
        stocksu1: stocksu1.present ? stocksu1.value : this.stocksu1,
        stocksu2: stocksu2.present ? stocksu2.value : this.stocksu2,
        stocksu3: stocksu3.present ? stocksu3.value : this.stocksu3,
      );
  DepartData copyWithCompanion(DepartCompanion data) {
    return DepartData(
      designation:
          data.designation.present ? data.designation.value : this.designation,
      depots: data.depots.present ? data.depots.value : this.depots,
      stocksu1: data.stocksu1.present ? data.stocksu1.value : this.stocksu1,
      stocksu2: data.stocksu2.present ? data.stocksu2.value : this.stocksu2,
      stocksu3: data.stocksu3.present ? data.stocksu3.value : this.stocksu3,
    );
  }

  @override
  String toString() {
    return (StringBuffer('DepartData(')
          ..write('designation: $designation, ')
          ..write('depots: $depots, ')
          ..write('stocksu1: $stocksu1, ')
          ..write('stocksu2: $stocksu2, ')
          ..write('stocksu3: $stocksu3')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(designation, depots, stocksu1, stocksu2, stocksu3);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is DepartData &&
          other.designation == this.designation &&
          other.depots == this.depots &&
          other.stocksu1 == this.stocksu1 &&
          other.stocksu2 == this.stocksu2 &&
          other.stocksu3 == this.stocksu3);
}

class DepartCompanion extends UpdateCompanion<DepartData> {
  final Value<String> designation;
  final Value<String?> depots;
  final Value<double?> stocksu1;
  final Value<double?> stocksu2;
  final Value<double?> stocksu3;
  final Value<int> rowid;
  const DepartCompanion({
    this.designation = const Value.absent(),
    this.depots = const Value.absent(),
    this.stocksu1 = const Value.absent(),
    this.stocksu2 = const Value.absent(),
    this.stocksu3 = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  DepartCompanion.insert({
    required String designation,
    this.depots = const Value.absent(),
    this.stocksu1 = const Value.absent(),
    this.stocksu2 = const Value.absent(),
    this.stocksu3 = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : designation = Value(designation);
  static Insertable<DepartData> custom({
    Expression<String>? designation,
    Expression<String>? depots,
    Expression<double>? stocksu1,
    Expression<double>? stocksu2,
    Expression<double>? stocksu3,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (designation != null) 'designation': designation,
      if (depots != null) 'depots': depots,
      if (stocksu1 != null) 'stocksu1': stocksu1,
      if (stocksu2 != null) 'stocksu2': stocksu2,
      if (stocksu3 != null) 'stocksu3': stocksu3,
      if (rowid != null) 'rowid': rowid,
    });
  }

  DepartCompanion copyWith(
      {Value<String>? designation,
      Value<String?>? depots,
      Value<double?>? stocksu1,
      Value<double?>? stocksu2,
      Value<double?>? stocksu3,
      Value<int>? rowid}) {
    return DepartCompanion(
      designation: designation ?? this.designation,
      depots: depots ?? this.depots,
      stocksu1: stocksu1 ?? this.stocksu1,
      stocksu2: stocksu2 ?? this.stocksu2,
      stocksu3: stocksu3 ?? this.stocksu3,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (designation.present) {
      map['designation'] = Variable<String>(designation.value);
    }
    if (depots.present) {
      map['depots'] = Variable<String>(depots.value);
    }
    if (stocksu1.present) {
      map['stocksu1'] = Variable<double>(stocksu1.value);
    }
    if (stocksu2.present) {
      map['stocksu2'] = Variable<double>(stocksu2.value);
    }
    if (stocksu3.present) {
      map['stocksu3'] = Variable<double>(stocksu3.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DepartCompanion(')
          ..write('designation: $designation, ')
          ..write('depots: $depots, ')
          ..write('stocksu1: $stocksu1, ')
          ..write('stocksu2: $stocksu2, ')
          ..write('stocksu3: $stocksu3, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $DetachatsTable extends Detachats
    with TableInfo<$DetachatsTable, Detachat> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DetachatsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _numMeta = const VerificationMeta('num');
  @override
  late final GeneratedColumn<int> num = GeneratedColumn<int>(
      'num', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _numachatsMeta =
      const VerificationMeta('numachats');
  @override
  late final GeneratedColumn<String> numachats = GeneratedColumn<String>(
      'numachats', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _designationMeta =
      const VerificationMeta('designation');
  @override
  late final GeneratedColumn<String> designation = GeneratedColumn<String>(
      'designation', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _unitesMeta = const VerificationMeta('unites');
  @override
  late final GeneratedColumn<String> unites = GeneratedColumn<String>(
      'unites', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _depotsMeta = const VerificationMeta('depots');
  @override
  late final GeneratedColumn<String> depots = GeneratedColumn<String>(
      'depots', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _qMeta = const VerificationMeta('q');
  @override
  late final GeneratedColumn<double> q = GeneratedColumn<double>(
      'q', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _puMeta = const VerificationMeta('pu');
  @override
  late final GeneratedColumn<double> pu = GeneratedColumn<double>(
      'pu', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _datyMeta = const VerificationMeta('daty');
  @override
  late final GeneratedColumn<DateTime> daty = GeneratedColumn<DateTime>(
      'daty', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _embMeta = const VerificationMeta('emb');
  @override
  late final GeneratedColumn<String> emb = GeneratedColumn<String>(
      'emb', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _transpMeta = const VerificationMeta('transp');
  @override
  late final GeneratedColumn<String> transp = GeneratedColumn<String>(
      'transp', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _qeMeta = const VerificationMeta('qe');
  @override
  late final GeneratedColumn<double> qe = GeneratedColumn<double>(
      'qe', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        num,
        numachats,
        designation,
        unites,
        depots,
        q,
        pu,
        daty,
        emb,
        transp,
        qe
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'detachats';
  @override
  VerificationContext validateIntegrity(Insertable<Detachat> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('num')) {
      context.handle(
          _numMeta, num.isAcceptableOrUnknown(data['num']!, _numMeta));
    }
    if (data.containsKey('numachats')) {
      context.handle(_numachatsMeta,
          numachats.isAcceptableOrUnknown(data['numachats']!, _numachatsMeta));
    }
    if (data.containsKey('designation')) {
      context.handle(
          _designationMeta,
          designation.isAcceptableOrUnknown(
              data['designation']!, _designationMeta));
    }
    if (data.containsKey('unites')) {
      context.handle(_unitesMeta,
          unites.isAcceptableOrUnknown(data['unites']!, _unitesMeta));
    }
    if (data.containsKey('depots')) {
      context.handle(_depotsMeta,
          depots.isAcceptableOrUnknown(data['depots']!, _depotsMeta));
    }
    if (data.containsKey('q')) {
      context.handle(_qMeta, q.isAcceptableOrUnknown(data['q']!, _qMeta));
    }
    if (data.containsKey('pu')) {
      context.handle(_puMeta, pu.isAcceptableOrUnknown(data['pu']!, _puMeta));
    }
    if (data.containsKey('daty')) {
      context.handle(
          _datyMeta, daty.isAcceptableOrUnknown(data['daty']!, _datyMeta));
    }
    if (data.containsKey('emb')) {
      context.handle(
          _embMeta, emb.isAcceptableOrUnknown(data['emb']!, _embMeta));
    }
    if (data.containsKey('transp')) {
      context.handle(_transpMeta,
          transp.isAcceptableOrUnknown(data['transp']!, _transpMeta));
    }
    if (data.containsKey('qe')) {
      context.handle(_qeMeta, qe.isAcceptableOrUnknown(data['qe']!, _qeMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {num};
  @override
  Detachat map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Detachat(
      num: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}num'])!,
      numachats: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}numachats']),
      designation: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}designation']),
      unites: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}unites']),
      depots: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}depots']),
      q: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}q']),
      pu: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}pu']),
      daty: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}daty']),
      emb: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}emb']),
      transp: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}transp']),
      qe: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}qe']),
    );
  }

  @override
  $DetachatsTable createAlias(String alias) {
    return $DetachatsTable(attachedDatabase, alias);
  }
}

class Detachat extends DataClass implements Insertable<Detachat> {
  final int num;
  final String? numachats;
  final String? designation;
  final String? unites;
  final String? depots;
  final double? q;
  final double? pu;
  final DateTime? daty;
  final String? emb;
  final String? transp;
  final double? qe;
  const Detachat(
      {required this.num,
      this.numachats,
      this.designation,
      this.unites,
      this.depots,
      this.q,
      this.pu,
      this.daty,
      this.emb,
      this.transp,
      this.qe});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['num'] = Variable<int>(num);
    if (!nullToAbsent || numachats != null) {
      map['numachats'] = Variable<String>(numachats);
    }
    if (!nullToAbsent || designation != null) {
      map['designation'] = Variable<String>(designation);
    }
    if (!nullToAbsent || unites != null) {
      map['unites'] = Variable<String>(unites);
    }
    if (!nullToAbsent || depots != null) {
      map['depots'] = Variable<String>(depots);
    }
    if (!nullToAbsent || q != null) {
      map['q'] = Variable<double>(q);
    }
    if (!nullToAbsent || pu != null) {
      map['pu'] = Variable<double>(pu);
    }
    if (!nullToAbsent || daty != null) {
      map['daty'] = Variable<DateTime>(daty);
    }
    if (!nullToAbsent || emb != null) {
      map['emb'] = Variable<String>(emb);
    }
    if (!nullToAbsent || transp != null) {
      map['transp'] = Variable<String>(transp);
    }
    if (!nullToAbsent || qe != null) {
      map['qe'] = Variable<double>(qe);
    }
    return map;
  }

  DetachatsCompanion toCompanion(bool nullToAbsent) {
    return DetachatsCompanion(
      num: Value(num),
      numachats: numachats == null && nullToAbsent
          ? const Value.absent()
          : Value(numachats),
      designation: designation == null && nullToAbsent
          ? const Value.absent()
          : Value(designation),
      unites:
          unites == null && nullToAbsent ? const Value.absent() : Value(unites),
      depots:
          depots == null && nullToAbsent ? const Value.absent() : Value(depots),
      q: q == null && nullToAbsent ? const Value.absent() : Value(q),
      pu: pu == null && nullToAbsent ? const Value.absent() : Value(pu),
      daty: daty == null && nullToAbsent ? const Value.absent() : Value(daty),
      emb: emb == null && nullToAbsent ? const Value.absent() : Value(emb),
      transp:
          transp == null && nullToAbsent ? const Value.absent() : Value(transp),
      qe: qe == null && nullToAbsent ? const Value.absent() : Value(qe),
    );
  }

  factory Detachat.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Detachat(
      num: serializer.fromJson<int>(json['num']),
      numachats: serializer.fromJson<String?>(json['numachats']),
      designation: serializer.fromJson<String?>(json['designation']),
      unites: serializer.fromJson<String?>(json['unites']),
      depots: serializer.fromJson<String?>(json['depots']),
      q: serializer.fromJson<double?>(json['q']),
      pu: serializer.fromJson<double?>(json['pu']),
      daty: serializer.fromJson<DateTime?>(json['daty']),
      emb: serializer.fromJson<String?>(json['emb']),
      transp: serializer.fromJson<String?>(json['transp']),
      qe: serializer.fromJson<double?>(json['qe']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'num': serializer.toJson<int>(num),
      'numachats': serializer.toJson<String?>(numachats),
      'designation': serializer.toJson<String?>(designation),
      'unites': serializer.toJson<String?>(unites),
      'depots': serializer.toJson<String?>(depots),
      'q': serializer.toJson<double?>(q),
      'pu': serializer.toJson<double?>(pu),
      'daty': serializer.toJson<DateTime?>(daty),
      'emb': serializer.toJson<String?>(emb),
      'transp': serializer.toJson<String?>(transp),
      'qe': serializer.toJson<double?>(qe),
    };
  }

  Detachat copyWith(
          {int? num,
          Value<String?> numachats = const Value.absent(),
          Value<String?> designation = const Value.absent(),
          Value<String?> unites = const Value.absent(),
          Value<String?> depots = const Value.absent(),
          Value<double?> q = const Value.absent(),
          Value<double?> pu = const Value.absent(),
          Value<DateTime?> daty = const Value.absent(),
          Value<String?> emb = const Value.absent(),
          Value<String?> transp = const Value.absent(),
          Value<double?> qe = const Value.absent()}) =>
      Detachat(
        num: num ?? this.num,
        numachats: numachats.present ? numachats.value : this.numachats,
        designation: designation.present ? designation.value : this.designation,
        unites: unites.present ? unites.value : this.unites,
        depots: depots.present ? depots.value : this.depots,
        q: q.present ? q.value : this.q,
        pu: pu.present ? pu.value : this.pu,
        daty: daty.present ? daty.value : this.daty,
        emb: emb.present ? emb.value : this.emb,
        transp: transp.present ? transp.value : this.transp,
        qe: qe.present ? qe.value : this.qe,
      );
  Detachat copyWithCompanion(DetachatsCompanion data) {
    return Detachat(
      num: data.num.present ? data.num.value : this.num,
      numachats: data.numachats.present ? data.numachats.value : this.numachats,
      designation:
          data.designation.present ? data.designation.value : this.designation,
      unites: data.unites.present ? data.unites.value : this.unites,
      depots: data.depots.present ? data.depots.value : this.depots,
      q: data.q.present ? data.q.value : this.q,
      pu: data.pu.present ? data.pu.value : this.pu,
      daty: data.daty.present ? data.daty.value : this.daty,
      emb: data.emb.present ? data.emb.value : this.emb,
      transp: data.transp.present ? data.transp.value : this.transp,
      qe: data.qe.present ? data.qe.value : this.qe,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Detachat(')
          ..write('num: $num, ')
          ..write('numachats: $numachats, ')
          ..write('designation: $designation, ')
          ..write('unites: $unites, ')
          ..write('depots: $depots, ')
          ..write('q: $q, ')
          ..write('pu: $pu, ')
          ..write('daty: $daty, ')
          ..write('emb: $emb, ')
          ..write('transp: $transp, ')
          ..write('qe: $qe')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(num, numachats, designation, unites, depots,
      q, pu, daty, emb, transp, qe);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Detachat &&
          other.num == this.num &&
          other.numachats == this.numachats &&
          other.designation == this.designation &&
          other.unites == this.unites &&
          other.depots == this.depots &&
          other.q == this.q &&
          other.pu == this.pu &&
          other.daty == this.daty &&
          other.emb == this.emb &&
          other.transp == this.transp &&
          other.qe == this.qe);
}

class DetachatsCompanion extends UpdateCompanion<Detachat> {
  final Value<int> num;
  final Value<String?> numachats;
  final Value<String?> designation;
  final Value<String?> unites;
  final Value<String?> depots;
  final Value<double?> q;
  final Value<double?> pu;
  final Value<DateTime?> daty;
  final Value<String?> emb;
  final Value<String?> transp;
  final Value<double?> qe;
  const DetachatsCompanion({
    this.num = const Value.absent(),
    this.numachats = const Value.absent(),
    this.designation = const Value.absent(),
    this.unites = const Value.absent(),
    this.depots = const Value.absent(),
    this.q = const Value.absent(),
    this.pu = const Value.absent(),
    this.daty = const Value.absent(),
    this.emb = const Value.absent(),
    this.transp = const Value.absent(),
    this.qe = const Value.absent(),
  });
  DetachatsCompanion.insert({
    this.num = const Value.absent(),
    this.numachats = const Value.absent(),
    this.designation = const Value.absent(),
    this.unites = const Value.absent(),
    this.depots = const Value.absent(),
    this.q = const Value.absent(),
    this.pu = const Value.absent(),
    this.daty = const Value.absent(),
    this.emb = const Value.absent(),
    this.transp = const Value.absent(),
    this.qe = const Value.absent(),
  });
  static Insertable<Detachat> custom({
    Expression<int>? num,
    Expression<String>? numachats,
    Expression<String>? designation,
    Expression<String>? unites,
    Expression<String>? depots,
    Expression<double>? q,
    Expression<double>? pu,
    Expression<DateTime>? daty,
    Expression<String>? emb,
    Expression<String>? transp,
    Expression<double>? qe,
  }) {
    return RawValuesInsertable({
      if (num != null) 'num': num,
      if (numachats != null) 'numachats': numachats,
      if (designation != null) 'designation': designation,
      if (unites != null) 'unites': unites,
      if (depots != null) 'depots': depots,
      if (q != null) 'q': q,
      if (pu != null) 'pu': pu,
      if (daty != null) 'daty': daty,
      if (emb != null) 'emb': emb,
      if (transp != null) 'transp': transp,
      if (qe != null) 'qe': qe,
    });
  }

  DetachatsCompanion copyWith(
      {Value<int>? num,
      Value<String?>? numachats,
      Value<String?>? designation,
      Value<String?>? unites,
      Value<String?>? depots,
      Value<double?>? q,
      Value<double?>? pu,
      Value<DateTime?>? daty,
      Value<String?>? emb,
      Value<String?>? transp,
      Value<double?>? qe}) {
    return DetachatsCompanion(
      num: num ?? this.num,
      numachats: numachats ?? this.numachats,
      designation: designation ?? this.designation,
      unites: unites ?? this.unites,
      depots: depots ?? this.depots,
      q: q ?? this.q,
      pu: pu ?? this.pu,
      daty: daty ?? this.daty,
      emb: emb ?? this.emb,
      transp: transp ?? this.transp,
      qe: qe ?? this.qe,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (num.present) {
      map['num'] = Variable<int>(num.value);
    }
    if (numachats.present) {
      map['numachats'] = Variable<String>(numachats.value);
    }
    if (designation.present) {
      map['designation'] = Variable<String>(designation.value);
    }
    if (unites.present) {
      map['unites'] = Variable<String>(unites.value);
    }
    if (depots.present) {
      map['depots'] = Variable<String>(depots.value);
    }
    if (q.present) {
      map['q'] = Variable<double>(q.value);
    }
    if (pu.present) {
      map['pu'] = Variable<double>(pu.value);
    }
    if (daty.present) {
      map['daty'] = Variable<DateTime>(daty.value);
    }
    if (emb.present) {
      map['emb'] = Variable<String>(emb.value);
    }
    if (transp.present) {
      map['transp'] = Variable<String>(transp.value);
    }
    if (qe.present) {
      map['qe'] = Variable<double>(qe.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DetachatsCompanion(')
          ..write('num: $num, ')
          ..write('numachats: $numachats, ')
          ..write('designation: $designation, ')
          ..write('unites: $unites, ')
          ..write('depots: $depots, ')
          ..write('q: $q, ')
          ..write('pu: $pu, ')
          ..write('daty: $daty, ')
          ..write('emb: $emb, ')
          ..write('transp: $transp, ')
          ..write('qe: $qe')
          ..write(')'))
        .toString();
  }
}

class $DetprodTable extends Detprod with TableInfo<$DetprodTable, DetprodData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DetprodTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _numMeta = const VerificationMeta('num');
  @override
  late final GeneratedColumn<int> num = GeneratedColumn<int>(
      'num', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _numaprodMeta =
      const VerificationMeta('numaprod');
  @override
  late final GeneratedColumn<String> numaprod = GeneratedColumn<String>(
      'numaprod', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _designationMeta =
      const VerificationMeta('designation');
  @override
  late final GeneratedColumn<String> designation = GeneratedColumn<String>(
      'designation', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _unitesMeta = const VerificationMeta('unites');
  @override
  late final GeneratedColumn<String> unites = GeneratedColumn<String>(
      'unites', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _depotsMeta = const VerificationMeta('depots');
  @override
  late final GeneratedColumn<String> depots = GeneratedColumn<String>(
      'depots', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _qMeta = const VerificationMeta('q');
  @override
  late final GeneratedColumn<double> q = GeneratedColumn<double>(
      'q', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _puMeta = const VerificationMeta('pu');
  @override
  late final GeneratedColumn<double> pu = GeneratedColumn<double>(
      'pu', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _datyMeta = const VerificationMeta('daty');
  @override
  late final GeneratedColumn<DateTime> daty = GeneratedColumn<DateTime>(
      'daty', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns =>
      [num, numaprod, designation, unites, depots, q, pu, daty];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'detprod';
  @override
  VerificationContext validateIntegrity(Insertable<DetprodData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('num')) {
      context.handle(
          _numMeta, num.isAcceptableOrUnknown(data['num']!, _numMeta));
    }
    if (data.containsKey('numaprod')) {
      context.handle(_numaprodMeta,
          numaprod.isAcceptableOrUnknown(data['numaprod']!, _numaprodMeta));
    }
    if (data.containsKey('designation')) {
      context.handle(
          _designationMeta,
          designation.isAcceptableOrUnknown(
              data['designation']!, _designationMeta));
    }
    if (data.containsKey('unites')) {
      context.handle(_unitesMeta,
          unites.isAcceptableOrUnknown(data['unites']!, _unitesMeta));
    }
    if (data.containsKey('depots')) {
      context.handle(_depotsMeta,
          depots.isAcceptableOrUnknown(data['depots']!, _depotsMeta));
    }
    if (data.containsKey('q')) {
      context.handle(_qMeta, q.isAcceptableOrUnknown(data['q']!, _qMeta));
    }
    if (data.containsKey('pu')) {
      context.handle(_puMeta, pu.isAcceptableOrUnknown(data['pu']!, _puMeta));
    }
    if (data.containsKey('daty')) {
      context.handle(
          _datyMeta, daty.isAcceptableOrUnknown(data['daty']!, _datyMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {num};
  @override
  DetprodData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return DetprodData(
      num: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}num'])!,
      numaprod: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}numaprod']),
      designation: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}designation']),
      unites: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}unites']),
      depots: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}depots']),
      q: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}q']),
      pu: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}pu']),
      daty: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}daty']),
    );
  }

  @override
  $DetprodTable createAlias(String alias) {
    return $DetprodTable(attachedDatabase, alias);
  }
}

class DetprodData extends DataClass implements Insertable<DetprodData> {
  final int num;
  final String? numaprod;
  final String? designation;
  final String? unites;
  final String? depots;
  final double? q;
  final double? pu;
  final DateTime? daty;
  const DetprodData(
      {required this.num,
      this.numaprod,
      this.designation,
      this.unites,
      this.depots,
      this.q,
      this.pu,
      this.daty});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['num'] = Variable<int>(num);
    if (!nullToAbsent || numaprod != null) {
      map['numaprod'] = Variable<String>(numaprod);
    }
    if (!nullToAbsent || designation != null) {
      map['designation'] = Variable<String>(designation);
    }
    if (!nullToAbsent || unites != null) {
      map['unites'] = Variable<String>(unites);
    }
    if (!nullToAbsent || depots != null) {
      map['depots'] = Variable<String>(depots);
    }
    if (!nullToAbsent || q != null) {
      map['q'] = Variable<double>(q);
    }
    if (!nullToAbsent || pu != null) {
      map['pu'] = Variable<double>(pu);
    }
    if (!nullToAbsent || daty != null) {
      map['daty'] = Variable<DateTime>(daty);
    }
    return map;
  }

  DetprodCompanion toCompanion(bool nullToAbsent) {
    return DetprodCompanion(
      num: Value(num),
      numaprod: numaprod == null && nullToAbsent
          ? const Value.absent()
          : Value(numaprod),
      designation: designation == null && nullToAbsent
          ? const Value.absent()
          : Value(designation),
      unites:
          unites == null && nullToAbsent ? const Value.absent() : Value(unites),
      depots:
          depots == null && nullToAbsent ? const Value.absent() : Value(depots),
      q: q == null && nullToAbsent ? const Value.absent() : Value(q),
      pu: pu == null && nullToAbsent ? const Value.absent() : Value(pu),
      daty: daty == null && nullToAbsent ? const Value.absent() : Value(daty),
    );
  }

  factory DetprodData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return DetprodData(
      num: serializer.fromJson<int>(json['num']),
      numaprod: serializer.fromJson<String?>(json['numaprod']),
      designation: serializer.fromJson<String?>(json['designation']),
      unites: serializer.fromJson<String?>(json['unites']),
      depots: serializer.fromJson<String?>(json['depots']),
      q: serializer.fromJson<double?>(json['q']),
      pu: serializer.fromJson<double?>(json['pu']),
      daty: serializer.fromJson<DateTime?>(json['daty']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'num': serializer.toJson<int>(num),
      'numaprod': serializer.toJson<String?>(numaprod),
      'designation': serializer.toJson<String?>(designation),
      'unites': serializer.toJson<String?>(unites),
      'depots': serializer.toJson<String?>(depots),
      'q': serializer.toJson<double?>(q),
      'pu': serializer.toJson<double?>(pu),
      'daty': serializer.toJson<DateTime?>(daty),
    };
  }

  DetprodData copyWith(
          {int? num,
          Value<String?> numaprod = const Value.absent(),
          Value<String?> designation = const Value.absent(),
          Value<String?> unites = const Value.absent(),
          Value<String?> depots = const Value.absent(),
          Value<double?> q = const Value.absent(),
          Value<double?> pu = const Value.absent(),
          Value<DateTime?> daty = const Value.absent()}) =>
      DetprodData(
        num: num ?? this.num,
        numaprod: numaprod.present ? numaprod.value : this.numaprod,
        designation: designation.present ? designation.value : this.designation,
        unites: unites.present ? unites.value : this.unites,
        depots: depots.present ? depots.value : this.depots,
        q: q.present ? q.value : this.q,
        pu: pu.present ? pu.value : this.pu,
        daty: daty.present ? daty.value : this.daty,
      );
  DetprodData copyWithCompanion(DetprodCompanion data) {
    return DetprodData(
      num: data.num.present ? data.num.value : this.num,
      numaprod: data.numaprod.present ? data.numaprod.value : this.numaprod,
      designation:
          data.designation.present ? data.designation.value : this.designation,
      unites: data.unites.present ? data.unites.value : this.unites,
      depots: data.depots.present ? data.depots.value : this.depots,
      q: data.q.present ? data.q.value : this.q,
      pu: data.pu.present ? data.pu.value : this.pu,
      daty: data.daty.present ? data.daty.value : this.daty,
    );
  }

  @override
  String toString() {
    return (StringBuffer('DetprodData(')
          ..write('num: $num, ')
          ..write('numaprod: $numaprod, ')
          ..write('designation: $designation, ')
          ..write('unites: $unites, ')
          ..write('depots: $depots, ')
          ..write('q: $q, ')
          ..write('pu: $pu, ')
          ..write('daty: $daty')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(num, numaprod, designation, unites, depots, q, pu, daty);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is DetprodData &&
          other.num == this.num &&
          other.numaprod == this.numaprod &&
          other.designation == this.designation &&
          other.unites == this.unites &&
          other.depots == this.depots &&
          other.q == this.q &&
          other.pu == this.pu &&
          other.daty == this.daty);
}

class DetprodCompanion extends UpdateCompanion<DetprodData> {
  final Value<int> num;
  final Value<String?> numaprod;
  final Value<String?> designation;
  final Value<String?> unites;
  final Value<String?> depots;
  final Value<double?> q;
  final Value<double?> pu;
  final Value<DateTime?> daty;
  const DetprodCompanion({
    this.num = const Value.absent(),
    this.numaprod = const Value.absent(),
    this.designation = const Value.absent(),
    this.unites = const Value.absent(),
    this.depots = const Value.absent(),
    this.q = const Value.absent(),
    this.pu = const Value.absent(),
    this.daty = const Value.absent(),
  });
  DetprodCompanion.insert({
    this.num = const Value.absent(),
    this.numaprod = const Value.absent(),
    this.designation = const Value.absent(),
    this.unites = const Value.absent(),
    this.depots = const Value.absent(),
    this.q = const Value.absent(),
    this.pu = const Value.absent(),
    this.daty = const Value.absent(),
  });
  static Insertable<DetprodData> custom({
    Expression<int>? num,
    Expression<String>? numaprod,
    Expression<String>? designation,
    Expression<String>? unites,
    Expression<String>? depots,
    Expression<double>? q,
    Expression<double>? pu,
    Expression<DateTime>? daty,
  }) {
    return RawValuesInsertable({
      if (num != null) 'num': num,
      if (numaprod != null) 'numaprod': numaprod,
      if (designation != null) 'designation': designation,
      if (unites != null) 'unites': unites,
      if (depots != null) 'depots': depots,
      if (q != null) 'q': q,
      if (pu != null) 'pu': pu,
      if (daty != null) 'daty': daty,
    });
  }

  DetprodCompanion copyWith(
      {Value<int>? num,
      Value<String?>? numaprod,
      Value<String?>? designation,
      Value<String?>? unites,
      Value<String?>? depots,
      Value<double?>? q,
      Value<double?>? pu,
      Value<DateTime?>? daty}) {
    return DetprodCompanion(
      num: num ?? this.num,
      numaprod: numaprod ?? this.numaprod,
      designation: designation ?? this.designation,
      unites: unites ?? this.unites,
      depots: depots ?? this.depots,
      q: q ?? this.q,
      pu: pu ?? this.pu,
      daty: daty ?? this.daty,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (num.present) {
      map['num'] = Variable<int>(num.value);
    }
    if (numaprod.present) {
      map['numaprod'] = Variable<String>(numaprod.value);
    }
    if (designation.present) {
      map['designation'] = Variable<String>(designation.value);
    }
    if (unites.present) {
      map['unites'] = Variable<String>(unites.value);
    }
    if (depots.present) {
      map['depots'] = Variable<String>(depots.value);
    }
    if (q.present) {
      map['q'] = Variable<double>(q.value);
    }
    if (pu.present) {
      map['pu'] = Variable<double>(pu.value);
    }
    if (daty.present) {
      map['daty'] = Variable<DateTime>(daty.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DetprodCompanion(')
          ..write('num: $num, ')
          ..write('numaprod: $numaprod, ')
          ..write('designation: $designation, ')
          ..write('unites: $unites, ')
          ..write('depots: $depots, ')
          ..write('q: $q, ')
          ..write('pu: $pu, ')
          ..write('daty: $daty')
          ..write(')'))
        .toString();
  }
}

class $DettransfTable extends Dettransf
    with TableInfo<$DettransfTable, DettransfData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DettransfTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _numMeta = const VerificationMeta('num');
  @override
  late final GeneratedColumn<int> num = GeneratedColumn<int>(
      'num', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _numtransfMeta =
      const VerificationMeta('numtransf');
  @override
  late final GeneratedColumn<String> numtransf = GeneratedColumn<String>(
      'numtransf', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _designationMeta =
      const VerificationMeta('designation');
  @override
  late final GeneratedColumn<String> designation = GeneratedColumn<String>(
      'designation', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _unitesMeta = const VerificationMeta('unites');
  @override
  late final GeneratedColumn<String> unites = GeneratedColumn<String>(
      'unites', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _qMeta = const VerificationMeta('q');
  @override
  late final GeneratedColumn<double> q = GeneratedColumn<double>(
      'q', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns =>
      [num, numtransf, designation, unites, q];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'dettransf';
  @override
  VerificationContext validateIntegrity(Insertable<DettransfData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('num')) {
      context.handle(
          _numMeta, num.isAcceptableOrUnknown(data['num']!, _numMeta));
    }
    if (data.containsKey('numtransf')) {
      context.handle(_numtransfMeta,
          numtransf.isAcceptableOrUnknown(data['numtransf']!, _numtransfMeta));
    }
    if (data.containsKey('designation')) {
      context.handle(
          _designationMeta,
          designation.isAcceptableOrUnknown(
              data['designation']!, _designationMeta));
    }
    if (data.containsKey('unites')) {
      context.handle(_unitesMeta,
          unites.isAcceptableOrUnknown(data['unites']!, _unitesMeta));
    }
    if (data.containsKey('q')) {
      context.handle(_qMeta, q.isAcceptableOrUnknown(data['q']!, _qMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {num};
  @override
  DettransfData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return DettransfData(
      num: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}num'])!,
      numtransf: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}numtransf']),
      designation: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}designation']),
      unites: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}unites']),
      q: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}q']),
    );
  }

  @override
  $DettransfTable createAlias(String alias) {
    return $DettransfTable(attachedDatabase, alias);
  }
}

class DettransfData extends DataClass implements Insertable<DettransfData> {
  final int num;
  final String? numtransf;
  final String? designation;
  final String? unites;
  final double? q;
  const DettransfData(
      {required this.num,
      this.numtransf,
      this.designation,
      this.unites,
      this.q});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['num'] = Variable<int>(num);
    if (!nullToAbsent || numtransf != null) {
      map['numtransf'] = Variable<String>(numtransf);
    }
    if (!nullToAbsent || designation != null) {
      map['designation'] = Variable<String>(designation);
    }
    if (!nullToAbsent || unites != null) {
      map['unites'] = Variable<String>(unites);
    }
    if (!nullToAbsent || q != null) {
      map['q'] = Variable<double>(q);
    }
    return map;
  }

  DettransfCompanion toCompanion(bool nullToAbsent) {
    return DettransfCompanion(
      num: Value(num),
      numtransf: numtransf == null && nullToAbsent
          ? const Value.absent()
          : Value(numtransf),
      designation: designation == null && nullToAbsent
          ? const Value.absent()
          : Value(designation),
      unites:
          unites == null && nullToAbsent ? const Value.absent() : Value(unites),
      q: q == null && nullToAbsent ? const Value.absent() : Value(q),
    );
  }

  factory DettransfData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return DettransfData(
      num: serializer.fromJson<int>(json['num']),
      numtransf: serializer.fromJson<String?>(json['numtransf']),
      designation: serializer.fromJson<String?>(json['designation']),
      unites: serializer.fromJson<String?>(json['unites']),
      q: serializer.fromJson<double?>(json['q']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'num': serializer.toJson<int>(num),
      'numtransf': serializer.toJson<String?>(numtransf),
      'designation': serializer.toJson<String?>(designation),
      'unites': serializer.toJson<String?>(unites),
      'q': serializer.toJson<double?>(q),
    };
  }

  DettransfData copyWith(
          {int? num,
          Value<String?> numtransf = const Value.absent(),
          Value<String?> designation = const Value.absent(),
          Value<String?> unites = const Value.absent(),
          Value<double?> q = const Value.absent()}) =>
      DettransfData(
        num: num ?? this.num,
        numtransf: numtransf.present ? numtransf.value : this.numtransf,
        designation: designation.present ? designation.value : this.designation,
        unites: unites.present ? unites.value : this.unites,
        q: q.present ? q.value : this.q,
      );
  DettransfData copyWithCompanion(DettransfCompanion data) {
    return DettransfData(
      num: data.num.present ? data.num.value : this.num,
      numtransf: data.numtransf.present ? data.numtransf.value : this.numtransf,
      designation:
          data.designation.present ? data.designation.value : this.designation,
      unites: data.unites.present ? data.unites.value : this.unites,
      q: data.q.present ? data.q.value : this.q,
    );
  }

  @override
  String toString() {
    return (StringBuffer('DettransfData(')
          ..write('num: $num, ')
          ..write('numtransf: $numtransf, ')
          ..write('designation: $designation, ')
          ..write('unites: $unites, ')
          ..write('q: $q')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(num, numtransf, designation, unites, q);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is DettransfData &&
          other.num == this.num &&
          other.numtransf == this.numtransf &&
          other.designation == this.designation &&
          other.unites == this.unites &&
          other.q == this.q);
}

class DettransfCompanion extends UpdateCompanion<DettransfData> {
  final Value<int> num;
  final Value<String?> numtransf;
  final Value<String?> designation;
  final Value<String?> unites;
  final Value<double?> q;
  const DettransfCompanion({
    this.num = const Value.absent(),
    this.numtransf = const Value.absent(),
    this.designation = const Value.absent(),
    this.unites = const Value.absent(),
    this.q = const Value.absent(),
  });
  DettransfCompanion.insert({
    this.num = const Value.absent(),
    this.numtransf = const Value.absent(),
    this.designation = const Value.absent(),
    this.unites = const Value.absent(),
    this.q = const Value.absent(),
  });
  static Insertable<DettransfData> custom({
    Expression<int>? num,
    Expression<String>? numtransf,
    Expression<String>? designation,
    Expression<String>? unites,
    Expression<double>? q,
  }) {
    return RawValuesInsertable({
      if (num != null) 'num': num,
      if (numtransf != null) 'numtransf': numtransf,
      if (designation != null) 'designation': designation,
      if (unites != null) 'unites': unites,
      if (q != null) 'q': q,
    });
  }

  DettransfCompanion copyWith(
      {Value<int>? num,
      Value<String?>? numtransf,
      Value<String?>? designation,
      Value<String?>? unites,
      Value<double?>? q}) {
    return DettransfCompanion(
      num: num ?? this.num,
      numtransf: numtransf ?? this.numtransf,
      designation: designation ?? this.designation,
      unites: unites ?? this.unites,
      q: q ?? this.q,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (num.present) {
      map['num'] = Variable<int>(num.value);
    }
    if (numtransf.present) {
      map['numtransf'] = Variable<String>(numtransf.value);
    }
    if (designation.present) {
      map['designation'] = Variable<String>(designation.value);
    }
    if (unites.present) {
      map['unites'] = Variable<String>(unites.value);
    }
    if (q.present) {
      map['q'] = Variable<double>(q.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DettransfCompanion(')
          ..write('num: $num, ')
          ..write('numtransf: $numtransf, ')
          ..write('designation: $designation, ')
          ..write('unites: $unites, ')
          ..write('q: $q')
          ..write(')'))
        .toString();
  }
}

class $DetventesTable extends Detventes
    with TableInfo<$DetventesTable, Detvente> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DetventesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _numMeta = const VerificationMeta('num');
  @override
  late final GeneratedColumn<int> num = GeneratedColumn<int>(
      'num', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _numventesMeta =
      const VerificationMeta('numventes');
  @override
  late final GeneratedColumn<String> numventes = GeneratedColumn<String>(
      'numventes', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _designationMeta =
      const VerificationMeta('designation');
  @override
  late final GeneratedColumn<String> designation = GeneratedColumn<String>(
      'designation', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _unitesMeta = const VerificationMeta('unites');
  @override
  late final GeneratedColumn<String> unites = GeneratedColumn<String>(
      'unites', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _depotsMeta = const VerificationMeta('depots');
  @override
  late final GeneratedColumn<String> depots = GeneratedColumn<String>(
      'depots', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _qMeta = const VerificationMeta('q');
  @override
  late final GeneratedColumn<double> q = GeneratedColumn<double>(
      'q', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _puMeta = const VerificationMeta('pu');
  @override
  late final GeneratedColumn<double> pu = GeneratedColumn<double>(
      'pu', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _datyMeta = const VerificationMeta('daty');
  @override
  late final GeneratedColumn<DateTime> daty = GeneratedColumn<DateTime>(
      'daty', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _embMeta = const VerificationMeta('emb');
  @override
  late final GeneratedColumn<String> emb = GeneratedColumn<String>(
      'emb', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _transpMeta = const VerificationMeta('transp');
  @override
  late final GeneratedColumn<String> transp = GeneratedColumn<String>(
      'transp', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _qeMeta = const VerificationMeta('qe');
  @override
  late final GeneratedColumn<double> qe = GeneratedColumn<double>(
      'qe', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        num,
        numventes,
        designation,
        unites,
        depots,
        q,
        pu,
        daty,
        emb,
        transp,
        qe
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'detventes';
  @override
  VerificationContext validateIntegrity(Insertable<Detvente> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('num')) {
      context.handle(
          _numMeta, num.isAcceptableOrUnknown(data['num']!, _numMeta));
    }
    if (data.containsKey('numventes')) {
      context.handle(_numventesMeta,
          numventes.isAcceptableOrUnknown(data['numventes']!, _numventesMeta));
    }
    if (data.containsKey('designation')) {
      context.handle(
          _designationMeta,
          designation.isAcceptableOrUnknown(
              data['designation']!, _designationMeta));
    }
    if (data.containsKey('unites')) {
      context.handle(_unitesMeta,
          unites.isAcceptableOrUnknown(data['unites']!, _unitesMeta));
    }
    if (data.containsKey('depots')) {
      context.handle(_depotsMeta,
          depots.isAcceptableOrUnknown(data['depots']!, _depotsMeta));
    }
    if (data.containsKey('q')) {
      context.handle(_qMeta, q.isAcceptableOrUnknown(data['q']!, _qMeta));
    }
    if (data.containsKey('pu')) {
      context.handle(_puMeta, pu.isAcceptableOrUnknown(data['pu']!, _puMeta));
    }
    if (data.containsKey('daty')) {
      context.handle(
          _datyMeta, daty.isAcceptableOrUnknown(data['daty']!, _datyMeta));
    }
    if (data.containsKey('emb')) {
      context.handle(
          _embMeta, emb.isAcceptableOrUnknown(data['emb']!, _embMeta));
    }
    if (data.containsKey('transp')) {
      context.handle(_transpMeta,
          transp.isAcceptableOrUnknown(data['transp']!, _transpMeta));
    }
    if (data.containsKey('qe')) {
      context.handle(_qeMeta, qe.isAcceptableOrUnknown(data['qe']!, _qeMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {num};
  @override
  Detvente map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Detvente(
      num: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}num'])!,
      numventes: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}numventes']),
      designation: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}designation']),
      unites: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}unites']),
      depots: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}depots']),
      q: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}q']),
      pu: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}pu']),
      daty: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}daty']),
      emb: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}emb']),
      transp: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}transp']),
      qe: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}qe']),
    );
  }

  @override
  $DetventesTable createAlias(String alias) {
    return $DetventesTable(attachedDatabase, alias);
  }
}

class Detvente extends DataClass implements Insertable<Detvente> {
  final int num;
  final String? numventes;
  final String? designation;
  final String? unites;
  final String? depots;
  final double? q;
  final double? pu;
  final DateTime? daty;
  final String? emb;
  final String? transp;
  final double? qe;
  const Detvente(
      {required this.num,
      this.numventes,
      this.designation,
      this.unites,
      this.depots,
      this.q,
      this.pu,
      this.daty,
      this.emb,
      this.transp,
      this.qe});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['num'] = Variable<int>(num);
    if (!nullToAbsent || numventes != null) {
      map['numventes'] = Variable<String>(numventes);
    }
    if (!nullToAbsent || designation != null) {
      map['designation'] = Variable<String>(designation);
    }
    if (!nullToAbsent || unites != null) {
      map['unites'] = Variable<String>(unites);
    }
    if (!nullToAbsent || depots != null) {
      map['depots'] = Variable<String>(depots);
    }
    if (!nullToAbsent || q != null) {
      map['q'] = Variable<double>(q);
    }
    if (!nullToAbsent || pu != null) {
      map['pu'] = Variable<double>(pu);
    }
    if (!nullToAbsent || daty != null) {
      map['daty'] = Variable<DateTime>(daty);
    }
    if (!nullToAbsent || emb != null) {
      map['emb'] = Variable<String>(emb);
    }
    if (!nullToAbsent || transp != null) {
      map['transp'] = Variable<String>(transp);
    }
    if (!nullToAbsent || qe != null) {
      map['qe'] = Variable<double>(qe);
    }
    return map;
  }

  DetventesCompanion toCompanion(bool nullToAbsent) {
    return DetventesCompanion(
      num: Value(num),
      numventes: numventes == null && nullToAbsent
          ? const Value.absent()
          : Value(numventes),
      designation: designation == null && nullToAbsent
          ? const Value.absent()
          : Value(designation),
      unites:
          unites == null && nullToAbsent ? const Value.absent() : Value(unites),
      depots:
          depots == null && nullToAbsent ? const Value.absent() : Value(depots),
      q: q == null && nullToAbsent ? const Value.absent() : Value(q),
      pu: pu == null && nullToAbsent ? const Value.absent() : Value(pu),
      daty: daty == null && nullToAbsent ? const Value.absent() : Value(daty),
      emb: emb == null && nullToAbsent ? const Value.absent() : Value(emb),
      transp:
          transp == null && nullToAbsent ? const Value.absent() : Value(transp),
      qe: qe == null && nullToAbsent ? const Value.absent() : Value(qe),
    );
  }

  factory Detvente.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Detvente(
      num: serializer.fromJson<int>(json['num']),
      numventes: serializer.fromJson<String?>(json['numventes']),
      designation: serializer.fromJson<String?>(json['designation']),
      unites: serializer.fromJson<String?>(json['unites']),
      depots: serializer.fromJson<String?>(json['depots']),
      q: serializer.fromJson<double?>(json['q']),
      pu: serializer.fromJson<double?>(json['pu']),
      daty: serializer.fromJson<DateTime?>(json['daty']),
      emb: serializer.fromJson<String?>(json['emb']),
      transp: serializer.fromJson<String?>(json['transp']),
      qe: serializer.fromJson<double?>(json['qe']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'num': serializer.toJson<int>(num),
      'numventes': serializer.toJson<String?>(numventes),
      'designation': serializer.toJson<String?>(designation),
      'unites': serializer.toJson<String?>(unites),
      'depots': serializer.toJson<String?>(depots),
      'q': serializer.toJson<double?>(q),
      'pu': serializer.toJson<double?>(pu),
      'daty': serializer.toJson<DateTime?>(daty),
      'emb': serializer.toJson<String?>(emb),
      'transp': serializer.toJson<String?>(transp),
      'qe': serializer.toJson<double?>(qe),
    };
  }

  Detvente copyWith(
          {int? num,
          Value<String?> numventes = const Value.absent(),
          Value<String?> designation = const Value.absent(),
          Value<String?> unites = const Value.absent(),
          Value<String?> depots = const Value.absent(),
          Value<double?> q = const Value.absent(),
          Value<double?> pu = const Value.absent(),
          Value<DateTime?> daty = const Value.absent(),
          Value<String?> emb = const Value.absent(),
          Value<String?> transp = const Value.absent(),
          Value<double?> qe = const Value.absent()}) =>
      Detvente(
        num: num ?? this.num,
        numventes: numventes.present ? numventes.value : this.numventes,
        designation: designation.present ? designation.value : this.designation,
        unites: unites.present ? unites.value : this.unites,
        depots: depots.present ? depots.value : this.depots,
        q: q.present ? q.value : this.q,
        pu: pu.present ? pu.value : this.pu,
        daty: daty.present ? daty.value : this.daty,
        emb: emb.present ? emb.value : this.emb,
        transp: transp.present ? transp.value : this.transp,
        qe: qe.present ? qe.value : this.qe,
      );
  Detvente copyWithCompanion(DetventesCompanion data) {
    return Detvente(
      num: data.num.present ? data.num.value : this.num,
      numventes: data.numventes.present ? data.numventes.value : this.numventes,
      designation:
          data.designation.present ? data.designation.value : this.designation,
      unites: data.unites.present ? data.unites.value : this.unites,
      depots: data.depots.present ? data.depots.value : this.depots,
      q: data.q.present ? data.q.value : this.q,
      pu: data.pu.present ? data.pu.value : this.pu,
      daty: data.daty.present ? data.daty.value : this.daty,
      emb: data.emb.present ? data.emb.value : this.emb,
      transp: data.transp.present ? data.transp.value : this.transp,
      qe: data.qe.present ? data.qe.value : this.qe,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Detvente(')
          ..write('num: $num, ')
          ..write('numventes: $numventes, ')
          ..write('designation: $designation, ')
          ..write('unites: $unites, ')
          ..write('depots: $depots, ')
          ..write('q: $q, ')
          ..write('pu: $pu, ')
          ..write('daty: $daty, ')
          ..write('emb: $emb, ')
          ..write('transp: $transp, ')
          ..write('qe: $qe')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(num, numventes, designation, unites, depots,
      q, pu, daty, emb, transp, qe);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Detvente &&
          other.num == this.num &&
          other.numventes == this.numventes &&
          other.designation == this.designation &&
          other.unites == this.unites &&
          other.depots == this.depots &&
          other.q == this.q &&
          other.pu == this.pu &&
          other.daty == this.daty &&
          other.emb == this.emb &&
          other.transp == this.transp &&
          other.qe == this.qe);
}

class DetventesCompanion extends UpdateCompanion<Detvente> {
  final Value<int> num;
  final Value<String?> numventes;
  final Value<String?> designation;
  final Value<String?> unites;
  final Value<String?> depots;
  final Value<double?> q;
  final Value<double?> pu;
  final Value<DateTime?> daty;
  final Value<String?> emb;
  final Value<String?> transp;
  final Value<double?> qe;
  const DetventesCompanion({
    this.num = const Value.absent(),
    this.numventes = const Value.absent(),
    this.designation = const Value.absent(),
    this.unites = const Value.absent(),
    this.depots = const Value.absent(),
    this.q = const Value.absent(),
    this.pu = const Value.absent(),
    this.daty = const Value.absent(),
    this.emb = const Value.absent(),
    this.transp = const Value.absent(),
    this.qe = const Value.absent(),
  });
  DetventesCompanion.insert({
    this.num = const Value.absent(),
    this.numventes = const Value.absent(),
    this.designation = const Value.absent(),
    this.unites = const Value.absent(),
    this.depots = const Value.absent(),
    this.q = const Value.absent(),
    this.pu = const Value.absent(),
    this.daty = const Value.absent(),
    this.emb = const Value.absent(),
    this.transp = const Value.absent(),
    this.qe = const Value.absent(),
  });
  static Insertable<Detvente> custom({
    Expression<int>? num,
    Expression<String>? numventes,
    Expression<String>? designation,
    Expression<String>? unites,
    Expression<String>? depots,
    Expression<double>? q,
    Expression<double>? pu,
    Expression<DateTime>? daty,
    Expression<String>? emb,
    Expression<String>? transp,
    Expression<double>? qe,
  }) {
    return RawValuesInsertable({
      if (num != null) 'num': num,
      if (numventes != null) 'numventes': numventes,
      if (designation != null) 'designation': designation,
      if (unites != null) 'unites': unites,
      if (depots != null) 'depots': depots,
      if (q != null) 'q': q,
      if (pu != null) 'pu': pu,
      if (daty != null) 'daty': daty,
      if (emb != null) 'emb': emb,
      if (transp != null) 'transp': transp,
      if (qe != null) 'qe': qe,
    });
  }

  DetventesCompanion copyWith(
      {Value<int>? num,
      Value<String?>? numventes,
      Value<String?>? designation,
      Value<String?>? unites,
      Value<String?>? depots,
      Value<double?>? q,
      Value<double?>? pu,
      Value<DateTime?>? daty,
      Value<String?>? emb,
      Value<String?>? transp,
      Value<double?>? qe}) {
    return DetventesCompanion(
      num: num ?? this.num,
      numventes: numventes ?? this.numventes,
      designation: designation ?? this.designation,
      unites: unites ?? this.unites,
      depots: depots ?? this.depots,
      q: q ?? this.q,
      pu: pu ?? this.pu,
      daty: daty ?? this.daty,
      emb: emb ?? this.emb,
      transp: transp ?? this.transp,
      qe: qe ?? this.qe,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (num.present) {
      map['num'] = Variable<int>(num.value);
    }
    if (numventes.present) {
      map['numventes'] = Variable<String>(numventes.value);
    }
    if (designation.present) {
      map['designation'] = Variable<String>(designation.value);
    }
    if (unites.present) {
      map['unites'] = Variable<String>(unites.value);
    }
    if (depots.present) {
      map['depots'] = Variable<String>(depots.value);
    }
    if (q.present) {
      map['q'] = Variable<double>(q.value);
    }
    if (pu.present) {
      map['pu'] = Variable<double>(pu.value);
    }
    if (daty.present) {
      map['daty'] = Variable<DateTime>(daty.value);
    }
    if (emb.present) {
      map['emb'] = Variable<String>(emb.value);
    }
    if (transp.present) {
      map['transp'] = Variable<String>(transp.value);
    }
    if (qe.present) {
      map['qe'] = Variable<double>(qe.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DetventesCompanion(')
          ..write('num: $num, ')
          ..write('numventes: $numventes, ')
          ..write('designation: $designation, ')
          ..write('unites: $unites, ')
          ..write('depots: $depots, ')
          ..write('q: $q, ')
          ..write('pu: $pu, ')
          ..write('daty: $daty, ')
          ..write('emb: $emb, ')
          ..write('transp: $transp, ')
          ..write('qe: $qe')
          ..write(')'))
        .toString();
  }
}

class $EffetsTable extends Effets with TableInfo<$EffetsTable, Effet> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $EffetsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _aMeta = const VerificationMeta('a');
  @override
  late final GeneratedColumn<int> a = GeneratedColumn<int>(
      'a', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _nopMeta = const VerificationMeta('nop');
  @override
  late final GeneratedColumn<int> nop = GeneratedColumn<int>(
      'nop', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _ncheqMeta = const VerificationMeta('ncheq');
  @override
  late final GeneratedColumn<String> ncheq = GeneratedColumn<String>(
      'ncheq', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _tireMeta = const VerificationMeta('tire');
  @override
  late final GeneratedColumn<String> tire = GeneratedColumn<String>(
      'tire', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _bqtireMeta = const VerificationMeta('bqtire');
  @override
  late final GeneratedColumn<String> bqtire = GeneratedColumn<String>(
      'bqtire', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _montantMeta =
      const VerificationMeta('montant');
  @override
  late final GeneratedColumn<double> montant = GeneratedColumn<double>(
      'montant', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _datechqMeta =
      const VerificationMeta('datechq');
  @override
  late final GeneratedColumn<DateTime> datechq = GeneratedColumn<DateTime>(
      'datechq', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _daterecepMeta =
      const VerificationMeta('daterecep');
  @override
  late final GeneratedColumn<DateTime> daterecep = GeneratedColumn<DateTime>(
      'daterecep', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _actionMeta = const VerificationMeta('action');
  @override
  late final GeneratedColumn<String> action = GeneratedColumn<String>(
      'action', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _nonactionMeta =
      const VerificationMeta('nonaction');
  @override
  late final GeneratedColumn<String> nonaction = GeneratedColumn<String>(
      'nonaction', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _numventesMeta =
      const VerificationMeta('numventes');
  @override
  late final GeneratedColumn<String> numventes = GeneratedColumn<String>(
      'numventes', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _verificationMeta =
      const VerificationMeta('verification');
  @override
  late final GeneratedColumn<String> verification = GeneratedColumn<String>(
      'verification', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        a,
        nop,
        ncheq,
        tire,
        bqtire,
        montant,
        datechq,
        daterecep,
        action,
        nonaction,
        numventes,
        verification
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'effets';
  @override
  VerificationContext validateIntegrity(Insertable<Effet> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('a')) {
      context.handle(_aMeta, a.isAcceptableOrUnknown(data['a']!, _aMeta));
    }
    if (data.containsKey('nop')) {
      context.handle(
          _nopMeta, nop.isAcceptableOrUnknown(data['nop']!, _nopMeta));
    }
    if (data.containsKey('ncheq')) {
      context.handle(
          _ncheqMeta, ncheq.isAcceptableOrUnknown(data['ncheq']!, _ncheqMeta));
    }
    if (data.containsKey('tire')) {
      context.handle(
          _tireMeta, tire.isAcceptableOrUnknown(data['tire']!, _tireMeta));
    }
    if (data.containsKey('bqtire')) {
      context.handle(_bqtireMeta,
          bqtire.isAcceptableOrUnknown(data['bqtire']!, _bqtireMeta));
    }
    if (data.containsKey('montant')) {
      context.handle(_montantMeta,
          montant.isAcceptableOrUnknown(data['montant']!, _montantMeta));
    }
    if (data.containsKey('datechq')) {
      context.handle(_datechqMeta,
          datechq.isAcceptableOrUnknown(data['datechq']!, _datechqMeta));
    }
    if (data.containsKey('daterecep')) {
      context.handle(_daterecepMeta,
          daterecep.isAcceptableOrUnknown(data['daterecep']!, _daterecepMeta));
    }
    if (data.containsKey('action')) {
      context.handle(_actionMeta,
          action.isAcceptableOrUnknown(data['action']!, _actionMeta));
    }
    if (data.containsKey('nonaction')) {
      context.handle(_nonactionMeta,
          nonaction.isAcceptableOrUnknown(data['nonaction']!, _nonactionMeta));
    }
    if (data.containsKey('numventes')) {
      context.handle(_numventesMeta,
          numventes.isAcceptableOrUnknown(data['numventes']!, _numventesMeta));
    }
    if (data.containsKey('verification')) {
      context.handle(
          _verificationMeta,
          verification.isAcceptableOrUnknown(
              data['verification']!, _verificationMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => const {};
  @override
  Effet map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Effet(
      a: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}a']),
      nop: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}nop']),
      ncheq: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}ncheq']),
      tire: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tire']),
      bqtire: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}bqtire']),
      montant: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}montant']),
      datechq: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}datechq']),
      daterecep: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}daterecep']),
      action: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}action']),
      nonaction: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}nonaction']),
      numventes: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}numventes']),
      verification: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}verification']),
    );
  }

  @override
  $EffetsTable createAlias(String alias) {
    return $EffetsTable(attachedDatabase, alias);
  }
}

class Effet extends DataClass implements Insertable<Effet> {
  final int? a;
  final int? nop;
  final String? ncheq;
  final String? tire;
  final String? bqtire;
  final double? montant;
  final DateTime? datechq;
  final DateTime? daterecep;
  final String? action;
  final String? nonaction;
  final String? numventes;
  final String? verification;
  const Effet(
      {this.a,
      this.nop,
      this.ncheq,
      this.tire,
      this.bqtire,
      this.montant,
      this.datechq,
      this.daterecep,
      this.action,
      this.nonaction,
      this.numventes,
      this.verification});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || a != null) {
      map['a'] = Variable<int>(a);
    }
    if (!nullToAbsent || nop != null) {
      map['nop'] = Variable<int>(nop);
    }
    if (!nullToAbsent || ncheq != null) {
      map['ncheq'] = Variable<String>(ncheq);
    }
    if (!nullToAbsent || tire != null) {
      map['tire'] = Variable<String>(tire);
    }
    if (!nullToAbsent || bqtire != null) {
      map['bqtire'] = Variable<String>(bqtire);
    }
    if (!nullToAbsent || montant != null) {
      map['montant'] = Variable<double>(montant);
    }
    if (!nullToAbsent || datechq != null) {
      map['datechq'] = Variable<DateTime>(datechq);
    }
    if (!nullToAbsent || daterecep != null) {
      map['daterecep'] = Variable<DateTime>(daterecep);
    }
    if (!nullToAbsent || action != null) {
      map['action'] = Variable<String>(action);
    }
    if (!nullToAbsent || nonaction != null) {
      map['nonaction'] = Variable<String>(nonaction);
    }
    if (!nullToAbsent || numventes != null) {
      map['numventes'] = Variable<String>(numventes);
    }
    if (!nullToAbsent || verification != null) {
      map['verification'] = Variable<String>(verification);
    }
    return map;
  }

  EffetsCompanion toCompanion(bool nullToAbsent) {
    return EffetsCompanion(
      a: a == null && nullToAbsent ? const Value.absent() : Value(a),
      nop: nop == null && nullToAbsent ? const Value.absent() : Value(nop),
      ncheq:
          ncheq == null && nullToAbsent ? const Value.absent() : Value(ncheq),
      tire: tire == null && nullToAbsent ? const Value.absent() : Value(tire),
      bqtire:
          bqtire == null && nullToAbsent ? const Value.absent() : Value(bqtire),
      montant: montant == null && nullToAbsent
          ? const Value.absent()
          : Value(montant),
      datechq: datechq == null && nullToAbsent
          ? const Value.absent()
          : Value(datechq),
      daterecep: daterecep == null && nullToAbsent
          ? const Value.absent()
          : Value(daterecep),
      action:
          action == null && nullToAbsent ? const Value.absent() : Value(action),
      nonaction: nonaction == null && nullToAbsent
          ? const Value.absent()
          : Value(nonaction),
      numventes: numventes == null && nullToAbsent
          ? const Value.absent()
          : Value(numventes),
      verification: verification == null && nullToAbsent
          ? const Value.absent()
          : Value(verification),
    );
  }

  factory Effet.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Effet(
      a: serializer.fromJson<int?>(json['a']),
      nop: serializer.fromJson<int?>(json['nop']),
      ncheq: serializer.fromJson<String?>(json['ncheq']),
      tire: serializer.fromJson<String?>(json['tire']),
      bqtire: serializer.fromJson<String?>(json['bqtire']),
      montant: serializer.fromJson<double?>(json['montant']),
      datechq: serializer.fromJson<DateTime?>(json['datechq']),
      daterecep: serializer.fromJson<DateTime?>(json['daterecep']),
      action: serializer.fromJson<String?>(json['action']),
      nonaction: serializer.fromJson<String?>(json['nonaction']),
      numventes: serializer.fromJson<String?>(json['numventes']),
      verification: serializer.fromJson<String?>(json['verification']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'a': serializer.toJson<int?>(a),
      'nop': serializer.toJson<int?>(nop),
      'ncheq': serializer.toJson<String?>(ncheq),
      'tire': serializer.toJson<String?>(tire),
      'bqtire': serializer.toJson<String?>(bqtire),
      'montant': serializer.toJson<double?>(montant),
      'datechq': serializer.toJson<DateTime?>(datechq),
      'daterecep': serializer.toJson<DateTime?>(daterecep),
      'action': serializer.toJson<String?>(action),
      'nonaction': serializer.toJson<String?>(nonaction),
      'numventes': serializer.toJson<String?>(numventes),
      'verification': serializer.toJson<String?>(verification),
    };
  }

  Effet copyWith(
          {Value<int?> a = const Value.absent(),
          Value<int?> nop = const Value.absent(),
          Value<String?> ncheq = const Value.absent(),
          Value<String?> tire = const Value.absent(),
          Value<String?> bqtire = const Value.absent(),
          Value<double?> montant = const Value.absent(),
          Value<DateTime?> datechq = const Value.absent(),
          Value<DateTime?> daterecep = const Value.absent(),
          Value<String?> action = const Value.absent(),
          Value<String?> nonaction = const Value.absent(),
          Value<String?> numventes = const Value.absent(),
          Value<String?> verification = const Value.absent()}) =>
      Effet(
        a: a.present ? a.value : this.a,
        nop: nop.present ? nop.value : this.nop,
        ncheq: ncheq.present ? ncheq.value : this.ncheq,
        tire: tire.present ? tire.value : this.tire,
        bqtire: bqtire.present ? bqtire.value : this.bqtire,
        montant: montant.present ? montant.value : this.montant,
        datechq: datechq.present ? datechq.value : this.datechq,
        daterecep: daterecep.present ? daterecep.value : this.daterecep,
        action: action.present ? action.value : this.action,
        nonaction: nonaction.present ? nonaction.value : this.nonaction,
        numventes: numventes.present ? numventes.value : this.numventes,
        verification:
            verification.present ? verification.value : this.verification,
      );
  Effet copyWithCompanion(EffetsCompanion data) {
    return Effet(
      a: data.a.present ? data.a.value : this.a,
      nop: data.nop.present ? data.nop.value : this.nop,
      ncheq: data.ncheq.present ? data.ncheq.value : this.ncheq,
      tire: data.tire.present ? data.tire.value : this.tire,
      bqtire: data.bqtire.present ? data.bqtire.value : this.bqtire,
      montant: data.montant.present ? data.montant.value : this.montant,
      datechq: data.datechq.present ? data.datechq.value : this.datechq,
      daterecep: data.daterecep.present ? data.daterecep.value : this.daterecep,
      action: data.action.present ? data.action.value : this.action,
      nonaction: data.nonaction.present ? data.nonaction.value : this.nonaction,
      numventes: data.numventes.present ? data.numventes.value : this.numventes,
      verification: data.verification.present
          ? data.verification.value
          : this.verification,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Effet(')
          ..write('a: $a, ')
          ..write('nop: $nop, ')
          ..write('ncheq: $ncheq, ')
          ..write('tire: $tire, ')
          ..write('bqtire: $bqtire, ')
          ..write('montant: $montant, ')
          ..write('datechq: $datechq, ')
          ..write('daterecep: $daterecep, ')
          ..write('action: $action, ')
          ..write('nonaction: $nonaction, ')
          ..write('numventes: $numventes, ')
          ..write('verification: $verification')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(a, nop, ncheq, tire, bqtire, montant, datechq,
      daterecep, action, nonaction, numventes, verification);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Effet &&
          other.a == this.a &&
          other.nop == this.nop &&
          other.ncheq == this.ncheq &&
          other.tire == this.tire &&
          other.bqtire == this.bqtire &&
          other.montant == this.montant &&
          other.datechq == this.datechq &&
          other.daterecep == this.daterecep &&
          other.action == this.action &&
          other.nonaction == this.nonaction &&
          other.numventes == this.numventes &&
          other.verification == this.verification);
}

class EffetsCompanion extends UpdateCompanion<Effet> {
  final Value<int?> a;
  final Value<int?> nop;
  final Value<String?> ncheq;
  final Value<String?> tire;
  final Value<String?> bqtire;
  final Value<double?> montant;
  final Value<DateTime?> datechq;
  final Value<DateTime?> daterecep;
  final Value<String?> action;
  final Value<String?> nonaction;
  final Value<String?> numventes;
  final Value<String?> verification;
  final Value<int> rowid;
  const EffetsCompanion({
    this.a = const Value.absent(),
    this.nop = const Value.absent(),
    this.ncheq = const Value.absent(),
    this.tire = const Value.absent(),
    this.bqtire = const Value.absent(),
    this.montant = const Value.absent(),
    this.datechq = const Value.absent(),
    this.daterecep = const Value.absent(),
    this.action = const Value.absent(),
    this.nonaction = const Value.absent(),
    this.numventes = const Value.absent(),
    this.verification = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  EffetsCompanion.insert({
    this.a = const Value.absent(),
    this.nop = const Value.absent(),
    this.ncheq = const Value.absent(),
    this.tire = const Value.absent(),
    this.bqtire = const Value.absent(),
    this.montant = const Value.absent(),
    this.datechq = const Value.absent(),
    this.daterecep = const Value.absent(),
    this.action = const Value.absent(),
    this.nonaction = const Value.absent(),
    this.numventes = const Value.absent(),
    this.verification = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  static Insertable<Effet> custom({
    Expression<int>? a,
    Expression<int>? nop,
    Expression<String>? ncheq,
    Expression<String>? tire,
    Expression<String>? bqtire,
    Expression<double>? montant,
    Expression<DateTime>? datechq,
    Expression<DateTime>? daterecep,
    Expression<String>? action,
    Expression<String>? nonaction,
    Expression<String>? numventes,
    Expression<String>? verification,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (a != null) 'a': a,
      if (nop != null) 'nop': nop,
      if (ncheq != null) 'ncheq': ncheq,
      if (tire != null) 'tire': tire,
      if (bqtire != null) 'bqtire': bqtire,
      if (montant != null) 'montant': montant,
      if (datechq != null) 'datechq': datechq,
      if (daterecep != null) 'daterecep': daterecep,
      if (action != null) 'action': action,
      if (nonaction != null) 'nonaction': nonaction,
      if (numventes != null) 'numventes': numventes,
      if (verification != null) 'verification': verification,
      if (rowid != null) 'rowid': rowid,
    });
  }

  EffetsCompanion copyWith(
      {Value<int?>? a,
      Value<int?>? nop,
      Value<String?>? ncheq,
      Value<String?>? tire,
      Value<String?>? bqtire,
      Value<double?>? montant,
      Value<DateTime?>? datechq,
      Value<DateTime?>? daterecep,
      Value<String?>? action,
      Value<String?>? nonaction,
      Value<String?>? numventes,
      Value<String?>? verification,
      Value<int>? rowid}) {
    return EffetsCompanion(
      a: a ?? this.a,
      nop: nop ?? this.nop,
      ncheq: ncheq ?? this.ncheq,
      tire: tire ?? this.tire,
      bqtire: bqtire ?? this.bqtire,
      montant: montant ?? this.montant,
      datechq: datechq ?? this.datechq,
      daterecep: daterecep ?? this.daterecep,
      action: action ?? this.action,
      nonaction: nonaction ?? this.nonaction,
      numventes: numventes ?? this.numventes,
      verification: verification ?? this.verification,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (a.present) {
      map['a'] = Variable<int>(a.value);
    }
    if (nop.present) {
      map['nop'] = Variable<int>(nop.value);
    }
    if (ncheq.present) {
      map['ncheq'] = Variable<String>(ncheq.value);
    }
    if (tire.present) {
      map['tire'] = Variable<String>(tire.value);
    }
    if (bqtire.present) {
      map['bqtire'] = Variable<String>(bqtire.value);
    }
    if (montant.present) {
      map['montant'] = Variable<double>(montant.value);
    }
    if (datechq.present) {
      map['datechq'] = Variable<DateTime>(datechq.value);
    }
    if (daterecep.present) {
      map['daterecep'] = Variable<DateTime>(daterecep.value);
    }
    if (action.present) {
      map['action'] = Variable<String>(action.value);
    }
    if (nonaction.present) {
      map['nonaction'] = Variable<String>(nonaction.value);
    }
    if (numventes.present) {
      map['numventes'] = Variable<String>(numventes.value);
    }
    if (verification.present) {
      map['verification'] = Variable<String>(verification.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('EffetsCompanion(')
          ..write('a: $a, ')
          ..write('nop: $nop, ')
          ..write('ncheq: $ncheq, ')
          ..write('tire: $tire, ')
          ..write('bqtire: $bqtire, ')
          ..write('montant: $montant, ')
          ..write('datechq: $datechq, ')
          ..write('daterecep: $daterecep, ')
          ..write('action: $action, ')
          ..write('nonaction: $nonaction, ')
          ..write('numventes: $numventes, ')
          ..write('verification: $verification, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $EmbTable extends Emb with TableInfo<$EmbTable, EmbData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $EmbTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _designationMeta =
      const VerificationMeta('designation');
  @override
  late final GeneratedColumn<String> designation = GeneratedColumn<String>(
      'designation', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _voMeta = const VerificationMeta('vo');
  @override
  late final GeneratedColumn<double> vo = GeneratedColumn<double>(
      'vo', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _actionMeta = const VerificationMeta('action');
  @override
  late final GeneratedColumn<String> action = GeneratedColumn<String>(
      'action', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _categorieMeta =
      const VerificationMeta('categorie');
  @override
  late final GeneratedColumn<String> categorie = GeneratedColumn<String>(
      'categorie', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _amtMeta = const VerificationMeta('amt');
  @override
  late final GeneratedColumn<double> amt = GeneratedColumn<double>(
      'amt', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _datyMeta = const VerificationMeta('daty');
  @override
  late final GeneratedColumn<DateTime> daty = GeneratedColumn<DateTime>(
      'daty', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
      'description', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tauxMeta = const VerificationMeta('taux');
  @override
  late final GeneratedColumn<double> taux = GeneratedColumn<double>(
      'taux', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns =>
      [designation, vo, action, categorie, amt, daty, description, taux];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'emb';
  @override
  VerificationContext validateIntegrity(Insertable<EmbData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('designation')) {
      context.handle(
          _designationMeta,
          designation.isAcceptableOrUnknown(
              data['designation']!, _designationMeta));
    } else if (isInserting) {
      context.missing(_designationMeta);
    }
    if (data.containsKey('vo')) {
      context.handle(_voMeta, vo.isAcceptableOrUnknown(data['vo']!, _voMeta));
    }
    if (data.containsKey('action')) {
      context.handle(_actionMeta,
          action.isAcceptableOrUnknown(data['action']!, _actionMeta));
    }
    if (data.containsKey('categorie')) {
      context.handle(_categorieMeta,
          categorie.isAcceptableOrUnknown(data['categorie']!, _categorieMeta));
    }
    if (data.containsKey('amt')) {
      context.handle(
          _amtMeta, amt.isAcceptableOrUnknown(data['amt']!, _amtMeta));
    }
    if (data.containsKey('daty')) {
      context.handle(
          _datyMeta, daty.isAcceptableOrUnknown(data['daty']!, _datyMeta));
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description']!, _descriptionMeta));
    }
    if (data.containsKey('taux')) {
      context.handle(
          _tauxMeta, taux.isAcceptableOrUnknown(data['taux']!, _tauxMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {designation};
  @override
  EmbData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return EmbData(
      designation: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}designation'])!,
      vo: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}vo']),
      action: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}action']),
      categorie: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}categorie']),
      amt: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}amt']),
      daty: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}daty']),
      description: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}description']),
      taux: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}taux']),
    );
  }

  @override
  $EmbTable createAlias(String alias) {
    return $EmbTable(attachedDatabase, alias);
  }
}

class EmbData extends DataClass implements Insertable<EmbData> {
  final String designation;
  final double? vo;
  final String? action;
  final String? categorie;
  final double? amt;
  final DateTime? daty;
  final String? description;
  final double? taux;
  const EmbData(
      {required this.designation,
      this.vo,
      this.action,
      this.categorie,
      this.amt,
      this.daty,
      this.description,
      this.taux});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['designation'] = Variable<String>(designation);
    if (!nullToAbsent || vo != null) {
      map['vo'] = Variable<double>(vo);
    }
    if (!nullToAbsent || action != null) {
      map['action'] = Variable<String>(action);
    }
    if (!nullToAbsent || categorie != null) {
      map['categorie'] = Variable<String>(categorie);
    }
    if (!nullToAbsent || amt != null) {
      map['amt'] = Variable<double>(amt);
    }
    if (!nullToAbsent || daty != null) {
      map['daty'] = Variable<DateTime>(daty);
    }
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    if (!nullToAbsent || taux != null) {
      map['taux'] = Variable<double>(taux);
    }
    return map;
  }

  EmbCompanion toCompanion(bool nullToAbsent) {
    return EmbCompanion(
      designation: Value(designation),
      vo: vo == null && nullToAbsent ? const Value.absent() : Value(vo),
      action:
          action == null && nullToAbsent ? const Value.absent() : Value(action),
      categorie: categorie == null && nullToAbsent
          ? const Value.absent()
          : Value(categorie),
      amt: amt == null && nullToAbsent ? const Value.absent() : Value(amt),
      daty: daty == null && nullToAbsent ? const Value.absent() : Value(daty),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      taux: taux == null && nullToAbsent ? const Value.absent() : Value(taux),
    );
  }

  factory EmbData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return EmbData(
      designation: serializer.fromJson<String>(json['designation']),
      vo: serializer.fromJson<double?>(json['vo']),
      action: serializer.fromJson<String?>(json['action']),
      categorie: serializer.fromJson<String?>(json['categorie']),
      amt: serializer.fromJson<double?>(json['amt']),
      daty: serializer.fromJson<DateTime?>(json['daty']),
      description: serializer.fromJson<String?>(json['description']),
      taux: serializer.fromJson<double?>(json['taux']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'designation': serializer.toJson<String>(designation),
      'vo': serializer.toJson<double?>(vo),
      'action': serializer.toJson<String?>(action),
      'categorie': serializer.toJson<String?>(categorie),
      'amt': serializer.toJson<double?>(amt),
      'daty': serializer.toJson<DateTime?>(daty),
      'description': serializer.toJson<String?>(description),
      'taux': serializer.toJson<double?>(taux),
    };
  }

  EmbData copyWith(
          {String? designation,
          Value<double?> vo = const Value.absent(),
          Value<String?> action = const Value.absent(),
          Value<String?> categorie = const Value.absent(),
          Value<double?> amt = const Value.absent(),
          Value<DateTime?> daty = const Value.absent(),
          Value<String?> description = const Value.absent(),
          Value<double?> taux = const Value.absent()}) =>
      EmbData(
        designation: designation ?? this.designation,
        vo: vo.present ? vo.value : this.vo,
        action: action.present ? action.value : this.action,
        categorie: categorie.present ? categorie.value : this.categorie,
        amt: amt.present ? amt.value : this.amt,
        daty: daty.present ? daty.value : this.daty,
        description: description.present ? description.value : this.description,
        taux: taux.present ? taux.value : this.taux,
      );
  EmbData copyWithCompanion(EmbCompanion data) {
    return EmbData(
      designation:
          data.designation.present ? data.designation.value : this.designation,
      vo: data.vo.present ? data.vo.value : this.vo,
      action: data.action.present ? data.action.value : this.action,
      categorie: data.categorie.present ? data.categorie.value : this.categorie,
      amt: data.amt.present ? data.amt.value : this.amt,
      daty: data.daty.present ? data.daty.value : this.daty,
      description:
          data.description.present ? data.description.value : this.description,
      taux: data.taux.present ? data.taux.value : this.taux,
    );
  }

  @override
  String toString() {
    return (StringBuffer('EmbData(')
          ..write('designation: $designation, ')
          ..write('vo: $vo, ')
          ..write('action: $action, ')
          ..write('categorie: $categorie, ')
          ..write('amt: $amt, ')
          ..write('daty: $daty, ')
          ..write('description: $description, ')
          ..write('taux: $taux')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      designation, vo, action, categorie, amt, daty, description, taux);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is EmbData &&
          other.designation == this.designation &&
          other.vo == this.vo &&
          other.action == this.action &&
          other.categorie == this.categorie &&
          other.amt == this.amt &&
          other.daty == this.daty &&
          other.description == this.description &&
          other.taux == this.taux);
}

class EmbCompanion extends UpdateCompanion<EmbData> {
  final Value<String> designation;
  final Value<double?> vo;
  final Value<String?> action;
  final Value<String?> categorie;
  final Value<double?> amt;
  final Value<DateTime?> daty;
  final Value<String?> description;
  final Value<double?> taux;
  final Value<int> rowid;
  const EmbCompanion({
    this.designation = const Value.absent(),
    this.vo = const Value.absent(),
    this.action = const Value.absent(),
    this.categorie = const Value.absent(),
    this.amt = const Value.absent(),
    this.daty = const Value.absent(),
    this.description = const Value.absent(),
    this.taux = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  EmbCompanion.insert({
    required String designation,
    this.vo = const Value.absent(),
    this.action = const Value.absent(),
    this.categorie = const Value.absent(),
    this.amt = const Value.absent(),
    this.daty = const Value.absent(),
    this.description = const Value.absent(),
    this.taux = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : designation = Value(designation);
  static Insertable<EmbData> custom({
    Expression<String>? designation,
    Expression<double>? vo,
    Expression<String>? action,
    Expression<String>? categorie,
    Expression<double>? amt,
    Expression<DateTime>? daty,
    Expression<String>? description,
    Expression<double>? taux,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (designation != null) 'designation': designation,
      if (vo != null) 'vo': vo,
      if (action != null) 'action': action,
      if (categorie != null) 'categorie': categorie,
      if (amt != null) 'amt': amt,
      if (daty != null) 'daty': daty,
      if (description != null) 'description': description,
      if (taux != null) 'taux': taux,
      if (rowid != null) 'rowid': rowid,
    });
  }

  EmbCompanion copyWith(
      {Value<String>? designation,
      Value<double?>? vo,
      Value<String?>? action,
      Value<String?>? categorie,
      Value<double?>? amt,
      Value<DateTime?>? daty,
      Value<String?>? description,
      Value<double?>? taux,
      Value<int>? rowid}) {
    return EmbCompanion(
      designation: designation ?? this.designation,
      vo: vo ?? this.vo,
      action: action ?? this.action,
      categorie: categorie ?? this.categorie,
      amt: amt ?? this.amt,
      daty: daty ?? this.daty,
      description: description ?? this.description,
      taux: taux ?? this.taux,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (designation.present) {
      map['designation'] = Variable<String>(designation.value);
    }
    if (vo.present) {
      map['vo'] = Variable<double>(vo.value);
    }
    if (action.present) {
      map['action'] = Variable<String>(action.value);
    }
    if (categorie.present) {
      map['categorie'] = Variable<String>(categorie.value);
    }
    if (amt.present) {
      map['amt'] = Variable<double>(amt.value);
    }
    if (daty.present) {
      map['daty'] = Variable<DateTime>(daty.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (taux.present) {
      map['taux'] = Variable<double>(taux.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('EmbCompanion(')
          ..write('designation: $designation, ')
          ..write('vo: $vo, ')
          ..write('action: $action, ')
          ..write('categorie: $categorie, ')
          ..write('amt: $amt, ')
          ..write('daty: $daty, ')
          ..write('description: $description, ')
          ..write('taux: $taux, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $EmblcltTable extends Emblclt with TableInfo<$EmblcltTable, EmblcltData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $EmblcltTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _numMeta = const VerificationMeta('num');
  @override
  late final GeneratedColumn<int> num = GeneratedColumn<int>(
      'num', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _numventesMeta =
      const VerificationMeta('numventes');
  @override
  late final GeneratedColumn<String> numventes = GeneratedColumn<String>(
      'numventes', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _nfactMeta = const VerificationMeta('nfact');
  @override
  late final GeneratedColumn<String> nfact = GeneratedColumn<String>(
      'nfact', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _datyMeta = const VerificationMeta('daty');
  @override
  late final GeneratedColumn<DateTime> daty = GeneratedColumn<DateTime>(
      'daty', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _cltMeta = const VerificationMeta('clt');
  @override
  late final GeneratedColumn<String> clt = GeneratedColumn<String>(
      'clt', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _embMeta = const VerificationMeta('emb');
  @override
  late final GeneratedColumn<String> emb = GeneratedColumn<String>(
      'emb', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _qMeta = const VerificationMeta('q');
  @override
  late final GeneratedColumn<double> q = GeneratedColumn<double>(
      'q', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _verificationMeta =
      const VerificationMeta('verification');
  @override
  late final GeneratedColumn<String> verification = GeneratedColumn<String>(
      'verification', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns =>
      [num, numventes, nfact, daty, clt, emb, q, verification];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'emblclt';
  @override
  VerificationContext validateIntegrity(Insertable<EmblcltData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('num')) {
      context.handle(
          _numMeta, num.isAcceptableOrUnknown(data['num']!, _numMeta));
    }
    if (data.containsKey('numventes')) {
      context.handle(_numventesMeta,
          numventes.isAcceptableOrUnknown(data['numventes']!, _numventesMeta));
    }
    if (data.containsKey('nfact')) {
      context.handle(
          _nfactMeta, nfact.isAcceptableOrUnknown(data['nfact']!, _nfactMeta));
    }
    if (data.containsKey('daty')) {
      context.handle(
          _datyMeta, daty.isAcceptableOrUnknown(data['daty']!, _datyMeta));
    }
    if (data.containsKey('clt')) {
      context.handle(
          _cltMeta, clt.isAcceptableOrUnknown(data['clt']!, _cltMeta));
    }
    if (data.containsKey('emb')) {
      context.handle(
          _embMeta, emb.isAcceptableOrUnknown(data['emb']!, _embMeta));
    }
    if (data.containsKey('q')) {
      context.handle(_qMeta, q.isAcceptableOrUnknown(data['q']!, _qMeta));
    }
    if (data.containsKey('verification')) {
      context.handle(
          _verificationMeta,
          verification.isAcceptableOrUnknown(
              data['verification']!, _verificationMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {num};
  @override
  EmblcltData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return EmblcltData(
      num: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}num'])!,
      numventes: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}numventes']),
      nfact: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}nfact']),
      daty: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}daty']),
      clt: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}clt']),
      emb: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}emb']),
      q: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}q']),
      verification: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}verification']),
    );
  }

  @override
  $EmblcltTable createAlias(String alias) {
    return $EmblcltTable(attachedDatabase, alias);
  }
}

class EmblcltData extends DataClass implements Insertable<EmblcltData> {
  final int num;
  final String? numventes;
  final String? nfact;
  final DateTime? daty;
  final String? clt;
  final String? emb;
  final double? q;
  final String? verification;
  const EmblcltData(
      {required this.num,
      this.numventes,
      this.nfact,
      this.daty,
      this.clt,
      this.emb,
      this.q,
      this.verification});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['num'] = Variable<int>(num);
    if (!nullToAbsent || numventes != null) {
      map['numventes'] = Variable<String>(numventes);
    }
    if (!nullToAbsent || nfact != null) {
      map['nfact'] = Variable<String>(nfact);
    }
    if (!nullToAbsent || daty != null) {
      map['daty'] = Variable<DateTime>(daty);
    }
    if (!nullToAbsent || clt != null) {
      map['clt'] = Variable<String>(clt);
    }
    if (!nullToAbsent || emb != null) {
      map['emb'] = Variable<String>(emb);
    }
    if (!nullToAbsent || q != null) {
      map['q'] = Variable<double>(q);
    }
    if (!nullToAbsent || verification != null) {
      map['verification'] = Variable<String>(verification);
    }
    return map;
  }

  EmblcltCompanion toCompanion(bool nullToAbsent) {
    return EmblcltCompanion(
      num: Value(num),
      numventes: numventes == null && nullToAbsent
          ? const Value.absent()
          : Value(numventes),
      nfact:
          nfact == null && nullToAbsent ? const Value.absent() : Value(nfact),
      daty: daty == null && nullToAbsent ? const Value.absent() : Value(daty),
      clt: clt == null && nullToAbsent ? const Value.absent() : Value(clt),
      emb: emb == null && nullToAbsent ? const Value.absent() : Value(emb),
      q: q == null && nullToAbsent ? const Value.absent() : Value(q),
      verification: verification == null && nullToAbsent
          ? const Value.absent()
          : Value(verification),
    );
  }

  factory EmblcltData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return EmblcltData(
      num: serializer.fromJson<int>(json['num']),
      numventes: serializer.fromJson<String?>(json['numventes']),
      nfact: serializer.fromJson<String?>(json['nfact']),
      daty: serializer.fromJson<DateTime?>(json['daty']),
      clt: serializer.fromJson<String?>(json['clt']),
      emb: serializer.fromJson<String?>(json['emb']),
      q: serializer.fromJson<double?>(json['q']),
      verification: serializer.fromJson<String?>(json['verification']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'num': serializer.toJson<int>(num),
      'numventes': serializer.toJson<String?>(numventes),
      'nfact': serializer.toJson<String?>(nfact),
      'daty': serializer.toJson<DateTime?>(daty),
      'clt': serializer.toJson<String?>(clt),
      'emb': serializer.toJson<String?>(emb),
      'q': serializer.toJson<double?>(q),
      'verification': serializer.toJson<String?>(verification),
    };
  }

  EmblcltData copyWith(
          {int? num,
          Value<String?> numventes = const Value.absent(),
          Value<String?> nfact = const Value.absent(),
          Value<DateTime?> daty = const Value.absent(),
          Value<String?> clt = const Value.absent(),
          Value<String?> emb = const Value.absent(),
          Value<double?> q = const Value.absent(),
          Value<String?> verification = const Value.absent()}) =>
      EmblcltData(
        num: num ?? this.num,
        numventes: numventes.present ? numventes.value : this.numventes,
        nfact: nfact.present ? nfact.value : this.nfact,
        daty: daty.present ? daty.value : this.daty,
        clt: clt.present ? clt.value : this.clt,
        emb: emb.present ? emb.value : this.emb,
        q: q.present ? q.value : this.q,
        verification:
            verification.present ? verification.value : this.verification,
      );
  EmblcltData copyWithCompanion(EmblcltCompanion data) {
    return EmblcltData(
      num: data.num.present ? data.num.value : this.num,
      numventes: data.numventes.present ? data.numventes.value : this.numventes,
      nfact: data.nfact.present ? data.nfact.value : this.nfact,
      daty: data.daty.present ? data.daty.value : this.daty,
      clt: data.clt.present ? data.clt.value : this.clt,
      emb: data.emb.present ? data.emb.value : this.emb,
      q: data.q.present ? data.q.value : this.q,
      verification: data.verification.present
          ? data.verification.value
          : this.verification,
    );
  }

  @override
  String toString() {
    return (StringBuffer('EmblcltData(')
          ..write('num: $num, ')
          ..write('numventes: $numventes, ')
          ..write('nfact: $nfact, ')
          ..write('daty: $daty, ')
          ..write('clt: $clt, ')
          ..write('emb: $emb, ')
          ..write('q: $q, ')
          ..write('verification: $verification')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(num, numventes, nfact, daty, clt, emb, q, verification);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is EmblcltData &&
          other.num == this.num &&
          other.numventes == this.numventes &&
          other.nfact == this.nfact &&
          other.daty == this.daty &&
          other.clt == this.clt &&
          other.emb == this.emb &&
          other.q == this.q &&
          other.verification == this.verification);
}

class EmblcltCompanion extends UpdateCompanion<EmblcltData> {
  final Value<int> num;
  final Value<String?> numventes;
  final Value<String?> nfact;
  final Value<DateTime?> daty;
  final Value<String?> clt;
  final Value<String?> emb;
  final Value<double?> q;
  final Value<String?> verification;
  const EmblcltCompanion({
    this.num = const Value.absent(),
    this.numventes = const Value.absent(),
    this.nfact = const Value.absent(),
    this.daty = const Value.absent(),
    this.clt = const Value.absent(),
    this.emb = const Value.absent(),
    this.q = const Value.absent(),
    this.verification = const Value.absent(),
  });
  EmblcltCompanion.insert({
    this.num = const Value.absent(),
    this.numventes = const Value.absent(),
    this.nfact = const Value.absent(),
    this.daty = const Value.absent(),
    this.clt = const Value.absent(),
    this.emb = const Value.absent(),
    this.q = const Value.absent(),
    this.verification = const Value.absent(),
  });
  static Insertable<EmblcltData> custom({
    Expression<int>? num,
    Expression<String>? numventes,
    Expression<String>? nfact,
    Expression<DateTime>? daty,
    Expression<String>? clt,
    Expression<String>? emb,
    Expression<double>? q,
    Expression<String>? verification,
  }) {
    return RawValuesInsertable({
      if (num != null) 'num': num,
      if (numventes != null) 'numventes': numventes,
      if (nfact != null) 'nfact': nfact,
      if (daty != null) 'daty': daty,
      if (clt != null) 'clt': clt,
      if (emb != null) 'emb': emb,
      if (q != null) 'q': q,
      if (verification != null) 'verification': verification,
    });
  }

  EmblcltCompanion copyWith(
      {Value<int>? num,
      Value<String?>? numventes,
      Value<String?>? nfact,
      Value<DateTime?>? daty,
      Value<String?>? clt,
      Value<String?>? emb,
      Value<double?>? q,
      Value<String?>? verification}) {
    return EmblcltCompanion(
      num: num ?? this.num,
      numventes: numventes ?? this.numventes,
      nfact: nfact ?? this.nfact,
      daty: daty ?? this.daty,
      clt: clt ?? this.clt,
      emb: emb ?? this.emb,
      q: q ?? this.q,
      verification: verification ?? this.verification,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (num.present) {
      map['num'] = Variable<int>(num.value);
    }
    if (numventes.present) {
      map['numventes'] = Variable<String>(numventes.value);
    }
    if (nfact.present) {
      map['nfact'] = Variable<String>(nfact.value);
    }
    if (daty.present) {
      map['daty'] = Variable<DateTime>(daty.value);
    }
    if (clt.present) {
      map['clt'] = Variable<String>(clt.value);
    }
    if (emb.present) {
      map['emb'] = Variable<String>(emb.value);
    }
    if (q.present) {
      map['q'] = Variable<double>(q.value);
    }
    if (verification.present) {
      map['verification'] = Variable<String>(verification.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('EmblcltCompanion(')
          ..write('num: $num, ')
          ..write('numventes: $numventes, ')
          ..write('nfact: $nfact, ')
          ..write('daty: $daty, ')
          ..write('clt: $clt, ')
          ..write('emb: $emb, ')
          ..write('q: $q, ')
          ..write('verification: $verification')
          ..write(')'))
        .toString();
  }
}

class $FstocksTable extends Fstocks with TableInfo<$FstocksTable, Fstock> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FstocksTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _refMeta = const VerificationMeta('ref');
  @override
  late final GeneratedColumn<String> ref = GeneratedColumn<String>(
      'ref', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _artMeta = const VerificationMeta('art');
  @override
  late final GeneratedColumn<String> art = GeneratedColumn<String>(
      'art', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _qeMeta = const VerificationMeta('qe');
  @override
  late final GeneratedColumn<double> qe = GeneratedColumn<double>(
      'qe', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _qsMeta = const VerificationMeta('qs');
  @override
  late final GeneratedColumn<double> qs = GeneratedColumn<double>(
      'qs', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _qstMeta = const VerificationMeta('qst');
  @override
  late final GeneratedColumn<double> qst = GeneratedColumn<double>(
      'qst', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _ueMeta = const VerificationMeta('ue');
  @override
  late final GeneratedColumn<String> ue = GeneratedColumn<String>(
      'ue', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [ref, art, qe, qs, qst, ue];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'fstocks';
  @override
  VerificationContext validateIntegrity(Insertable<Fstock> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('ref')) {
      context.handle(
          _refMeta, ref.isAcceptableOrUnknown(data['ref']!, _refMeta));
    } else if (isInserting) {
      context.missing(_refMeta);
    }
    if (data.containsKey('art')) {
      context.handle(
          _artMeta, art.isAcceptableOrUnknown(data['art']!, _artMeta));
    }
    if (data.containsKey('qe')) {
      context.handle(_qeMeta, qe.isAcceptableOrUnknown(data['qe']!, _qeMeta));
    }
    if (data.containsKey('qs')) {
      context.handle(_qsMeta, qs.isAcceptableOrUnknown(data['qs']!, _qsMeta));
    }
    if (data.containsKey('qst')) {
      context.handle(
          _qstMeta, qst.isAcceptableOrUnknown(data['qst']!, _qstMeta));
    }
    if (data.containsKey('ue')) {
      context.handle(_ueMeta, ue.isAcceptableOrUnknown(data['ue']!, _ueMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {ref};
  @override
  Fstock map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Fstock(
      ref: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}ref'])!,
      art: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}art']),
      qe: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}qe']),
      qs: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}qs']),
      qst: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}qst']),
      ue: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}ue']),
    );
  }

  @override
  $FstocksTable createAlias(String alias) {
    return $FstocksTable(attachedDatabase, alias);
  }
}

class Fstock extends DataClass implements Insertable<Fstock> {
  final String ref;
  final String? art;
  final double? qe;
  final double? qs;
  final double? qst;
  final String? ue;
  const Fstock(
      {required this.ref, this.art, this.qe, this.qs, this.qst, this.ue});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['ref'] = Variable<String>(ref);
    if (!nullToAbsent || art != null) {
      map['art'] = Variable<String>(art);
    }
    if (!nullToAbsent || qe != null) {
      map['qe'] = Variable<double>(qe);
    }
    if (!nullToAbsent || qs != null) {
      map['qs'] = Variable<double>(qs);
    }
    if (!nullToAbsent || qst != null) {
      map['qst'] = Variable<double>(qst);
    }
    if (!nullToAbsent || ue != null) {
      map['ue'] = Variable<String>(ue);
    }
    return map;
  }

  FstocksCompanion toCompanion(bool nullToAbsent) {
    return FstocksCompanion(
      ref: Value(ref),
      art: art == null && nullToAbsent ? const Value.absent() : Value(art),
      qe: qe == null && nullToAbsent ? const Value.absent() : Value(qe),
      qs: qs == null && nullToAbsent ? const Value.absent() : Value(qs),
      qst: qst == null && nullToAbsent ? const Value.absent() : Value(qst),
      ue: ue == null && nullToAbsent ? const Value.absent() : Value(ue),
    );
  }

  factory Fstock.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Fstock(
      ref: serializer.fromJson<String>(json['ref']),
      art: serializer.fromJson<String?>(json['art']),
      qe: serializer.fromJson<double?>(json['qe']),
      qs: serializer.fromJson<double?>(json['qs']),
      qst: serializer.fromJson<double?>(json['qst']),
      ue: serializer.fromJson<String?>(json['ue']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'ref': serializer.toJson<String>(ref),
      'art': serializer.toJson<String?>(art),
      'qe': serializer.toJson<double?>(qe),
      'qs': serializer.toJson<double?>(qs),
      'qst': serializer.toJson<double?>(qst),
      'ue': serializer.toJson<String?>(ue),
    };
  }

  Fstock copyWith(
          {String? ref,
          Value<String?> art = const Value.absent(),
          Value<double?> qe = const Value.absent(),
          Value<double?> qs = const Value.absent(),
          Value<double?> qst = const Value.absent(),
          Value<String?> ue = const Value.absent()}) =>
      Fstock(
        ref: ref ?? this.ref,
        art: art.present ? art.value : this.art,
        qe: qe.present ? qe.value : this.qe,
        qs: qs.present ? qs.value : this.qs,
        qst: qst.present ? qst.value : this.qst,
        ue: ue.present ? ue.value : this.ue,
      );
  Fstock copyWithCompanion(FstocksCompanion data) {
    return Fstock(
      ref: data.ref.present ? data.ref.value : this.ref,
      art: data.art.present ? data.art.value : this.art,
      qe: data.qe.present ? data.qe.value : this.qe,
      qs: data.qs.present ? data.qs.value : this.qs,
      qst: data.qst.present ? data.qst.value : this.qst,
      ue: data.ue.present ? data.ue.value : this.ue,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Fstock(')
          ..write('ref: $ref, ')
          ..write('art: $art, ')
          ..write('qe: $qe, ')
          ..write('qs: $qs, ')
          ..write('qst: $qst, ')
          ..write('ue: $ue')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(ref, art, qe, qs, qst, ue);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Fstock &&
          other.ref == this.ref &&
          other.art == this.art &&
          other.qe == this.qe &&
          other.qs == this.qs &&
          other.qst == this.qst &&
          other.ue == this.ue);
}

class FstocksCompanion extends UpdateCompanion<Fstock> {
  final Value<String> ref;
  final Value<String?> art;
  final Value<double?> qe;
  final Value<double?> qs;
  final Value<double?> qst;
  final Value<String?> ue;
  final Value<int> rowid;
  const FstocksCompanion({
    this.ref = const Value.absent(),
    this.art = const Value.absent(),
    this.qe = const Value.absent(),
    this.qs = const Value.absent(),
    this.qst = const Value.absent(),
    this.ue = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  FstocksCompanion.insert({
    required String ref,
    this.art = const Value.absent(),
    this.qe = const Value.absent(),
    this.qs = const Value.absent(),
    this.qst = const Value.absent(),
    this.ue = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : ref = Value(ref);
  static Insertable<Fstock> custom({
    Expression<String>? ref,
    Expression<String>? art,
    Expression<double>? qe,
    Expression<double>? qs,
    Expression<double>? qst,
    Expression<String>? ue,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (ref != null) 'ref': ref,
      if (art != null) 'art': art,
      if (qe != null) 'qe': qe,
      if (qs != null) 'qs': qs,
      if (qst != null) 'qst': qst,
      if (ue != null) 'ue': ue,
      if (rowid != null) 'rowid': rowid,
    });
  }

  FstocksCompanion copyWith(
      {Value<String>? ref,
      Value<String?>? art,
      Value<double?>? qe,
      Value<double?>? qs,
      Value<double?>? qst,
      Value<String?>? ue,
      Value<int>? rowid}) {
    return FstocksCompanion(
      ref: ref ?? this.ref,
      art: art ?? this.art,
      qe: qe ?? this.qe,
      qs: qs ?? this.qs,
      qst: qst ?? this.qst,
      ue: ue ?? this.ue,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (ref.present) {
      map['ref'] = Variable<String>(ref.value);
    }
    if (art.present) {
      map['art'] = Variable<String>(art.value);
    }
    if (qe.present) {
      map['qe'] = Variable<double>(qe.value);
    }
    if (qs.present) {
      map['qs'] = Variable<double>(qs.value);
    }
    if (qst.present) {
      map['qst'] = Variable<double>(qst.value);
    }
    if (ue.present) {
      map['ue'] = Variable<String>(ue.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FstocksCompanion(')
          ..write('ref: $ref, ')
          ..write('art: $art, ')
          ..write('qe: $qe, ')
          ..write('qs: $qs, ')
          ..write('qst: $qst, ')
          ..write('ue: $ue, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $MpTable extends Mp with TableInfo<$MpTable, MpData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $MpTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _mpMeta = const VerificationMeta('mp');
  @override
  late final GeneratedColumn<String> mp = GeneratedColumn<String>(
      'mp', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [mp];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'mp';
  @override
  VerificationContext validateIntegrity(Insertable<MpData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('mp')) {
      context.handle(_mpMeta, mp.isAcceptableOrUnknown(data['mp']!, _mpMeta));
    } else if (isInserting) {
      context.missing(_mpMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {mp};
  @override
  MpData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return MpData(
      mp: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}mp'])!,
    );
  }

  @override
  $MpTable createAlias(String alias) {
    return $MpTable(attachedDatabase, alias);
  }
}

class MpData extends DataClass implements Insertable<MpData> {
  final String mp;
  const MpData({required this.mp});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['mp'] = Variable<String>(mp);
    return map;
  }

  MpCompanion toCompanion(bool nullToAbsent) {
    return MpCompanion(
      mp: Value(mp),
    );
  }

  factory MpData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return MpData(
      mp: serializer.fromJson<String>(json['mp']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'mp': serializer.toJson<String>(mp),
    };
  }

  MpData copyWith({String? mp}) => MpData(
        mp: mp ?? this.mp,
      );
  MpData copyWithCompanion(MpCompanion data) {
    return MpData(
      mp: data.mp.present ? data.mp.value : this.mp,
    );
  }

  @override
  String toString() {
    return (StringBuffer('MpData(')
          ..write('mp: $mp')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => mp.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) || (other is MpData && other.mp == this.mp);
}

class MpCompanion extends UpdateCompanion<MpData> {
  final Value<String> mp;
  final Value<int> rowid;
  const MpCompanion({
    this.mp = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  MpCompanion.insert({
    required String mp,
    this.rowid = const Value.absent(),
  }) : mp = Value(mp);
  static Insertable<MpData> custom({
    Expression<String>? mp,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (mp != null) 'mp': mp,
      if (rowid != null) 'rowid': rowid,
    });
  }

  MpCompanion copyWith({Value<String>? mp, Value<int>? rowid}) {
    return MpCompanion(
      mp: mp ?? this.mp,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (mp.present) {
      map['mp'] = Variable<String>(mp.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('MpCompanion(')
          ..write('mp: $mp, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ProdTable extends Prod with TableInfo<$ProdTable, ProdData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProdTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _numMeta = const VerificationMeta('num');
  @override
  late final GeneratedColumn<int> num = GeneratedColumn<int>(
      'num', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _numaprodMeta =
      const VerificationMeta('numaprod');
  @override
  late final GeneratedColumn<String> numaprod = GeneratedColumn<String>(
      'numaprod', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _obsMeta = const VerificationMeta('obs');
  @override
  late final GeneratedColumn<String> obs = GeneratedColumn<String>(
      'obs', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _socDatyMeta =
      const VerificationMeta('socDaty');
  @override
  late final GeneratedColumn<DateTime> socDaty = GeneratedColumn<DateTime>(
      'soc_daty', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _produitsMeta =
      const VerificationMeta('produits');
  @override
  late final GeneratedColumn<String> produits = GeneratedColumn<String>(
      'produits', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _depotMeta = const VerificationMeta('depot');
  @override
  late final GeneratedColumn<String> depot = GeneratedColumn<String>(
      'depot', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _cteMeta = const VerificationMeta('cte');
  @override
  late final GeneratedColumn<String> cte = GeneratedColumn<String>(
      'cte', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _totalttcMeta =
      const VerificationMeta('totalttc');
  @override
  late final GeneratedColumn<double> totalttc = GeneratedColumn<double>(
      'totalttc', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _cmupMeta = const VerificationMeta('cmup');
  @override
  late final GeneratedColumn<double> cmup = GeneratedColumn<double>(
      'cmup', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _verificationMeta =
      const VerificationMeta('verification');
  @override
  late final GeneratedColumn<String> verification = GeneratedColumn<String>(
      'verification', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
      'type', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _uniteMeta = const VerificationMeta('unite');
  @override
  late final GeneratedColumn<String> unite = GeneratedColumn<String>(
      'unite', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _contreMeta = const VerificationMeta('contre');
  @override
  late final GeneratedColumn<String> contre = GeneratedColumn<String>(
      'contre', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        num,
        numaprod,
        obs,
        socDaty,
        produits,
        depot,
        cte,
        totalttc,
        cmup,
        verification,
        type,
        unite,
        contre
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'prod';
  @override
  VerificationContext validateIntegrity(Insertable<ProdData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('num')) {
      context.handle(
          _numMeta, num.isAcceptableOrUnknown(data['num']!, _numMeta));
    }
    if (data.containsKey('numaprod')) {
      context.handle(_numaprodMeta,
          numaprod.isAcceptableOrUnknown(data['numaprod']!, _numaprodMeta));
    }
    if (data.containsKey('obs')) {
      context.handle(
          _obsMeta, obs.isAcceptableOrUnknown(data['obs']!, _obsMeta));
    }
    if (data.containsKey('soc_daty')) {
      context.handle(_socDatyMeta,
          socDaty.isAcceptableOrUnknown(data['soc_daty']!, _socDatyMeta));
    }
    if (data.containsKey('produits')) {
      context.handle(_produitsMeta,
          produits.isAcceptableOrUnknown(data['produits']!, _produitsMeta));
    }
    if (data.containsKey('depot')) {
      context.handle(
          _depotMeta, depot.isAcceptableOrUnknown(data['depot']!, _depotMeta));
    }
    if (data.containsKey('cte')) {
      context.handle(
          _cteMeta, cte.isAcceptableOrUnknown(data['cte']!, _cteMeta));
    }
    if (data.containsKey('totalttc')) {
      context.handle(_totalttcMeta,
          totalttc.isAcceptableOrUnknown(data['totalttc']!, _totalttcMeta));
    }
    if (data.containsKey('cmup')) {
      context.handle(
          _cmupMeta, cmup.isAcceptableOrUnknown(data['cmup']!, _cmupMeta));
    }
    if (data.containsKey('verification')) {
      context.handle(
          _verificationMeta,
          verification.isAcceptableOrUnknown(
              data['verification']!, _verificationMeta));
    }
    if (data.containsKey('type')) {
      context.handle(
          _typeMeta, type.isAcceptableOrUnknown(data['type']!, _typeMeta));
    }
    if (data.containsKey('unite')) {
      context.handle(
          _uniteMeta, unite.isAcceptableOrUnknown(data['unite']!, _uniteMeta));
    }
    if (data.containsKey('contre')) {
      context.handle(_contreMeta,
          contre.isAcceptableOrUnknown(data['contre']!, _contreMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {num};
  @override
  ProdData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ProdData(
      num: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}num'])!,
      numaprod: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}numaprod']),
      obs: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}obs']),
      socDaty: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}soc_daty']),
      produits: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}produits']),
      depot: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}depot']),
      cte: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}cte']),
      totalttc: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}totalttc']),
      cmup: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}cmup']),
      verification: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}verification']),
      type: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type']),
      unite: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}unite']),
      contre: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}contre']),
    );
  }

  @override
  $ProdTable createAlias(String alias) {
    return $ProdTable(attachedDatabase, alias);
  }
}

class ProdData extends DataClass implements Insertable<ProdData> {
  final int num;
  final String? numaprod;
  final String? obs;
  final DateTime? socDaty;
  final String? produits;
  final String? depot;
  final String? cte;
  final double? totalttc;
  final double? cmup;
  final String? verification;
  final String? type;
  final String? unite;
  final String? contre;
  const ProdData(
      {required this.num,
      this.numaprod,
      this.obs,
      this.socDaty,
      this.produits,
      this.depot,
      this.cte,
      this.totalttc,
      this.cmup,
      this.verification,
      this.type,
      this.unite,
      this.contre});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['num'] = Variable<int>(num);
    if (!nullToAbsent || numaprod != null) {
      map['numaprod'] = Variable<String>(numaprod);
    }
    if (!nullToAbsent || obs != null) {
      map['obs'] = Variable<String>(obs);
    }
    if (!nullToAbsent || socDaty != null) {
      map['soc_daty'] = Variable<DateTime>(socDaty);
    }
    if (!nullToAbsent || produits != null) {
      map['produits'] = Variable<String>(produits);
    }
    if (!nullToAbsent || depot != null) {
      map['depot'] = Variable<String>(depot);
    }
    if (!nullToAbsent || cte != null) {
      map['cte'] = Variable<String>(cte);
    }
    if (!nullToAbsent || totalttc != null) {
      map['totalttc'] = Variable<double>(totalttc);
    }
    if (!nullToAbsent || cmup != null) {
      map['cmup'] = Variable<double>(cmup);
    }
    if (!nullToAbsent || verification != null) {
      map['verification'] = Variable<String>(verification);
    }
    if (!nullToAbsent || type != null) {
      map['type'] = Variable<String>(type);
    }
    if (!nullToAbsent || unite != null) {
      map['unite'] = Variable<String>(unite);
    }
    if (!nullToAbsent || contre != null) {
      map['contre'] = Variable<String>(contre);
    }
    return map;
  }

  ProdCompanion toCompanion(bool nullToAbsent) {
    return ProdCompanion(
      num: Value(num),
      numaprod: numaprod == null && nullToAbsent
          ? const Value.absent()
          : Value(numaprod),
      obs: obs == null && nullToAbsent ? const Value.absent() : Value(obs),
      socDaty: socDaty == null && nullToAbsent
          ? const Value.absent()
          : Value(socDaty),
      produits: produits == null && nullToAbsent
          ? const Value.absent()
          : Value(produits),
      depot:
          depot == null && nullToAbsent ? const Value.absent() : Value(depot),
      cte: cte == null && nullToAbsent ? const Value.absent() : Value(cte),
      totalttc: totalttc == null && nullToAbsent
          ? const Value.absent()
          : Value(totalttc),
      cmup: cmup == null && nullToAbsent ? const Value.absent() : Value(cmup),
      verification: verification == null && nullToAbsent
          ? const Value.absent()
          : Value(verification),
      type: type == null && nullToAbsent ? const Value.absent() : Value(type),
      unite:
          unite == null && nullToAbsent ? const Value.absent() : Value(unite),
      contre:
          contre == null && nullToAbsent ? const Value.absent() : Value(contre),
    );
  }

  factory ProdData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ProdData(
      num: serializer.fromJson<int>(json['num']),
      numaprod: serializer.fromJson<String?>(json['numaprod']),
      obs: serializer.fromJson<String?>(json['obs']),
      socDaty: serializer.fromJson<DateTime?>(json['socDaty']),
      produits: serializer.fromJson<String?>(json['produits']),
      depot: serializer.fromJson<String?>(json['depot']),
      cte: serializer.fromJson<String?>(json['cte']),
      totalttc: serializer.fromJson<double?>(json['totalttc']),
      cmup: serializer.fromJson<double?>(json['cmup']),
      verification: serializer.fromJson<String?>(json['verification']),
      type: serializer.fromJson<String?>(json['type']),
      unite: serializer.fromJson<String?>(json['unite']),
      contre: serializer.fromJson<String?>(json['contre']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'num': serializer.toJson<int>(num),
      'numaprod': serializer.toJson<String?>(numaprod),
      'obs': serializer.toJson<String?>(obs),
      'socDaty': serializer.toJson<DateTime?>(socDaty),
      'produits': serializer.toJson<String?>(produits),
      'depot': serializer.toJson<String?>(depot),
      'cte': serializer.toJson<String?>(cte),
      'totalttc': serializer.toJson<double?>(totalttc),
      'cmup': serializer.toJson<double?>(cmup),
      'verification': serializer.toJson<String?>(verification),
      'type': serializer.toJson<String?>(type),
      'unite': serializer.toJson<String?>(unite),
      'contre': serializer.toJson<String?>(contre),
    };
  }

  ProdData copyWith(
          {int? num,
          Value<String?> numaprod = const Value.absent(),
          Value<String?> obs = const Value.absent(),
          Value<DateTime?> socDaty = const Value.absent(),
          Value<String?> produits = const Value.absent(),
          Value<String?> depot = const Value.absent(),
          Value<String?> cte = const Value.absent(),
          Value<double?> totalttc = const Value.absent(),
          Value<double?> cmup = const Value.absent(),
          Value<String?> verification = const Value.absent(),
          Value<String?> type = const Value.absent(),
          Value<String?> unite = const Value.absent(),
          Value<String?> contre = const Value.absent()}) =>
      ProdData(
        num: num ?? this.num,
        numaprod: numaprod.present ? numaprod.value : this.numaprod,
        obs: obs.present ? obs.value : this.obs,
        socDaty: socDaty.present ? socDaty.value : this.socDaty,
        produits: produits.present ? produits.value : this.produits,
        depot: depot.present ? depot.value : this.depot,
        cte: cte.present ? cte.value : this.cte,
        totalttc: totalttc.present ? totalttc.value : this.totalttc,
        cmup: cmup.present ? cmup.value : this.cmup,
        verification:
            verification.present ? verification.value : this.verification,
        type: type.present ? type.value : this.type,
        unite: unite.present ? unite.value : this.unite,
        contre: contre.present ? contre.value : this.contre,
      );
  ProdData copyWithCompanion(ProdCompanion data) {
    return ProdData(
      num: data.num.present ? data.num.value : this.num,
      numaprod: data.numaprod.present ? data.numaprod.value : this.numaprod,
      obs: data.obs.present ? data.obs.value : this.obs,
      socDaty: data.socDaty.present ? data.socDaty.value : this.socDaty,
      produits: data.produits.present ? data.produits.value : this.produits,
      depot: data.depot.present ? data.depot.value : this.depot,
      cte: data.cte.present ? data.cte.value : this.cte,
      totalttc: data.totalttc.present ? data.totalttc.value : this.totalttc,
      cmup: data.cmup.present ? data.cmup.value : this.cmup,
      verification: data.verification.present
          ? data.verification.value
          : this.verification,
      type: data.type.present ? data.type.value : this.type,
      unite: data.unite.present ? data.unite.value : this.unite,
      contre: data.contre.present ? data.contre.value : this.contre,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ProdData(')
          ..write('num: $num, ')
          ..write('numaprod: $numaprod, ')
          ..write('obs: $obs, ')
          ..write('socDaty: $socDaty, ')
          ..write('produits: $produits, ')
          ..write('depot: $depot, ')
          ..write('cte: $cte, ')
          ..write('totalttc: $totalttc, ')
          ..write('cmup: $cmup, ')
          ..write('verification: $verification, ')
          ..write('type: $type, ')
          ..write('unite: $unite, ')
          ..write('contre: $contre')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(num, numaprod, obs, socDaty, produits, depot,
      cte, totalttc, cmup, verification, type, unite, contre);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ProdData &&
          other.num == this.num &&
          other.numaprod == this.numaprod &&
          other.obs == this.obs &&
          other.socDaty == this.socDaty &&
          other.produits == this.produits &&
          other.depot == this.depot &&
          other.cte == this.cte &&
          other.totalttc == this.totalttc &&
          other.cmup == this.cmup &&
          other.verification == this.verification &&
          other.type == this.type &&
          other.unite == this.unite &&
          other.contre == this.contre);
}

class ProdCompanion extends UpdateCompanion<ProdData> {
  final Value<int> num;
  final Value<String?> numaprod;
  final Value<String?> obs;
  final Value<DateTime?> socDaty;
  final Value<String?> produits;
  final Value<String?> depot;
  final Value<String?> cte;
  final Value<double?> totalttc;
  final Value<double?> cmup;
  final Value<String?> verification;
  final Value<String?> type;
  final Value<String?> unite;
  final Value<String?> contre;
  const ProdCompanion({
    this.num = const Value.absent(),
    this.numaprod = const Value.absent(),
    this.obs = const Value.absent(),
    this.socDaty = const Value.absent(),
    this.produits = const Value.absent(),
    this.depot = const Value.absent(),
    this.cte = const Value.absent(),
    this.totalttc = const Value.absent(),
    this.cmup = const Value.absent(),
    this.verification = const Value.absent(),
    this.type = const Value.absent(),
    this.unite = const Value.absent(),
    this.contre = const Value.absent(),
  });
  ProdCompanion.insert({
    this.num = const Value.absent(),
    this.numaprod = const Value.absent(),
    this.obs = const Value.absent(),
    this.socDaty = const Value.absent(),
    this.produits = const Value.absent(),
    this.depot = const Value.absent(),
    this.cte = const Value.absent(),
    this.totalttc = const Value.absent(),
    this.cmup = const Value.absent(),
    this.verification = const Value.absent(),
    this.type = const Value.absent(),
    this.unite = const Value.absent(),
    this.contre = const Value.absent(),
  });
  static Insertable<ProdData> custom({
    Expression<int>? num,
    Expression<String>? numaprod,
    Expression<String>? obs,
    Expression<DateTime>? socDaty,
    Expression<String>? produits,
    Expression<String>? depot,
    Expression<String>? cte,
    Expression<double>? totalttc,
    Expression<double>? cmup,
    Expression<String>? verification,
    Expression<String>? type,
    Expression<String>? unite,
    Expression<String>? contre,
  }) {
    return RawValuesInsertable({
      if (num != null) 'num': num,
      if (numaprod != null) 'numaprod': numaprod,
      if (obs != null) 'obs': obs,
      if (socDaty != null) 'soc_daty': socDaty,
      if (produits != null) 'produits': produits,
      if (depot != null) 'depot': depot,
      if (cte != null) 'cte': cte,
      if (totalttc != null) 'totalttc': totalttc,
      if (cmup != null) 'cmup': cmup,
      if (verification != null) 'verification': verification,
      if (type != null) 'type': type,
      if (unite != null) 'unite': unite,
      if (contre != null) 'contre': contre,
    });
  }

  ProdCompanion copyWith(
      {Value<int>? num,
      Value<String?>? numaprod,
      Value<String?>? obs,
      Value<DateTime?>? socDaty,
      Value<String?>? produits,
      Value<String?>? depot,
      Value<String?>? cte,
      Value<double?>? totalttc,
      Value<double?>? cmup,
      Value<String?>? verification,
      Value<String?>? type,
      Value<String?>? unite,
      Value<String?>? contre}) {
    return ProdCompanion(
      num: num ?? this.num,
      numaprod: numaprod ?? this.numaprod,
      obs: obs ?? this.obs,
      socDaty: socDaty ?? this.socDaty,
      produits: produits ?? this.produits,
      depot: depot ?? this.depot,
      cte: cte ?? this.cte,
      totalttc: totalttc ?? this.totalttc,
      cmup: cmup ?? this.cmup,
      verification: verification ?? this.verification,
      type: type ?? this.type,
      unite: unite ?? this.unite,
      contre: contre ?? this.contre,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (num.present) {
      map['num'] = Variable<int>(num.value);
    }
    if (numaprod.present) {
      map['numaprod'] = Variable<String>(numaprod.value);
    }
    if (obs.present) {
      map['obs'] = Variable<String>(obs.value);
    }
    if (socDaty.present) {
      map['soc_daty'] = Variable<DateTime>(socDaty.value);
    }
    if (produits.present) {
      map['produits'] = Variable<String>(produits.value);
    }
    if (depot.present) {
      map['depot'] = Variable<String>(depot.value);
    }
    if (cte.present) {
      map['cte'] = Variable<String>(cte.value);
    }
    if (totalttc.present) {
      map['totalttc'] = Variable<double>(totalttc.value);
    }
    if (cmup.present) {
      map['cmup'] = Variable<double>(cmup.value);
    }
    if (verification.present) {
      map['verification'] = Variable<String>(verification.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (unite.present) {
      map['unite'] = Variable<String>(unite.value);
    }
    if (contre.present) {
      map['contre'] = Variable<String>(contre.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProdCompanion(')
          ..write('num: $num, ')
          ..write('numaprod: $numaprod, ')
          ..write('obs: $obs, ')
          ..write('socDaty: $socDaty, ')
          ..write('produits: $produits, ')
          ..write('depot: $depot, ')
          ..write('cte: $cte, ')
          ..write('totalttc: $totalttc, ')
          ..write('cmup: $cmup, ')
          ..write('verification: $verification, ')
          ..write('type: $type, ')
          ..write('unite: $unite, ')
          ..write('contre: $contre')
          ..write(')'))
        .toString();
  }
}

class $PvTable extends Pv with TableInfo<$PvTable, PvData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PvTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _designationMeta =
      const VerificationMeta('designation');
  @override
  late final GeneratedColumn<String> designation = GeneratedColumn<String>(
      'designation', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _categorieMeta =
      const VerificationMeta('categorie');
  @override
  late final GeneratedColumn<String> categorie = GeneratedColumn<String>(
      'categorie', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _pvu1Meta = const VerificationMeta('pvu1');
  @override
  late final GeneratedColumn<double> pvu1 = GeneratedColumn<double>(
      'pvu1', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _pvu2Meta = const VerificationMeta('pvu2');
  @override
  late final GeneratedColumn<double> pvu2 = GeneratedColumn<double>(
      'pvu2', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _pvu3Meta = const VerificationMeta('pvu3');
  @override
  late final GeneratedColumn<double> pvu3 = GeneratedColumn<double>(
      'pvu3', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns =>
      [designation, categorie, pvu1, pvu2, pvu3];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'pv';
  @override
  VerificationContext validateIntegrity(Insertable<PvData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('designation')) {
      context.handle(
          _designationMeta,
          designation.isAcceptableOrUnknown(
              data['designation']!, _designationMeta));
    } else if (isInserting) {
      context.missing(_designationMeta);
    }
    if (data.containsKey('categorie')) {
      context.handle(_categorieMeta,
          categorie.isAcceptableOrUnknown(data['categorie']!, _categorieMeta));
    }
    if (data.containsKey('pvu1')) {
      context.handle(
          _pvu1Meta, pvu1.isAcceptableOrUnknown(data['pvu1']!, _pvu1Meta));
    }
    if (data.containsKey('pvu2')) {
      context.handle(
          _pvu2Meta, pvu2.isAcceptableOrUnknown(data['pvu2']!, _pvu2Meta));
    }
    if (data.containsKey('pvu3')) {
      context.handle(
          _pvu3Meta, pvu3.isAcceptableOrUnknown(data['pvu3']!, _pvu3Meta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {designation};
  @override
  PvData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PvData(
      designation: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}designation'])!,
      categorie: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}categorie']),
      pvu1: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}pvu1']),
      pvu2: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}pvu2']),
      pvu3: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}pvu3']),
    );
  }

  @override
  $PvTable createAlias(String alias) {
    return $PvTable(attachedDatabase, alias);
  }
}

class PvData extends DataClass implements Insertable<PvData> {
  final String designation;
  final String? categorie;
  final double? pvu1;
  final double? pvu2;
  final double? pvu3;
  const PvData(
      {required this.designation,
      this.categorie,
      this.pvu1,
      this.pvu2,
      this.pvu3});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['designation'] = Variable<String>(designation);
    if (!nullToAbsent || categorie != null) {
      map['categorie'] = Variable<String>(categorie);
    }
    if (!nullToAbsent || pvu1 != null) {
      map['pvu1'] = Variable<double>(pvu1);
    }
    if (!nullToAbsent || pvu2 != null) {
      map['pvu2'] = Variable<double>(pvu2);
    }
    if (!nullToAbsent || pvu3 != null) {
      map['pvu3'] = Variable<double>(pvu3);
    }
    return map;
  }

  PvCompanion toCompanion(bool nullToAbsent) {
    return PvCompanion(
      designation: Value(designation),
      categorie: categorie == null && nullToAbsent
          ? const Value.absent()
          : Value(categorie),
      pvu1: pvu1 == null && nullToAbsent ? const Value.absent() : Value(pvu1),
      pvu2: pvu2 == null && nullToAbsent ? const Value.absent() : Value(pvu2),
      pvu3: pvu3 == null && nullToAbsent ? const Value.absent() : Value(pvu3),
    );
  }

  factory PvData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PvData(
      designation: serializer.fromJson<String>(json['designation']),
      categorie: serializer.fromJson<String?>(json['categorie']),
      pvu1: serializer.fromJson<double?>(json['pvu1']),
      pvu2: serializer.fromJson<double?>(json['pvu2']),
      pvu3: serializer.fromJson<double?>(json['pvu3']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'designation': serializer.toJson<String>(designation),
      'categorie': serializer.toJson<String?>(categorie),
      'pvu1': serializer.toJson<double?>(pvu1),
      'pvu2': serializer.toJson<double?>(pvu2),
      'pvu3': serializer.toJson<double?>(pvu3),
    };
  }

  PvData copyWith(
          {String? designation,
          Value<String?> categorie = const Value.absent(),
          Value<double?> pvu1 = const Value.absent(),
          Value<double?> pvu2 = const Value.absent(),
          Value<double?> pvu3 = const Value.absent()}) =>
      PvData(
        designation: designation ?? this.designation,
        categorie: categorie.present ? categorie.value : this.categorie,
        pvu1: pvu1.present ? pvu1.value : this.pvu1,
        pvu2: pvu2.present ? pvu2.value : this.pvu2,
        pvu3: pvu3.present ? pvu3.value : this.pvu3,
      );
  PvData copyWithCompanion(PvCompanion data) {
    return PvData(
      designation:
          data.designation.present ? data.designation.value : this.designation,
      categorie: data.categorie.present ? data.categorie.value : this.categorie,
      pvu1: data.pvu1.present ? data.pvu1.value : this.pvu1,
      pvu2: data.pvu2.present ? data.pvu2.value : this.pvu2,
      pvu3: data.pvu3.present ? data.pvu3.value : this.pvu3,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PvData(')
          ..write('designation: $designation, ')
          ..write('categorie: $categorie, ')
          ..write('pvu1: $pvu1, ')
          ..write('pvu2: $pvu2, ')
          ..write('pvu3: $pvu3')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(designation, categorie, pvu1, pvu2, pvu3);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PvData &&
          other.designation == this.designation &&
          other.categorie == this.categorie &&
          other.pvu1 == this.pvu1 &&
          other.pvu2 == this.pvu2 &&
          other.pvu3 == this.pvu3);
}

class PvCompanion extends UpdateCompanion<PvData> {
  final Value<String> designation;
  final Value<String?> categorie;
  final Value<double?> pvu1;
  final Value<double?> pvu2;
  final Value<double?> pvu3;
  final Value<int> rowid;
  const PvCompanion({
    this.designation = const Value.absent(),
    this.categorie = const Value.absent(),
    this.pvu1 = const Value.absent(),
    this.pvu2 = const Value.absent(),
    this.pvu3 = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  PvCompanion.insert({
    required String designation,
    this.categorie = const Value.absent(),
    this.pvu1 = const Value.absent(),
    this.pvu2 = const Value.absent(),
    this.pvu3 = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : designation = Value(designation);
  static Insertable<PvData> custom({
    Expression<String>? designation,
    Expression<String>? categorie,
    Expression<double>? pvu1,
    Expression<double>? pvu2,
    Expression<double>? pvu3,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (designation != null) 'designation': designation,
      if (categorie != null) 'categorie': categorie,
      if (pvu1 != null) 'pvu1': pvu1,
      if (pvu2 != null) 'pvu2': pvu2,
      if (pvu3 != null) 'pvu3': pvu3,
      if (rowid != null) 'rowid': rowid,
    });
  }

  PvCompanion copyWith(
      {Value<String>? designation,
      Value<String?>? categorie,
      Value<double?>? pvu1,
      Value<double?>? pvu2,
      Value<double?>? pvu3,
      Value<int>? rowid}) {
    return PvCompanion(
      designation: designation ?? this.designation,
      categorie: categorie ?? this.categorie,
      pvu1: pvu1 ?? this.pvu1,
      pvu2: pvu2 ?? this.pvu2,
      pvu3: pvu3 ?? this.pvu3,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (designation.present) {
      map['designation'] = Variable<String>(designation.value);
    }
    if (categorie.present) {
      map['categorie'] = Variable<String>(categorie.value);
    }
    if (pvu1.present) {
      map['pvu1'] = Variable<double>(pvu1.value);
    }
    if (pvu2.present) {
      map['pvu2'] = Variable<double>(pvu2.value);
    }
    if (pvu3.present) {
      map['pvu3'] = Variable<double>(pvu3.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PvCompanion(')
          ..write('designation: $designation, ')
          ..write('categorie: $categorie, ')
          ..write('pvu1: $pvu1, ')
          ..write('pvu2: $pvu2, ')
          ..write('pvu3: $pvu3, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $RetachatsTable extends Retachats
    with TableInfo<$RetachatsTable, Retachat> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $RetachatsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _numMeta = const VerificationMeta('num');
  @override
  late final GeneratedColumn<int> num = GeneratedColumn<int>(
      'num', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _numachatsMeta =
      const VerificationMeta('numachats');
  @override
  late final GeneratedColumn<String> numachats = GeneratedColumn<String>(
      'numachats', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _nfactMeta = const VerificationMeta('nfact');
  @override
  late final GeneratedColumn<String> nfact = GeneratedColumn<String>(
      'nfact', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _datyMeta = const VerificationMeta('daty');
  @override
  late final GeneratedColumn<DateTime> daty = GeneratedColumn<DateTime>(
      'daty', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _frnsMeta = const VerificationMeta('frns');
  @override
  late final GeneratedColumn<String> frns = GeneratedColumn<String>(
      'frns', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _modepaiMeta =
      const VerificationMeta('modepai');
  @override
  late final GeneratedColumn<String> modepai = GeneratedColumn<String>(
      'modepai', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _echeanceMeta =
      const VerificationMeta('echeance');
  @override
  late final GeneratedColumn<DateTime> echeance = GeneratedColumn<DateTime>(
      'echeance', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _totalntMeta =
      const VerificationMeta('totalnt');
  @override
  late final GeneratedColumn<double> totalnt = GeneratedColumn<double>(
      'totalnt', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _totalttcMeta =
      const VerificationMeta('totalttc');
  @override
  late final GeneratedColumn<double> totalttc = GeneratedColumn<double>(
      'totalttc', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _tvaMeta = const VerificationMeta('tva');
  @override
  late final GeneratedColumn<double> tva = GeneratedColumn<double>(
      'tva', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _contreMeta = const VerificationMeta('contre');
  @override
  late final GeneratedColumn<String> contre = GeneratedColumn<String>(
      'contre', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _bqMeta = const VerificationMeta('bq');
  @override
  late final GeneratedColumn<String> bq = GeneratedColumn<String>(
      'bq', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _verificationMeta =
      const VerificationMeta('verification');
  @override
  late final GeneratedColumn<String> verification = GeneratedColumn<String>(
      'verification', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
      'type', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _numachats1Meta =
      const VerificationMeta('numachats1');
  @override
  late final GeneratedColumn<String> numachats1 = GeneratedColumn<String>(
      'numachats1', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        num,
        numachats,
        nfact,
        daty,
        frns,
        modepai,
        echeance,
        totalnt,
        totalttc,
        tva,
        contre,
        bq,
        verification,
        type,
        numachats1
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'retachats';
  @override
  VerificationContext validateIntegrity(Insertable<Retachat> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('num')) {
      context.handle(
          _numMeta, num.isAcceptableOrUnknown(data['num']!, _numMeta));
    }
    if (data.containsKey('numachats')) {
      context.handle(_numachatsMeta,
          numachats.isAcceptableOrUnknown(data['numachats']!, _numachatsMeta));
    }
    if (data.containsKey('nfact')) {
      context.handle(
          _nfactMeta, nfact.isAcceptableOrUnknown(data['nfact']!, _nfactMeta));
    }
    if (data.containsKey('daty')) {
      context.handle(
          _datyMeta, daty.isAcceptableOrUnknown(data['daty']!, _datyMeta));
    }
    if (data.containsKey('frns')) {
      context.handle(
          _frnsMeta, frns.isAcceptableOrUnknown(data['frns']!, _frnsMeta));
    }
    if (data.containsKey('modepai')) {
      context.handle(_modepaiMeta,
          modepai.isAcceptableOrUnknown(data['modepai']!, _modepaiMeta));
    }
    if (data.containsKey('echeance')) {
      context.handle(_echeanceMeta,
          echeance.isAcceptableOrUnknown(data['echeance']!, _echeanceMeta));
    }
    if (data.containsKey('totalnt')) {
      context.handle(_totalntMeta,
          totalnt.isAcceptableOrUnknown(data['totalnt']!, _totalntMeta));
    }
    if (data.containsKey('totalttc')) {
      context.handle(_totalttcMeta,
          totalttc.isAcceptableOrUnknown(data['totalttc']!, _totalttcMeta));
    }
    if (data.containsKey('tva')) {
      context.handle(
          _tvaMeta, tva.isAcceptableOrUnknown(data['tva']!, _tvaMeta));
    }
    if (data.containsKey('contre')) {
      context.handle(_contreMeta,
          contre.isAcceptableOrUnknown(data['contre']!, _contreMeta));
    }
    if (data.containsKey('bq')) {
      context.handle(_bqMeta, bq.isAcceptableOrUnknown(data['bq']!, _bqMeta));
    }
    if (data.containsKey('verification')) {
      context.handle(
          _verificationMeta,
          verification.isAcceptableOrUnknown(
              data['verification']!, _verificationMeta));
    }
    if (data.containsKey('type')) {
      context.handle(
          _typeMeta, type.isAcceptableOrUnknown(data['type']!, _typeMeta));
    }
    if (data.containsKey('numachats1')) {
      context.handle(
          _numachats1Meta,
          numachats1.isAcceptableOrUnknown(
              data['numachats1']!, _numachats1Meta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {num};
  @override
  Retachat map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Retachat(
      num: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}num'])!,
      numachats: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}numachats']),
      nfact: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}nfact']),
      daty: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}daty']),
      frns: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}frns']),
      modepai: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}modepai']),
      echeance: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}echeance']),
      totalnt: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}totalnt']),
      totalttc: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}totalttc']),
      tva: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}tva']),
      contre: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}contre']),
      bq: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}bq']),
      verification: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}verification']),
      type: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type']),
      numachats1: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}numachats1']),
    );
  }

  @override
  $RetachatsTable createAlias(String alias) {
    return $RetachatsTable(attachedDatabase, alias);
  }
}

class Retachat extends DataClass implements Insertable<Retachat> {
  final int num;
  final String? numachats;
  final String? nfact;
  final DateTime? daty;
  final String? frns;
  final String? modepai;
  final DateTime? echeance;
  final double? totalnt;
  final double? totalttc;
  final double? tva;
  final String? contre;
  final String? bq;
  final String? verification;
  final String? type;
  final String? numachats1;
  const Retachat(
      {required this.num,
      this.numachats,
      this.nfact,
      this.daty,
      this.frns,
      this.modepai,
      this.echeance,
      this.totalnt,
      this.totalttc,
      this.tva,
      this.contre,
      this.bq,
      this.verification,
      this.type,
      this.numachats1});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['num'] = Variable<int>(num);
    if (!nullToAbsent || numachats != null) {
      map['numachats'] = Variable<String>(numachats);
    }
    if (!nullToAbsent || nfact != null) {
      map['nfact'] = Variable<String>(nfact);
    }
    if (!nullToAbsent || daty != null) {
      map['daty'] = Variable<DateTime>(daty);
    }
    if (!nullToAbsent || frns != null) {
      map['frns'] = Variable<String>(frns);
    }
    if (!nullToAbsent || modepai != null) {
      map['modepai'] = Variable<String>(modepai);
    }
    if (!nullToAbsent || echeance != null) {
      map['echeance'] = Variable<DateTime>(echeance);
    }
    if (!nullToAbsent || totalnt != null) {
      map['totalnt'] = Variable<double>(totalnt);
    }
    if (!nullToAbsent || totalttc != null) {
      map['totalttc'] = Variable<double>(totalttc);
    }
    if (!nullToAbsent || tva != null) {
      map['tva'] = Variable<double>(tva);
    }
    if (!nullToAbsent || contre != null) {
      map['contre'] = Variable<String>(contre);
    }
    if (!nullToAbsent || bq != null) {
      map['bq'] = Variable<String>(bq);
    }
    if (!nullToAbsent || verification != null) {
      map['verification'] = Variable<String>(verification);
    }
    if (!nullToAbsent || type != null) {
      map['type'] = Variable<String>(type);
    }
    if (!nullToAbsent || numachats1 != null) {
      map['numachats1'] = Variable<String>(numachats1);
    }
    return map;
  }

  RetachatsCompanion toCompanion(bool nullToAbsent) {
    return RetachatsCompanion(
      num: Value(num),
      numachats: numachats == null && nullToAbsent
          ? const Value.absent()
          : Value(numachats),
      nfact:
          nfact == null && nullToAbsent ? const Value.absent() : Value(nfact),
      daty: daty == null && nullToAbsent ? const Value.absent() : Value(daty),
      frns: frns == null && nullToAbsent ? const Value.absent() : Value(frns),
      modepai: modepai == null && nullToAbsent
          ? const Value.absent()
          : Value(modepai),
      echeance: echeance == null && nullToAbsent
          ? const Value.absent()
          : Value(echeance),
      totalnt: totalnt == null && nullToAbsent
          ? const Value.absent()
          : Value(totalnt),
      totalttc: totalttc == null && nullToAbsent
          ? const Value.absent()
          : Value(totalttc),
      tva: tva == null && nullToAbsent ? const Value.absent() : Value(tva),
      contre:
          contre == null && nullToAbsent ? const Value.absent() : Value(contre),
      bq: bq == null && nullToAbsent ? const Value.absent() : Value(bq),
      verification: verification == null && nullToAbsent
          ? const Value.absent()
          : Value(verification),
      type: type == null && nullToAbsent ? const Value.absent() : Value(type),
      numachats1: numachats1 == null && nullToAbsent
          ? const Value.absent()
          : Value(numachats1),
    );
  }

  factory Retachat.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Retachat(
      num: serializer.fromJson<int>(json['num']),
      numachats: serializer.fromJson<String?>(json['numachats']),
      nfact: serializer.fromJson<String?>(json['nfact']),
      daty: serializer.fromJson<DateTime?>(json['daty']),
      frns: serializer.fromJson<String?>(json['frns']),
      modepai: serializer.fromJson<String?>(json['modepai']),
      echeance: serializer.fromJson<DateTime?>(json['echeance']),
      totalnt: serializer.fromJson<double?>(json['totalnt']),
      totalttc: serializer.fromJson<double?>(json['totalttc']),
      tva: serializer.fromJson<double?>(json['tva']),
      contre: serializer.fromJson<String?>(json['contre']),
      bq: serializer.fromJson<String?>(json['bq']),
      verification: serializer.fromJson<String?>(json['verification']),
      type: serializer.fromJson<String?>(json['type']),
      numachats1: serializer.fromJson<String?>(json['numachats1']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'num': serializer.toJson<int>(num),
      'numachats': serializer.toJson<String?>(numachats),
      'nfact': serializer.toJson<String?>(nfact),
      'daty': serializer.toJson<DateTime?>(daty),
      'frns': serializer.toJson<String?>(frns),
      'modepai': serializer.toJson<String?>(modepai),
      'echeance': serializer.toJson<DateTime?>(echeance),
      'totalnt': serializer.toJson<double?>(totalnt),
      'totalttc': serializer.toJson<double?>(totalttc),
      'tva': serializer.toJson<double?>(tva),
      'contre': serializer.toJson<String?>(contre),
      'bq': serializer.toJson<String?>(bq),
      'verification': serializer.toJson<String?>(verification),
      'type': serializer.toJson<String?>(type),
      'numachats1': serializer.toJson<String?>(numachats1),
    };
  }

  Retachat copyWith(
          {int? num,
          Value<String?> numachats = const Value.absent(),
          Value<String?> nfact = const Value.absent(),
          Value<DateTime?> daty = const Value.absent(),
          Value<String?> frns = const Value.absent(),
          Value<String?> modepai = const Value.absent(),
          Value<DateTime?> echeance = const Value.absent(),
          Value<double?> totalnt = const Value.absent(),
          Value<double?> totalttc = const Value.absent(),
          Value<double?> tva = const Value.absent(),
          Value<String?> contre = const Value.absent(),
          Value<String?> bq = const Value.absent(),
          Value<String?> verification = const Value.absent(),
          Value<String?> type = const Value.absent(),
          Value<String?> numachats1 = const Value.absent()}) =>
      Retachat(
        num: num ?? this.num,
        numachats: numachats.present ? numachats.value : this.numachats,
        nfact: nfact.present ? nfact.value : this.nfact,
        daty: daty.present ? daty.value : this.daty,
        frns: frns.present ? frns.value : this.frns,
        modepai: modepai.present ? modepai.value : this.modepai,
        echeance: echeance.present ? echeance.value : this.echeance,
        totalnt: totalnt.present ? totalnt.value : this.totalnt,
        totalttc: totalttc.present ? totalttc.value : this.totalttc,
        tva: tva.present ? tva.value : this.tva,
        contre: contre.present ? contre.value : this.contre,
        bq: bq.present ? bq.value : this.bq,
        verification:
            verification.present ? verification.value : this.verification,
        type: type.present ? type.value : this.type,
        numachats1: numachats1.present ? numachats1.value : this.numachats1,
      );
  Retachat copyWithCompanion(RetachatsCompanion data) {
    return Retachat(
      num: data.num.present ? data.num.value : this.num,
      numachats: data.numachats.present ? data.numachats.value : this.numachats,
      nfact: data.nfact.present ? data.nfact.value : this.nfact,
      daty: data.daty.present ? data.daty.value : this.daty,
      frns: data.frns.present ? data.frns.value : this.frns,
      modepai: data.modepai.present ? data.modepai.value : this.modepai,
      echeance: data.echeance.present ? data.echeance.value : this.echeance,
      totalnt: data.totalnt.present ? data.totalnt.value : this.totalnt,
      totalttc: data.totalttc.present ? data.totalttc.value : this.totalttc,
      tva: data.tva.present ? data.tva.value : this.tva,
      contre: data.contre.present ? data.contre.value : this.contre,
      bq: data.bq.present ? data.bq.value : this.bq,
      verification: data.verification.present
          ? data.verification.value
          : this.verification,
      type: data.type.present ? data.type.value : this.type,
      numachats1:
          data.numachats1.present ? data.numachats1.value : this.numachats1,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Retachat(')
          ..write('num: $num, ')
          ..write('numachats: $numachats, ')
          ..write('nfact: $nfact, ')
          ..write('daty: $daty, ')
          ..write('frns: $frns, ')
          ..write('modepai: $modepai, ')
          ..write('echeance: $echeance, ')
          ..write('totalnt: $totalnt, ')
          ..write('totalttc: $totalttc, ')
          ..write('tva: $tva, ')
          ..write('contre: $contre, ')
          ..write('bq: $bq, ')
          ..write('verification: $verification, ')
          ..write('type: $type, ')
          ..write('numachats1: $numachats1')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      num,
      numachats,
      nfact,
      daty,
      frns,
      modepai,
      echeance,
      totalnt,
      totalttc,
      tva,
      contre,
      bq,
      verification,
      type,
      numachats1);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Retachat &&
          other.num == this.num &&
          other.numachats == this.numachats &&
          other.nfact == this.nfact &&
          other.daty == this.daty &&
          other.frns == this.frns &&
          other.modepai == this.modepai &&
          other.echeance == this.echeance &&
          other.totalnt == this.totalnt &&
          other.totalttc == this.totalttc &&
          other.tva == this.tva &&
          other.contre == this.contre &&
          other.bq == this.bq &&
          other.verification == this.verification &&
          other.type == this.type &&
          other.numachats1 == this.numachats1);
}

class RetachatsCompanion extends UpdateCompanion<Retachat> {
  final Value<int> num;
  final Value<String?> numachats;
  final Value<String?> nfact;
  final Value<DateTime?> daty;
  final Value<String?> frns;
  final Value<String?> modepai;
  final Value<DateTime?> echeance;
  final Value<double?> totalnt;
  final Value<double?> totalttc;
  final Value<double?> tva;
  final Value<String?> contre;
  final Value<String?> bq;
  final Value<String?> verification;
  final Value<String?> type;
  final Value<String?> numachats1;
  const RetachatsCompanion({
    this.num = const Value.absent(),
    this.numachats = const Value.absent(),
    this.nfact = const Value.absent(),
    this.daty = const Value.absent(),
    this.frns = const Value.absent(),
    this.modepai = const Value.absent(),
    this.echeance = const Value.absent(),
    this.totalnt = const Value.absent(),
    this.totalttc = const Value.absent(),
    this.tva = const Value.absent(),
    this.contre = const Value.absent(),
    this.bq = const Value.absent(),
    this.verification = const Value.absent(),
    this.type = const Value.absent(),
    this.numachats1 = const Value.absent(),
  });
  RetachatsCompanion.insert({
    this.num = const Value.absent(),
    this.numachats = const Value.absent(),
    this.nfact = const Value.absent(),
    this.daty = const Value.absent(),
    this.frns = const Value.absent(),
    this.modepai = const Value.absent(),
    this.echeance = const Value.absent(),
    this.totalnt = const Value.absent(),
    this.totalttc = const Value.absent(),
    this.tva = const Value.absent(),
    this.contre = const Value.absent(),
    this.bq = const Value.absent(),
    this.verification = const Value.absent(),
    this.type = const Value.absent(),
    this.numachats1 = const Value.absent(),
  });
  static Insertable<Retachat> custom({
    Expression<int>? num,
    Expression<String>? numachats,
    Expression<String>? nfact,
    Expression<DateTime>? daty,
    Expression<String>? frns,
    Expression<String>? modepai,
    Expression<DateTime>? echeance,
    Expression<double>? totalnt,
    Expression<double>? totalttc,
    Expression<double>? tva,
    Expression<String>? contre,
    Expression<String>? bq,
    Expression<String>? verification,
    Expression<String>? type,
    Expression<String>? numachats1,
  }) {
    return RawValuesInsertable({
      if (num != null) 'num': num,
      if (numachats != null) 'numachats': numachats,
      if (nfact != null) 'nfact': nfact,
      if (daty != null) 'daty': daty,
      if (frns != null) 'frns': frns,
      if (modepai != null) 'modepai': modepai,
      if (echeance != null) 'echeance': echeance,
      if (totalnt != null) 'totalnt': totalnt,
      if (totalttc != null) 'totalttc': totalttc,
      if (tva != null) 'tva': tva,
      if (contre != null) 'contre': contre,
      if (bq != null) 'bq': bq,
      if (verification != null) 'verification': verification,
      if (type != null) 'type': type,
      if (numachats1 != null) 'numachats1': numachats1,
    });
  }

  RetachatsCompanion copyWith(
      {Value<int>? num,
      Value<String?>? numachats,
      Value<String?>? nfact,
      Value<DateTime?>? daty,
      Value<String?>? frns,
      Value<String?>? modepai,
      Value<DateTime?>? echeance,
      Value<double?>? totalnt,
      Value<double?>? totalttc,
      Value<double?>? tva,
      Value<String?>? contre,
      Value<String?>? bq,
      Value<String?>? verification,
      Value<String?>? type,
      Value<String?>? numachats1}) {
    return RetachatsCompanion(
      num: num ?? this.num,
      numachats: numachats ?? this.numachats,
      nfact: nfact ?? this.nfact,
      daty: daty ?? this.daty,
      frns: frns ?? this.frns,
      modepai: modepai ?? this.modepai,
      echeance: echeance ?? this.echeance,
      totalnt: totalnt ?? this.totalnt,
      totalttc: totalttc ?? this.totalttc,
      tva: tva ?? this.tva,
      contre: contre ?? this.contre,
      bq: bq ?? this.bq,
      verification: verification ?? this.verification,
      type: type ?? this.type,
      numachats1: numachats1 ?? this.numachats1,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (num.present) {
      map['num'] = Variable<int>(num.value);
    }
    if (numachats.present) {
      map['numachats'] = Variable<String>(numachats.value);
    }
    if (nfact.present) {
      map['nfact'] = Variable<String>(nfact.value);
    }
    if (daty.present) {
      map['daty'] = Variable<DateTime>(daty.value);
    }
    if (frns.present) {
      map['frns'] = Variable<String>(frns.value);
    }
    if (modepai.present) {
      map['modepai'] = Variable<String>(modepai.value);
    }
    if (echeance.present) {
      map['echeance'] = Variable<DateTime>(echeance.value);
    }
    if (totalnt.present) {
      map['totalnt'] = Variable<double>(totalnt.value);
    }
    if (totalttc.present) {
      map['totalttc'] = Variable<double>(totalttc.value);
    }
    if (tva.present) {
      map['tva'] = Variable<double>(tva.value);
    }
    if (contre.present) {
      map['contre'] = Variable<String>(contre.value);
    }
    if (bq.present) {
      map['bq'] = Variable<String>(bq.value);
    }
    if (verification.present) {
      map['verification'] = Variable<String>(verification.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (numachats1.present) {
      map['numachats1'] = Variable<String>(numachats1.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('RetachatsCompanion(')
          ..write('num: $num, ')
          ..write('numachats: $numachats, ')
          ..write('nfact: $nfact, ')
          ..write('daty: $daty, ')
          ..write('frns: $frns, ')
          ..write('modepai: $modepai, ')
          ..write('echeance: $echeance, ')
          ..write('totalnt: $totalnt, ')
          ..write('totalttc: $totalttc, ')
          ..write('tva: $tva, ')
          ..write('contre: $contre, ')
          ..write('bq: $bq, ')
          ..write('verification: $verification, ')
          ..write('type: $type, ')
          ..write('numachats1: $numachats1')
          ..write(')'))
        .toString();
  }
}

class $RetdetachatsTable extends Retdetachats
    with TableInfo<$RetdetachatsTable, Retdetachat> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $RetdetachatsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _numMeta = const VerificationMeta('num');
  @override
  late final GeneratedColumn<int> num = GeneratedColumn<int>(
      'num', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _numachatsMeta =
      const VerificationMeta('numachats');
  @override
  late final GeneratedColumn<String> numachats = GeneratedColumn<String>(
      'numachats', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _designationMeta =
      const VerificationMeta('designation');
  @override
  late final GeneratedColumn<String> designation = GeneratedColumn<String>(
      'designation', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _uniteMeta = const VerificationMeta('unite');
  @override
  late final GeneratedColumn<String> unite = GeneratedColumn<String>(
      'unite', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _depotsMeta = const VerificationMeta('depots');
  @override
  late final GeneratedColumn<String> depots = GeneratedColumn<String>(
      'depots', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _qMeta = const VerificationMeta('q');
  @override
  late final GeneratedColumn<double> q = GeneratedColumn<double>(
      'q', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _puMeta = const VerificationMeta('pu');
  @override
  late final GeneratedColumn<double> pu = GeneratedColumn<double>(
      'pu', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns =>
      [num, numachats, designation, unite, depots, q, pu];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'retdetachats';
  @override
  VerificationContext validateIntegrity(Insertable<Retdetachat> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('num')) {
      context.handle(
          _numMeta, num.isAcceptableOrUnknown(data['num']!, _numMeta));
    }
    if (data.containsKey('numachats')) {
      context.handle(_numachatsMeta,
          numachats.isAcceptableOrUnknown(data['numachats']!, _numachatsMeta));
    }
    if (data.containsKey('designation')) {
      context.handle(
          _designationMeta,
          designation.isAcceptableOrUnknown(
              data['designation']!, _designationMeta));
    }
    if (data.containsKey('unite')) {
      context.handle(
          _uniteMeta, unite.isAcceptableOrUnknown(data['unite']!, _uniteMeta));
    }
    if (data.containsKey('depots')) {
      context.handle(_depotsMeta,
          depots.isAcceptableOrUnknown(data['depots']!, _depotsMeta));
    }
    if (data.containsKey('q')) {
      context.handle(_qMeta, q.isAcceptableOrUnknown(data['q']!, _qMeta));
    }
    if (data.containsKey('pu')) {
      context.handle(_puMeta, pu.isAcceptableOrUnknown(data['pu']!, _puMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {num};
  @override
  Retdetachat map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Retdetachat(
      num: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}num'])!,
      numachats: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}numachats']),
      designation: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}designation']),
      unite: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}unite']),
      depots: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}depots']),
      q: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}q']),
      pu: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}pu']),
    );
  }

  @override
  $RetdetachatsTable createAlias(String alias) {
    return $RetdetachatsTable(attachedDatabase, alias);
  }
}

class Retdetachat extends DataClass implements Insertable<Retdetachat> {
  final int num;
  final String? numachats;
  final String? designation;
  final String? unite;
  final String? depots;
  final double? q;
  final double? pu;
  const Retdetachat(
      {required this.num,
      this.numachats,
      this.designation,
      this.unite,
      this.depots,
      this.q,
      this.pu});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['num'] = Variable<int>(num);
    if (!nullToAbsent || numachats != null) {
      map['numachats'] = Variable<String>(numachats);
    }
    if (!nullToAbsent || designation != null) {
      map['designation'] = Variable<String>(designation);
    }
    if (!nullToAbsent || unite != null) {
      map['unite'] = Variable<String>(unite);
    }
    if (!nullToAbsent || depots != null) {
      map['depots'] = Variable<String>(depots);
    }
    if (!nullToAbsent || q != null) {
      map['q'] = Variable<double>(q);
    }
    if (!nullToAbsent || pu != null) {
      map['pu'] = Variable<double>(pu);
    }
    return map;
  }

  RetdetachatsCompanion toCompanion(bool nullToAbsent) {
    return RetdetachatsCompanion(
      num: Value(num),
      numachats: numachats == null && nullToAbsent
          ? const Value.absent()
          : Value(numachats),
      designation: designation == null && nullToAbsent
          ? const Value.absent()
          : Value(designation),
      unite:
          unite == null && nullToAbsent ? const Value.absent() : Value(unite),
      depots:
          depots == null && nullToAbsent ? const Value.absent() : Value(depots),
      q: q == null && nullToAbsent ? const Value.absent() : Value(q),
      pu: pu == null && nullToAbsent ? const Value.absent() : Value(pu),
    );
  }

  factory Retdetachat.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Retdetachat(
      num: serializer.fromJson<int>(json['num']),
      numachats: serializer.fromJson<String?>(json['numachats']),
      designation: serializer.fromJson<String?>(json['designation']),
      unite: serializer.fromJson<String?>(json['unite']),
      depots: serializer.fromJson<String?>(json['depots']),
      q: serializer.fromJson<double?>(json['q']),
      pu: serializer.fromJson<double?>(json['pu']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'num': serializer.toJson<int>(num),
      'numachats': serializer.toJson<String?>(numachats),
      'designation': serializer.toJson<String?>(designation),
      'unite': serializer.toJson<String?>(unite),
      'depots': serializer.toJson<String?>(depots),
      'q': serializer.toJson<double?>(q),
      'pu': serializer.toJson<double?>(pu),
    };
  }

  Retdetachat copyWith(
          {int? num,
          Value<String?> numachats = const Value.absent(),
          Value<String?> designation = const Value.absent(),
          Value<String?> unite = const Value.absent(),
          Value<String?> depots = const Value.absent(),
          Value<double?> q = const Value.absent(),
          Value<double?> pu = const Value.absent()}) =>
      Retdetachat(
        num: num ?? this.num,
        numachats: numachats.present ? numachats.value : this.numachats,
        designation: designation.present ? designation.value : this.designation,
        unite: unite.present ? unite.value : this.unite,
        depots: depots.present ? depots.value : this.depots,
        q: q.present ? q.value : this.q,
        pu: pu.present ? pu.value : this.pu,
      );
  Retdetachat copyWithCompanion(RetdetachatsCompanion data) {
    return Retdetachat(
      num: data.num.present ? data.num.value : this.num,
      numachats: data.numachats.present ? data.numachats.value : this.numachats,
      designation:
          data.designation.present ? data.designation.value : this.designation,
      unite: data.unite.present ? data.unite.value : this.unite,
      depots: data.depots.present ? data.depots.value : this.depots,
      q: data.q.present ? data.q.value : this.q,
      pu: data.pu.present ? data.pu.value : this.pu,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Retdetachat(')
          ..write('num: $num, ')
          ..write('numachats: $numachats, ')
          ..write('designation: $designation, ')
          ..write('unite: $unite, ')
          ..write('depots: $depots, ')
          ..write('q: $q, ')
          ..write('pu: $pu')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(num, numachats, designation, unite, depots, q, pu);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Retdetachat &&
          other.num == this.num &&
          other.numachats == this.numachats &&
          other.designation == this.designation &&
          other.unite == this.unite &&
          other.depots == this.depots &&
          other.q == this.q &&
          other.pu == this.pu);
}

class RetdetachatsCompanion extends UpdateCompanion<Retdetachat> {
  final Value<int> num;
  final Value<String?> numachats;
  final Value<String?> designation;
  final Value<String?> unite;
  final Value<String?> depots;
  final Value<double?> q;
  final Value<double?> pu;
  const RetdetachatsCompanion({
    this.num = const Value.absent(),
    this.numachats = const Value.absent(),
    this.designation = const Value.absent(),
    this.unite = const Value.absent(),
    this.depots = const Value.absent(),
    this.q = const Value.absent(),
    this.pu = const Value.absent(),
  });
  RetdetachatsCompanion.insert({
    this.num = const Value.absent(),
    this.numachats = const Value.absent(),
    this.designation = const Value.absent(),
    this.unite = const Value.absent(),
    this.depots = const Value.absent(),
    this.q = const Value.absent(),
    this.pu = const Value.absent(),
  });
  static Insertable<Retdetachat> custom({
    Expression<int>? num,
    Expression<String>? numachats,
    Expression<String>? designation,
    Expression<String>? unite,
    Expression<String>? depots,
    Expression<double>? q,
    Expression<double>? pu,
  }) {
    return RawValuesInsertable({
      if (num != null) 'num': num,
      if (numachats != null) 'numachats': numachats,
      if (designation != null) 'designation': designation,
      if (unite != null) 'unite': unite,
      if (depots != null) 'depots': depots,
      if (q != null) 'q': q,
      if (pu != null) 'pu': pu,
    });
  }

  RetdetachatsCompanion copyWith(
      {Value<int>? num,
      Value<String?>? numachats,
      Value<String?>? designation,
      Value<String?>? unite,
      Value<String?>? depots,
      Value<double?>? q,
      Value<double?>? pu}) {
    return RetdetachatsCompanion(
      num: num ?? this.num,
      numachats: numachats ?? this.numachats,
      designation: designation ?? this.designation,
      unite: unite ?? this.unite,
      depots: depots ?? this.depots,
      q: q ?? this.q,
      pu: pu ?? this.pu,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (num.present) {
      map['num'] = Variable<int>(num.value);
    }
    if (numachats.present) {
      map['numachats'] = Variable<String>(numachats.value);
    }
    if (designation.present) {
      map['designation'] = Variable<String>(designation.value);
    }
    if (unite.present) {
      map['unite'] = Variable<String>(unite.value);
    }
    if (depots.present) {
      map['depots'] = Variable<String>(depots.value);
    }
    if (q.present) {
      map['q'] = Variable<double>(q.value);
    }
    if (pu.present) {
      map['pu'] = Variable<double>(pu.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('RetdetachatsCompanion(')
          ..write('num: $num, ')
          ..write('numachats: $numachats, ')
          ..write('designation: $designation, ')
          ..write('unite: $unite, ')
          ..write('depots: $depots, ')
          ..write('q: $q, ')
          ..write('pu: $pu')
          ..write(')'))
        .toString();
  }
}

class $RetdeventesTable extends Retdeventes
    with TableInfo<$RetdeventesTable, Retdevente> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $RetdeventesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _numMeta = const VerificationMeta('num');
  @override
  late final GeneratedColumn<int> num = GeneratedColumn<int>(
      'num', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _numventesMeta =
      const VerificationMeta('numventes');
  @override
  late final GeneratedColumn<String> numventes = GeneratedColumn<String>(
      'numventes', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _designationMeta =
      const VerificationMeta('designation');
  @override
  late final GeneratedColumn<String> designation = GeneratedColumn<String>(
      'designation', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _unitesMeta = const VerificationMeta('unites');
  @override
  late final GeneratedColumn<String> unites = GeneratedColumn<String>(
      'unites', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 20),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _depotsMeta = const VerificationMeta('depots');
  @override
  late final GeneratedColumn<String> depots = GeneratedColumn<String>(
      'depots', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _qMeta = const VerificationMeta('q');
  @override
  late final GeneratedColumn<double> q = GeneratedColumn<double>(
      'q', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _puMeta = const VerificationMeta('pu');
  @override
  late final GeneratedColumn<double> pu = GeneratedColumn<double>(
      'pu', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns =>
      [num, numventes, designation, unites, depots, q, pu];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'retdeventes';
  @override
  VerificationContext validateIntegrity(Insertable<Retdevente> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('num')) {
      context.handle(
          _numMeta, num.isAcceptableOrUnknown(data['num']!, _numMeta));
    }
    if (data.containsKey('numventes')) {
      context.handle(_numventesMeta,
          numventes.isAcceptableOrUnknown(data['numventes']!, _numventesMeta));
    }
    if (data.containsKey('designation')) {
      context.handle(
          _designationMeta,
          designation.isAcceptableOrUnknown(
              data['designation']!, _designationMeta));
    }
    if (data.containsKey('unites')) {
      context.handle(_unitesMeta,
          unites.isAcceptableOrUnknown(data['unites']!, _unitesMeta));
    }
    if (data.containsKey('depots')) {
      context.handle(_depotsMeta,
          depots.isAcceptableOrUnknown(data['depots']!, _depotsMeta));
    }
    if (data.containsKey('q')) {
      context.handle(_qMeta, q.isAcceptableOrUnknown(data['q']!, _qMeta));
    }
    if (data.containsKey('pu')) {
      context.handle(_puMeta, pu.isAcceptableOrUnknown(data['pu']!, _puMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {num};
  @override
  Retdevente map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Retdevente(
      num: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}num'])!,
      numventes: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}numventes']),
      designation: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}designation']),
      unites: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}unites']),
      depots: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}depots']),
      q: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}q']),
      pu: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}pu']),
    );
  }

  @override
  $RetdeventesTable createAlias(String alias) {
    return $RetdeventesTable(attachedDatabase, alias);
  }
}

class Retdevente extends DataClass implements Insertable<Retdevente> {
  final int num;
  final String? numventes;
  final String? designation;
  final String? unites;
  final String? depots;
  final double? q;
  final double? pu;
  const Retdevente(
      {required this.num,
      this.numventes,
      this.designation,
      this.unites,
      this.depots,
      this.q,
      this.pu});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['num'] = Variable<int>(num);
    if (!nullToAbsent || numventes != null) {
      map['numventes'] = Variable<String>(numventes);
    }
    if (!nullToAbsent || designation != null) {
      map['designation'] = Variable<String>(designation);
    }
    if (!nullToAbsent || unites != null) {
      map['unites'] = Variable<String>(unites);
    }
    if (!nullToAbsent || depots != null) {
      map['depots'] = Variable<String>(depots);
    }
    if (!nullToAbsent || q != null) {
      map['q'] = Variable<double>(q);
    }
    if (!nullToAbsent || pu != null) {
      map['pu'] = Variable<double>(pu);
    }
    return map;
  }

  RetdeventesCompanion toCompanion(bool nullToAbsent) {
    return RetdeventesCompanion(
      num: Value(num),
      numventes: numventes == null && nullToAbsent
          ? const Value.absent()
          : Value(numventes),
      designation: designation == null && nullToAbsent
          ? const Value.absent()
          : Value(designation),
      unites:
          unites == null && nullToAbsent ? const Value.absent() : Value(unites),
      depots:
          depots == null && nullToAbsent ? const Value.absent() : Value(depots),
      q: q == null && nullToAbsent ? const Value.absent() : Value(q),
      pu: pu == null && nullToAbsent ? const Value.absent() : Value(pu),
    );
  }

  factory Retdevente.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Retdevente(
      num: serializer.fromJson<int>(json['num']),
      numventes: serializer.fromJson<String?>(json['numventes']),
      designation: serializer.fromJson<String?>(json['designation']),
      unites: serializer.fromJson<String?>(json['unites']),
      depots: serializer.fromJson<String?>(json['depots']),
      q: serializer.fromJson<double?>(json['q']),
      pu: serializer.fromJson<double?>(json['pu']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'num': serializer.toJson<int>(num),
      'numventes': serializer.toJson<String?>(numventes),
      'designation': serializer.toJson<String?>(designation),
      'unites': serializer.toJson<String?>(unites),
      'depots': serializer.toJson<String?>(depots),
      'q': serializer.toJson<double?>(q),
      'pu': serializer.toJson<double?>(pu),
    };
  }

  Retdevente copyWith(
          {int? num,
          Value<String?> numventes = const Value.absent(),
          Value<String?> designation = const Value.absent(),
          Value<String?> unites = const Value.absent(),
          Value<String?> depots = const Value.absent(),
          Value<double?> q = const Value.absent(),
          Value<double?> pu = const Value.absent()}) =>
      Retdevente(
        num: num ?? this.num,
        numventes: numventes.present ? numventes.value : this.numventes,
        designation: designation.present ? designation.value : this.designation,
        unites: unites.present ? unites.value : this.unites,
        depots: depots.present ? depots.value : this.depots,
        q: q.present ? q.value : this.q,
        pu: pu.present ? pu.value : this.pu,
      );
  Retdevente copyWithCompanion(RetdeventesCompanion data) {
    return Retdevente(
      num: data.num.present ? data.num.value : this.num,
      numventes: data.numventes.present ? data.numventes.value : this.numventes,
      designation:
          data.designation.present ? data.designation.value : this.designation,
      unites: data.unites.present ? data.unites.value : this.unites,
      depots: data.depots.present ? data.depots.value : this.depots,
      q: data.q.present ? data.q.value : this.q,
      pu: data.pu.present ? data.pu.value : this.pu,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Retdevente(')
          ..write('num: $num, ')
          ..write('numventes: $numventes, ')
          ..write('designation: $designation, ')
          ..write('unites: $unites, ')
          ..write('depots: $depots, ')
          ..write('q: $q, ')
          ..write('pu: $pu')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(num, numventes, designation, unites, depots, q, pu);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Retdevente &&
          other.num == this.num &&
          other.numventes == this.numventes &&
          other.designation == this.designation &&
          other.unites == this.unites &&
          other.depots == this.depots &&
          other.q == this.q &&
          other.pu == this.pu);
}

class RetdeventesCompanion extends UpdateCompanion<Retdevente> {
  final Value<int> num;
  final Value<String?> numventes;
  final Value<String?> designation;
  final Value<String?> unites;
  final Value<String?> depots;
  final Value<double?> q;
  final Value<double?> pu;
  const RetdeventesCompanion({
    this.num = const Value.absent(),
    this.numventes = const Value.absent(),
    this.designation = const Value.absent(),
    this.unites = const Value.absent(),
    this.depots = const Value.absent(),
    this.q = const Value.absent(),
    this.pu = const Value.absent(),
  });
  RetdeventesCompanion.insert({
    this.num = const Value.absent(),
    this.numventes = const Value.absent(),
    this.designation = const Value.absent(),
    this.unites = const Value.absent(),
    this.depots = const Value.absent(),
    this.q = const Value.absent(),
    this.pu = const Value.absent(),
  });
  static Insertable<Retdevente> custom({
    Expression<int>? num,
    Expression<String>? numventes,
    Expression<String>? designation,
    Expression<String>? unites,
    Expression<String>? depots,
    Expression<double>? q,
    Expression<double>? pu,
  }) {
    return RawValuesInsertable({
      if (num != null) 'num': num,
      if (numventes != null) 'numventes': numventes,
      if (designation != null) 'designation': designation,
      if (unites != null) 'unites': unites,
      if (depots != null) 'depots': depots,
      if (q != null) 'q': q,
      if (pu != null) 'pu': pu,
    });
  }

  RetdeventesCompanion copyWith(
      {Value<int>? num,
      Value<String?>? numventes,
      Value<String?>? designation,
      Value<String?>? unites,
      Value<String?>? depots,
      Value<double?>? q,
      Value<double?>? pu}) {
    return RetdeventesCompanion(
      num: num ?? this.num,
      numventes: numventes ?? this.numventes,
      designation: designation ?? this.designation,
      unites: unites ?? this.unites,
      depots: depots ?? this.depots,
      q: q ?? this.q,
      pu: pu ?? this.pu,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (num.present) {
      map['num'] = Variable<int>(num.value);
    }
    if (numventes.present) {
      map['numventes'] = Variable<String>(numventes.value);
    }
    if (designation.present) {
      map['designation'] = Variable<String>(designation.value);
    }
    if (unites.present) {
      map['unites'] = Variable<String>(unites.value);
    }
    if (depots.present) {
      map['depots'] = Variable<String>(depots.value);
    }
    if (q.present) {
      map['q'] = Variable<double>(q.value);
    }
    if (pu.present) {
      map['pu'] = Variable<double>(pu.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('RetdeventesCompanion(')
          ..write('num: $num, ')
          ..write('numventes: $numventes, ')
          ..write('designation: $designation, ')
          ..write('unites: $unites, ')
          ..write('depots: $depots, ')
          ..write('q: $q, ')
          ..write('pu: $pu')
          ..write(')'))
        .toString();
  }
}

class $RetventesTable extends Retventes
    with TableInfo<$RetventesTable, Retvente> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $RetventesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _numMeta = const VerificationMeta('num');
  @override
  late final GeneratedColumn<int> num = GeneratedColumn<int>(
      'num', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _numventesMeta =
      const VerificationMeta('numventes');
  @override
  late final GeneratedColumn<String> numventes = GeneratedColumn<String>(
      'numventes', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _nfactMeta = const VerificationMeta('nfact');
  @override
  late final GeneratedColumn<String> nfact = GeneratedColumn<String>(
      'nfact', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _datyMeta = const VerificationMeta('daty');
  @override
  late final GeneratedColumn<DateTime> daty = GeneratedColumn<DateTime>(
      'daty', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _cltMeta = const VerificationMeta('clt');
  @override
  late final GeneratedColumn<String> clt = GeneratedColumn<String>(
      'clt', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _modepaiMeta =
      const VerificationMeta('modepai');
  @override
  late final GeneratedColumn<String> modepai = GeneratedColumn<String>(
      'modepai', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _echeanceMeta =
      const VerificationMeta('echeance');
  @override
  late final GeneratedColumn<DateTime> echeance = GeneratedColumn<DateTime>(
      'echeance', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _totalntMeta =
      const VerificationMeta('totalnt');
  @override
  late final GeneratedColumn<double> totalnt = GeneratedColumn<double>(
      'totalnt', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _totalttcMeta =
      const VerificationMeta('totalttc');
  @override
  late final GeneratedColumn<double> totalttc = GeneratedColumn<double>(
      'totalttc', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _tvaMeta = const VerificationMeta('tva');
  @override
  late final GeneratedColumn<double> tva = GeneratedColumn<double>(
      'tva', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _contreMeta = const VerificationMeta('contre');
  @override
  late final GeneratedColumn<String> contre = GeneratedColumn<String>(
      'contre', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _avanceMeta = const VerificationMeta('avance');
  @override
  late final GeneratedColumn<double> avance = GeneratedColumn<double>(
      'avance', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _bqMeta = const VerificationMeta('bq');
  @override
  late final GeneratedColumn<String> bq = GeneratedColumn<String>(
      'bq', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _commercMeta =
      const VerificationMeta('commerc');
  @override
  late final GeneratedColumn<String> commerc = GeneratedColumn<String>(
      'commerc', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _commissionMeta =
      const VerificationMeta('commission');
  @override
  late final GeneratedColumn<double> commission = GeneratedColumn<double>(
      'commission', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _remiseMeta = const VerificationMeta('remise');
  @override
  late final GeneratedColumn<double> remise = GeneratedColumn<double>(
      'remise', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _verificationMeta =
      const VerificationMeta('verification');
  @override
  late final GeneratedColumn<String> verification = GeneratedColumn<String>(
      'verification', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
      'type', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _numventes1Meta =
      const VerificationMeta('numventes1');
  @override
  late final GeneratedColumn<String> numventes1 = GeneratedColumn<String>(
      'numventes1', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        num,
        numventes,
        nfact,
        daty,
        clt,
        modepai,
        echeance,
        totalnt,
        totalttc,
        tva,
        contre,
        avance,
        bq,
        commerc,
        commission,
        remise,
        verification,
        type,
        numventes1
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'retventes';
  @override
  VerificationContext validateIntegrity(Insertable<Retvente> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('num')) {
      context.handle(
          _numMeta, num.isAcceptableOrUnknown(data['num']!, _numMeta));
    }
    if (data.containsKey('numventes')) {
      context.handle(_numventesMeta,
          numventes.isAcceptableOrUnknown(data['numventes']!, _numventesMeta));
    }
    if (data.containsKey('nfact')) {
      context.handle(
          _nfactMeta, nfact.isAcceptableOrUnknown(data['nfact']!, _nfactMeta));
    }
    if (data.containsKey('daty')) {
      context.handle(
          _datyMeta, daty.isAcceptableOrUnknown(data['daty']!, _datyMeta));
    }
    if (data.containsKey('clt')) {
      context.handle(
          _cltMeta, clt.isAcceptableOrUnknown(data['clt']!, _cltMeta));
    }
    if (data.containsKey('modepai')) {
      context.handle(_modepaiMeta,
          modepai.isAcceptableOrUnknown(data['modepai']!, _modepaiMeta));
    }
    if (data.containsKey('echeance')) {
      context.handle(_echeanceMeta,
          echeance.isAcceptableOrUnknown(data['echeance']!, _echeanceMeta));
    }
    if (data.containsKey('totalnt')) {
      context.handle(_totalntMeta,
          totalnt.isAcceptableOrUnknown(data['totalnt']!, _totalntMeta));
    }
    if (data.containsKey('totalttc')) {
      context.handle(_totalttcMeta,
          totalttc.isAcceptableOrUnknown(data['totalttc']!, _totalttcMeta));
    }
    if (data.containsKey('tva')) {
      context.handle(
          _tvaMeta, tva.isAcceptableOrUnknown(data['tva']!, _tvaMeta));
    }
    if (data.containsKey('contre')) {
      context.handle(_contreMeta,
          contre.isAcceptableOrUnknown(data['contre']!, _contreMeta));
    }
    if (data.containsKey('avance')) {
      context.handle(_avanceMeta,
          avance.isAcceptableOrUnknown(data['avance']!, _avanceMeta));
    }
    if (data.containsKey('bq')) {
      context.handle(_bqMeta, bq.isAcceptableOrUnknown(data['bq']!, _bqMeta));
    }
    if (data.containsKey('commerc')) {
      context.handle(_commercMeta,
          commerc.isAcceptableOrUnknown(data['commerc']!, _commercMeta));
    }
    if (data.containsKey('commission')) {
      context.handle(
          _commissionMeta,
          commission.isAcceptableOrUnknown(
              data['commission']!, _commissionMeta));
    }
    if (data.containsKey('remise')) {
      context.handle(_remiseMeta,
          remise.isAcceptableOrUnknown(data['remise']!, _remiseMeta));
    }
    if (data.containsKey('verification')) {
      context.handle(
          _verificationMeta,
          verification.isAcceptableOrUnknown(
              data['verification']!, _verificationMeta));
    }
    if (data.containsKey('type')) {
      context.handle(
          _typeMeta, type.isAcceptableOrUnknown(data['type']!, _typeMeta));
    }
    if (data.containsKey('numventes1')) {
      context.handle(
          _numventes1Meta,
          numventes1.isAcceptableOrUnknown(
              data['numventes1']!, _numventes1Meta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {num};
  @override
  Retvente map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Retvente(
      num: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}num'])!,
      numventes: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}numventes']),
      nfact: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}nfact']),
      daty: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}daty']),
      clt: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}clt']),
      modepai: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}modepai']),
      echeance: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}echeance']),
      totalnt: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}totalnt']),
      totalttc: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}totalttc']),
      tva: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}tva']),
      contre: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}contre']),
      avance: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}avance']),
      bq: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}bq']),
      commerc: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}commerc']),
      commission: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}commission']),
      remise: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}remise']),
      verification: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}verification']),
      type: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type']),
      numventes1: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}numventes1']),
    );
  }

  @override
  $RetventesTable createAlias(String alias) {
    return $RetventesTable(attachedDatabase, alias);
  }
}

class Retvente extends DataClass implements Insertable<Retvente> {
  final int num;
  final String? numventes;
  final String? nfact;
  final DateTime? daty;
  final String? clt;
  final String? modepai;
  final DateTime? echeance;
  final double? totalnt;
  final double? totalttc;
  final double? tva;
  final String? contre;
  final double? avance;
  final String? bq;
  final String? commerc;
  final double? commission;
  final double? remise;
  final String? verification;
  final String? type;
  final String? numventes1;
  const Retvente(
      {required this.num,
      this.numventes,
      this.nfact,
      this.daty,
      this.clt,
      this.modepai,
      this.echeance,
      this.totalnt,
      this.totalttc,
      this.tva,
      this.contre,
      this.avance,
      this.bq,
      this.commerc,
      this.commission,
      this.remise,
      this.verification,
      this.type,
      this.numventes1});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['num'] = Variable<int>(num);
    if (!nullToAbsent || numventes != null) {
      map['numventes'] = Variable<String>(numventes);
    }
    if (!nullToAbsent || nfact != null) {
      map['nfact'] = Variable<String>(nfact);
    }
    if (!nullToAbsent || daty != null) {
      map['daty'] = Variable<DateTime>(daty);
    }
    if (!nullToAbsent || clt != null) {
      map['clt'] = Variable<String>(clt);
    }
    if (!nullToAbsent || modepai != null) {
      map['modepai'] = Variable<String>(modepai);
    }
    if (!nullToAbsent || echeance != null) {
      map['echeance'] = Variable<DateTime>(echeance);
    }
    if (!nullToAbsent || totalnt != null) {
      map['totalnt'] = Variable<double>(totalnt);
    }
    if (!nullToAbsent || totalttc != null) {
      map['totalttc'] = Variable<double>(totalttc);
    }
    if (!nullToAbsent || tva != null) {
      map['tva'] = Variable<double>(tva);
    }
    if (!nullToAbsent || contre != null) {
      map['contre'] = Variable<String>(contre);
    }
    if (!nullToAbsent || avance != null) {
      map['avance'] = Variable<double>(avance);
    }
    if (!nullToAbsent || bq != null) {
      map['bq'] = Variable<String>(bq);
    }
    if (!nullToAbsent || commerc != null) {
      map['commerc'] = Variable<String>(commerc);
    }
    if (!nullToAbsent || commission != null) {
      map['commission'] = Variable<double>(commission);
    }
    if (!nullToAbsent || remise != null) {
      map['remise'] = Variable<double>(remise);
    }
    if (!nullToAbsent || verification != null) {
      map['verification'] = Variable<String>(verification);
    }
    if (!nullToAbsent || type != null) {
      map['type'] = Variable<String>(type);
    }
    if (!nullToAbsent || numventes1 != null) {
      map['numventes1'] = Variable<String>(numventes1);
    }
    return map;
  }

  RetventesCompanion toCompanion(bool nullToAbsent) {
    return RetventesCompanion(
      num: Value(num),
      numventes: numventes == null && nullToAbsent
          ? const Value.absent()
          : Value(numventes),
      nfact:
          nfact == null && nullToAbsent ? const Value.absent() : Value(nfact),
      daty: daty == null && nullToAbsent ? const Value.absent() : Value(daty),
      clt: clt == null && nullToAbsent ? const Value.absent() : Value(clt),
      modepai: modepai == null && nullToAbsent
          ? const Value.absent()
          : Value(modepai),
      echeance: echeance == null && nullToAbsent
          ? const Value.absent()
          : Value(echeance),
      totalnt: totalnt == null && nullToAbsent
          ? const Value.absent()
          : Value(totalnt),
      totalttc: totalttc == null && nullToAbsent
          ? const Value.absent()
          : Value(totalttc),
      tva: tva == null && nullToAbsent ? const Value.absent() : Value(tva),
      contre:
          contre == null && nullToAbsent ? const Value.absent() : Value(contre),
      avance:
          avance == null && nullToAbsent ? const Value.absent() : Value(avance),
      bq: bq == null && nullToAbsent ? const Value.absent() : Value(bq),
      commerc: commerc == null && nullToAbsent
          ? const Value.absent()
          : Value(commerc),
      commission: commission == null && nullToAbsent
          ? const Value.absent()
          : Value(commission),
      remise:
          remise == null && nullToAbsent ? const Value.absent() : Value(remise),
      verification: verification == null && nullToAbsent
          ? const Value.absent()
          : Value(verification),
      type: type == null && nullToAbsent ? const Value.absent() : Value(type),
      numventes1: numventes1 == null && nullToAbsent
          ? const Value.absent()
          : Value(numventes1),
    );
  }

  factory Retvente.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Retvente(
      num: serializer.fromJson<int>(json['num']),
      numventes: serializer.fromJson<String?>(json['numventes']),
      nfact: serializer.fromJson<String?>(json['nfact']),
      daty: serializer.fromJson<DateTime?>(json['daty']),
      clt: serializer.fromJson<String?>(json['clt']),
      modepai: serializer.fromJson<String?>(json['modepai']),
      echeance: serializer.fromJson<DateTime?>(json['echeance']),
      totalnt: serializer.fromJson<double?>(json['totalnt']),
      totalttc: serializer.fromJson<double?>(json['totalttc']),
      tva: serializer.fromJson<double?>(json['tva']),
      contre: serializer.fromJson<String?>(json['contre']),
      avance: serializer.fromJson<double?>(json['avance']),
      bq: serializer.fromJson<String?>(json['bq']),
      commerc: serializer.fromJson<String?>(json['commerc']),
      commission: serializer.fromJson<double?>(json['commission']),
      remise: serializer.fromJson<double?>(json['remise']),
      verification: serializer.fromJson<String?>(json['verification']),
      type: serializer.fromJson<String?>(json['type']),
      numventes1: serializer.fromJson<String?>(json['numventes1']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'num': serializer.toJson<int>(num),
      'numventes': serializer.toJson<String?>(numventes),
      'nfact': serializer.toJson<String?>(nfact),
      'daty': serializer.toJson<DateTime?>(daty),
      'clt': serializer.toJson<String?>(clt),
      'modepai': serializer.toJson<String?>(modepai),
      'echeance': serializer.toJson<DateTime?>(echeance),
      'totalnt': serializer.toJson<double?>(totalnt),
      'totalttc': serializer.toJson<double?>(totalttc),
      'tva': serializer.toJson<double?>(tva),
      'contre': serializer.toJson<String?>(contre),
      'avance': serializer.toJson<double?>(avance),
      'bq': serializer.toJson<String?>(bq),
      'commerc': serializer.toJson<String?>(commerc),
      'commission': serializer.toJson<double?>(commission),
      'remise': serializer.toJson<double?>(remise),
      'verification': serializer.toJson<String?>(verification),
      'type': serializer.toJson<String?>(type),
      'numventes1': serializer.toJson<String?>(numventes1),
    };
  }

  Retvente copyWith(
          {int? num,
          Value<String?> numventes = const Value.absent(),
          Value<String?> nfact = const Value.absent(),
          Value<DateTime?> daty = const Value.absent(),
          Value<String?> clt = const Value.absent(),
          Value<String?> modepai = const Value.absent(),
          Value<DateTime?> echeance = const Value.absent(),
          Value<double?> totalnt = const Value.absent(),
          Value<double?> totalttc = const Value.absent(),
          Value<double?> tva = const Value.absent(),
          Value<String?> contre = const Value.absent(),
          Value<double?> avance = const Value.absent(),
          Value<String?> bq = const Value.absent(),
          Value<String?> commerc = const Value.absent(),
          Value<double?> commission = const Value.absent(),
          Value<double?> remise = const Value.absent(),
          Value<String?> verification = const Value.absent(),
          Value<String?> type = const Value.absent(),
          Value<String?> numventes1 = const Value.absent()}) =>
      Retvente(
        num: num ?? this.num,
        numventes: numventes.present ? numventes.value : this.numventes,
        nfact: nfact.present ? nfact.value : this.nfact,
        daty: daty.present ? daty.value : this.daty,
        clt: clt.present ? clt.value : this.clt,
        modepai: modepai.present ? modepai.value : this.modepai,
        echeance: echeance.present ? echeance.value : this.echeance,
        totalnt: totalnt.present ? totalnt.value : this.totalnt,
        totalttc: totalttc.present ? totalttc.value : this.totalttc,
        tva: tva.present ? tva.value : this.tva,
        contre: contre.present ? contre.value : this.contre,
        avance: avance.present ? avance.value : this.avance,
        bq: bq.present ? bq.value : this.bq,
        commerc: commerc.present ? commerc.value : this.commerc,
        commission: commission.present ? commission.value : this.commission,
        remise: remise.present ? remise.value : this.remise,
        verification:
            verification.present ? verification.value : this.verification,
        type: type.present ? type.value : this.type,
        numventes1: numventes1.present ? numventes1.value : this.numventes1,
      );
  Retvente copyWithCompanion(RetventesCompanion data) {
    return Retvente(
      num: data.num.present ? data.num.value : this.num,
      numventes: data.numventes.present ? data.numventes.value : this.numventes,
      nfact: data.nfact.present ? data.nfact.value : this.nfact,
      daty: data.daty.present ? data.daty.value : this.daty,
      clt: data.clt.present ? data.clt.value : this.clt,
      modepai: data.modepai.present ? data.modepai.value : this.modepai,
      echeance: data.echeance.present ? data.echeance.value : this.echeance,
      totalnt: data.totalnt.present ? data.totalnt.value : this.totalnt,
      totalttc: data.totalttc.present ? data.totalttc.value : this.totalttc,
      tva: data.tva.present ? data.tva.value : this.tva,
      contre: data.contre.present ? data.contre.value : this.contre,
      avance: data.avance.present ? data.avance.value : this.avance,
      bq: data.bq.present ? data.bq.value : this.bq,
      commerc: data.commerc.present ? data.commerc.value : this.commerc,
      commission:
          data.commission.present ? data.commission.value : this.commission,
      remise: data.remise.present ? data.remise.value : this.remise,
      verification: data.verification.present
          ? data.verification.value
          : this.verification,
      type: data.type.present ? data.type.value : this.type,
      numventes1:
          data.numventes1.present ? data.numventes1.value : this.numventes1,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Retvente(')
          ..write('num: $num, ')
          ..write('numventes: $numventes, ')
          ..write('nfact: $nfact, ')
          ..write('daty: $daty, ')
          ..write('clt: $clt, ')
          ..write('modepai: $modepai, ')
          ..write('echeance: $echeance, ')
          ..write('totalnt: $totalnt, ')
          ..write('totalttc: $totalttc, ')
          ..write('tva: $tva, ')
          ..write('contre: $contre, ')
          ..write('avance: $avance, ')
          ..write('bq: $bq, ')
          ..write('commerc: $commerc, ')
          ..write('commission: $commission, ')
          ..write('remise: $remise, ')
          ..write('verification: $verification, ')
          ..write('type: $type, ')
          ..write('numventes1: $numventes1')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      num,
      numventes,
      nfact,
      daty,
      clt,
      modepai,
      echeance,
      totalnt,
      totalttc,
      tva,
      contre,
      avance,
      bq,
      commerc,
      commission,
      remise,
      verification,
      type,
      numventes1);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Retvente &&
          other.num == this.num &&
          other.numventes == this.numventes &&
          other.nfact == this.nfact &&
          other.daty == this.daty &&
          other.clt == this.clt &&
          other.modepai == this.modepai &&
          other.echeance == this.echeance &&
          other.totalnt == this.totalnt &&
          other.totalttc == this.totalttc &&
          other.tva == this.tva &&
          other.contre == this.contre &&
          other.avance == this.avance &&
          other.bq == this.bq &&
          other.commerc == this.commerc &&
          other.commission == this.commission &&
          other.remise == this.remise &&
          other.verification == this.verification &&
          other.type == this.type &&
          other.numventes1 == this.numventes1);
}

class RetventesCompanion extends UpdateCompanion<Retvente> {
  final Value<int> num;
  final Value<String?> numventes;
  final Value<String?> nfact;
  final Value<DateTime?> daty;
  final Value<String?> clt;
  final Value<String?> modepai;
  final Value<DateTime?> echeance;
  final Value<double?> totalnt;
  final Value<double?> totalttc;
  final Value<double?> tva;
  final Value<String?> contre;
  final Value<double?> avance;
  final Value<String?> bq;
  final Value<String?> commerc;
  final Value<double?> commission;
  final Value<double?> remise;
  final Value<String?> verification;
  final Value<String?> type;
  final Value<String?> numventes1;
  const RetventesCompanion({
    this.num = const Value.absent(),
    this.numventes = const Value.absent(),
    this.nfact = const Value.absent(),
    this.daty = const Value.absent(),
    this.clt = const Value.absent(),
    this.modepai = const Value.absent(),
    this.echeance = const Value.absent(),
    this.totalnt = const Value.absent(),
    this.totalttc = const Value.absent(),
    this.tva = const Value.absent(),
    this.contre = const Value.absent(),
    this.avance = const Value.absent(),
    this.bq = const Value.absent(),
    this.commerc = const Value.absent(),
    this.commission = const Value.absent(),
    this.remise = const Value.absent(),
    this.verification = const Value.absent(),
    this.type = const Value.absent(),
    this.numventes1 = const Value.absent(),
  });
  RetventesCompanion.insert({
    this.num = const Value.absent(),
    this.numventes = const Value.absent(),
    this.nfact = const Value.absent(),
    this.daty = const Value.absent(),
    this.clt = const Value.absent(),
    this.modepai = const Value.absent(),
    this.echeance = const Value.absent(),
    this.totalnt = const Value.absent(),
    this.totalttc = const Value.absent(),
    this.tva = const Value.absent(),
    this.contre = const Value.absent(),
    this.avance = const Value.absent(),
    this.bq = const Value.absent(),
    this.commerc = const Value.absent(),
    this.commission = const Value.absent(),
    this.remise = const Value.absent(),
    this.verification = const Value.absent(),
    this.type = const Value.absent(),
    this.numventes1 = const Value.absent(),
  });
  static Insertable<Retvente> custom({
    Expression<int>? num,
    Expression<String>? numventes,
    Expression<String>? nfact,
    Expression<DateTime>? daty,
    Expression<String>? clt,
    Expression<String>? modepai,
    Expression<DateTime>? echeance,
    Expression<double>? totalnt,
    Expression<double>? totalttc,
    Expression<double>? tva,
    Expression<String>? contre,
    Expression<double>? avance,
    Expression<String>? bq,
    Expression<String>? commerc,
    Expression<double>? commission,
    Expression<double>? remise,
    Expression<String>? verification,
    Expression<String>? type,
    Expression<String>? numventes1,
  }) {
    return RawValuesInsertable({
      if (num != null) 'num': num,
      if (numventes != null) 'numventes': numventes,
      if (nfact != null) 'nfact': nfact,
      if (daty != null) 'daty': daty,
      if (clt != null) 'clt': clt,
      if (modepai != null) 'modepai': modepai,
      if (echeance != null) 'echeance': echeance,
      if (totalnt != null) 'totalnt': totalnt,
      if (totalttc != null) 'totalttc': totalttc,
      if (tva != null) 'tva': tva,
      if (contre != null) 'contre': contre,
      if (avance != null) 'avance': avance,
      if (bq != null) 'bq': bq,
      if (commerc != null) 'commerc': commerc,
      if (commission != null) 'commission': commission,
      if (remise != null) 'remise': remise,
      if (verification != null) 'verification': verification,
      if (type != null) 'type': type,
      if (numventes1 != null) 'numventes1': numventes1,
    });
  }

  RetventesCompanion copyWith(
      {Value<int>? num,
      Value<String?>? numventes,
      Value<String?>? nfact,
      Value<DateTime?>? daty,
      Value<String?>? clt,
      Value<String?>? modepai,
      Value<DateTime?>? echeance,
      Value<double?>? totalnt,
      Value<double?>? totalttc,
      Value<double?>? tva,
      Value<String?>? contre,
      Value<double?>? avance,
      Value<String?>? bq,
      Value<String?>? commerc,
      Value<double?>? commission,
      Value<double?>? remise,
      Value<String?>? verification,
      Value<String?>? type,
      Value<String?>? numventes1}) {
    return RetventesCompanion(
      num: num ?? this.num,
      numventes: numventes ?? this.numventes,
      nfact: nfact ?? this.nfact,
      daty: daty ?? this.daty,
      clt: clt ?? this.clt,
      modepai: modepai ?? this.modepai,
      echeance: echeance ?? this.echeance,
      totalnt: totalnt ?? this.totalnt,
      totalttc: totalttc ?? this.totalttc,
      tva: tva ?? this.tva,
      contre: contre ?? this.contre,
      avance: avance ?? this.avance,
      bq: bq ?? this.bq,
      commerc: commerc ?? this.commerc,
      commission: commission ?? this.commission,
      remise: remise ?? this.remise,
      verification: verification ?? this.verification,
      type: type ?? this.type,
      numventes1: numventes1 ?? this.numventes1,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (num.present) {
      map['num'] = Variable<int>(num.value);
    }
    if (numventes.present) {
      map['numventes'] = Variable<String>(numventes.value);
    }
    if (nfact.present) {
      map['nfact'] = Variable<String>(nfact.value);
    }
    if (daty.present) {
      map['daty'] = Variable<DateTime>(daty.value);
    }
    if (clt.present) {
      map['clt'] = Variable<String>(clt.value);
    }
    if (modepai.present) {
      map['modepai'] = Variable<String>(modepai.value);
    }
    if (echeance.present) {
      map['echeance'] = Variable<DateTime>(echeance.value);
    }
    if (totalnt.present) {
      map['totalnt'] = Variable<double>(totalnt.value);
    }
    if (totalttc.present) {
      map['totalttc'] = Variable<double>(totalttc.value);
    }
    if (tva.present) {
      map['tva'] = Variable<double>(tva.value);
    }
    if (contre.present) {
      map['contre'] = Variable<String>(contre.value);
    }
    if (avance.present) {
      map['avance'] = Variable<double>(avance.value);
    }
    if (bq.present) {
      map['bq'] = Variable<String>(bq.value);
    }
    if (commerc.present) {
      map['commerc'] = Variable<String>(commerc.value);
    }
    if (commission.present) {
      map['commission'] = Variable<double>(commission.value);
    }
    if (remise.present) {
      map['remise'] = Variable<double>(remise.value);
    }
    if (verification.present) {
      map['verification'] = Variable<String>(verification.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (numventes1.present) {
      map['numventes1'] = Variable<String>(numventes1.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('RetventesCompanion(')
          ..write('num: $num, ')
          ..write('numventes: $numventes, ')
          ..write('nfact: $nfact, ')
          ..write('daty: $daty, ')
          ..write('clt: $clt, ')
          ..write('modepai: $modepai, ')
          ..write('echeance: $echeance, ')
          ..write('totalnt: $totalnt, ')
          ..write('totalttc: $totalttc, ')
          ..write('tva: $tva, ')
          ..write('contre: $contre, ')
          ..write('avance: $avance, ')
          ..write('bq: $bq, ')
          ..write('commerc: $commerc, ')
          ..write('commission: $commission, ')
          ..write('remise: $remise, ')
          ..write('verification: $verification, ')
          ..write('type: $type, ')
          ..write('numventes1: $numventes1')
          ..write(')'))
        .toString();
  }
}

class $SintrantTable extends Sintrant
    with TableInfo<$SintrantTable, SintrantData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SintrantTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _desMeta = const VerificationMeta('des');
  @override
  late final GeneratedColumn<String> des = GeneratedColumn<String>(
      'des', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _qMeta = const VerificationMeta('q');
  @override
  late final GeneratedColumn<double> q = GeneratedColumn<double>(
      'q', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [des, q];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sintrant';
  @override
  VerificationContext validateIntegrity(Insertable<SintrantData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('des')) {
      context.handle(
          _desMeta, des.isAcceptableOrUnknown(data['des']!, _desMeta));
    } else if (isInserting) {
      context.missing(_desMeta);
    }
    if (data.containsKey('q')) {
      context.handle(_qMeta, q.isAcceptableOrUnknown(data['q']!, _qMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {des};
  @override
  SintrantData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SintrantData(
      des: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}des'])!,
      q: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}q']),
    );
  }

  @override
  $SintrantTable createAlias(String alias) {
    return $SintrantTable(attachedDatabase, alias);
  }
}

class SintrantData extends DataClass implements Insertable<SintrantData> {
  final String des;
  final double? q;
  const SintrantData({required this.des, this.q});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['des'] = Variable<String>(des);
    if (!nullToAbsent || q != null) {
      map['q'] = Variable<double>(q);
    }
    return map;
  }

  SintrantCompanion toCompanion(bool nullToAbsent) {
    return SintrantCompanion(
      des: Value(des),
      q: q == null && nullToAbsent ? const Value.absent() : Value(q),
    );
  }

  factory SintrantData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SintrantData(
      des: serializer.fromJson<String>(json['des']),
      q: serializer.fromJson<double?>(json['q']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'des': serializer.toJson<String>(des),
      'q': serializer.toJson<double?>(q),
    };
  }

  SintrantData copyWith(
          {String? des, Value<double?> q = const Value.absent()}) =>
      SintrantData(
        des: des ?? this.des,
        q: q.present ? q.value : this.q,
      );
  SintrantData copyWithCompanion(SintrantCompanion data) {
    return SintrantData(
      des: data.des.present ? data.des.value : this.des,
      q: data.q.present ? data.q.value : this.q,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SintrantData(')
          ..write('des: $des, ')
          ..write('q: $q')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(des, q);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SintrantData && other.des == this.des && other.q == this.q);
}

class SintrantCompanion extends UpdateCompanion<SintrantData> {
  final Value<String> des;
  final Value<double?> q;
  final Value<int> rowid;
  const SintrantCompanion({
    this.des = const Value.absent(),
    this.q = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SintrantCompanion.insert({
    required String des,
    this.q = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : des = Value(des);
  static Insertable<SintrantData> custom({
    Expression<String>? des,
    Expression<double>? q,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (des != null) 'des': des,
      if (q != null) 'q': q,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SintrantCompanion copyWith(
      {Value<String>? des, Value<double?>? q, Value<int>? rowid}) {
    return SintrantCompanion(
      des: des ?? this.des,
      q: q ?? this.q,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (des.present) {
      map['des'] = Variable<String>(des.value);
    }
    if (q.present) {
      map['q'] = Variable<double>(q.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SintrantCompanion(')
          ..write('des: $des, ')
          ..write('q: $q, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SproduitTable extends Sproduit
    with TableInfo<$SproduitTable, SproduitData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SproduitTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _desMeta = const VerificationMeta('des');
  @override
  late final GeneratedColumn<String> des = GeneratedColumn<String>(
      'des', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _qMeta = const VerificationMeta('q');
  @override
  late final GeneratedColumn<double> q = GeneratedColumn<double>(
      'q', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [des, q];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sproduit';
  @override
  VerificationContext validateIntegrity(Insertable<SproduitData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('des')) {
      context.handle(
          _desMeta, des.isAcceptableOrUnknown(data['des']!, _desMeta));
    } else if (isInserting) {
      context.missing(_desMeta);
    }
    if (data.containsKey('q')) {
      context.handle(_qMeta, q.isAcceptableOrUnknown(data['q']!, _qMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {des};
  @override
  SproduitData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SproduitData(
      des: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}des'])!,
      q: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}q']),
    );
  }

  @override
  $SproduitTable createAlias(String alias) {
    return $SproduitTable(attachedDatabase, alias);
  }
}

class SproduitData extends DataClass implements Insertable<SproduitData> {
  final String des;
  final double? q;
  const SproduitData({required this.des, this.q});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['des'] = Variable<String>(des);
    if (!nullToAbsent || q != null) {
      map['q'] = Variable<double>(q);
    }
    return map;
  }

  SproduitCompanion toCompanion(bool nullToAbsent) {
    return SproduitCompanion(
      des: Value(des),
      q: q == null && nullToAbsent ? const Value.absent() : Value(q),
    );
  }

  factory SproduitData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SproduitData(
      des: serializer.fromJson<String>(json['des']),
      q: serializer.fromJson<double?>(json['q']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'des': serializer.toJson<String>(des),
      'q': serializer.toJson<double?>(q),
    };
  }

  SproduitData copyWith(
          {String? des, Value<double?> q = const Value.absent()}) =>
      SproduitData(
        des: des ?? this.des,
        q: q.present ? q.value : this.q,
      );
  SproduitData copyWithCompanion(SproduitCompanion data) {
    return SproduitData(
      des: data.des.present ? data.des.value : this.des,
      q: data.q.present ? data.q.value : this.q,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SproduitData(')
          ..write('des: $des, ')
          ..write('q: $q')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(des, q);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SproduitData && other.des == this.des && other.q == this.q);
}

class SproduitCompanion extends UpdateCompanion<SproduitData> {
  final Value<String> des;
  final Value<double?> q;
  final Value<int> rowid;
  const SproduitCompanion({
    this.des = const Value.absent(),
    this.q = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SproduitCompanion.insert({
    required String des,
    this.q = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : des = Value(des);
  static Insertable<SproduitData> custom({
    Expression<String>? des,
    Expression<double>? q,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (des != null) 'des': des,
      if (q != null) 'q': q,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SproduitCompanion copyWith(
      {Value<String>? des, Value<double?>? q, Value<int>? rowid}) {
    return SproduitCompanion(
      des: des ?? this.des,
      q: q ?? this.q,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (des.present) {
      map['des'] = Variable<String>(des.value);
    }
    if (q.present) {
      map['q'] = Variable<double>(q.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SproduitCompanion(')
          ..write('des: $des, ')
          ..write('q: $q, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $TblunitTable extends Tblunit with TableInfo<$TblunitTable, TblunitData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $TblunitTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _libMeta = const VerificationMeta('lib');
  @override
  late final GeneratedColumn<String> lib = GeneratedColumn<String>(
      'lib', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [lib];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'tblunit';
  @override
  VerificationContext validateIntegrity(Insertable<TblunitData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('lib')) {
      context.handle(
          _libMeta, lib.isAcceptableOrUnknown(data['lib']!, _libMeta));
    } else if (isInserting) {
      context.missing(_libMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {lib};
  @override
  TblunitData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return TblunitData(
      lib: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}lib'])!,
    );
  }

  @override
  $TblunitTable createAlias(String alias) {
    return $TblunitTable(attachedDatabase, alias);
  }
}

class TblunitData extends DataClass implements Insertable<TblunitData> {
  final String lib;
  const TblunitData({required this.lib});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['lib'] = Variable<String>(lib);
    return map;
  }

  TblunitCompanion toCompanion(bool nullToAbsent) {
    return TblunitCompanion(
      lib: Value(lib),
    );
  }

  factory TblunitData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return TblunitData(
      lib: serializer.fromJson<String>(json['lib']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'lib': serializer.toJson<String>(lib),
    };
  }

  TblunitData copyWith({String? lib}) => TblunitData(
        lib: lib ?? this.lib,
      );
  TblunitData copyWithCompanion(TblunitCompanion data) {
    return TblunitData(
      lib: data.lib.present ? data.lib.value : this.lib,
    );
  }

  @override
  String toString() {
    return (StringBuffer('TblunitData(')
          ..write('lib: $lib')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => lib.hashCode;
  @override
  bool operator ==(Object other) =>
      identical(this, other) || (other is TblunitData && other.lib == this.lib);
}

class TblunitCompanion extends UpdateCompanion<TblunitData> {
  final Value<String> lib;
  final Value<int> rowid;
  const TblunitCompanion({
    this.lib = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  TblunitCompanion.insert({
    required String lib,
    this.rowid = const Value.absent(),
  }) : lib = Value(lib);
  static Insertable<TblunitData> custom({
    Expression<String>? lib,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (lib != null) 'lib': lib,
      if (rowid != null) 'rowid': rowid,
    });
  }

  TblunitCompanion copyWith({Value<String>? lib, Value<int>? rowid}) {
    return TblunitCompanion(
      lib: lib ?? this.lib,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (lib.present) {
      map['lib'] = Variable<String>(lib.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TblunitCompanion(')
          ..write('lib: $lib, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $TransfTable extends Transf with TableInfo<$TransfTable, TransfData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $TransfTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _numMeta = const VerificationMeta('num');
  @override
  late final GeneratedColumn<int> num = GeneratedColumn<int>(
      'num', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _numtransfMeta =
      const VerificationMeta('numtransf');
  @override
  late final GeneratedColumn<String> numtransf = GeneratedColumn<String>(
      'numtransf', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _datyMeta = const VerificationMeta('daty');
  @override
  late final GeneratedColumn<DateTime> daty = GeneratedColumn<DateTime>(
      'daty', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _deMeta = const VerificationMeta('de');
  @override
  late final GeneratedColumn<String> de = GeneratedColumn<String>(
      'de', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _auMeta = const VerificationMeta('au');
  @override
  late final GeneratedColumn<String> au = GeneratedColumn<String>(
      'au', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _contreMeta = const VerificationMeta('contre');
  @override
  late final GeneratedColumn<String> contre = GeneratedColumn<String>(
      'contre', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [num, numtransf, daty, de, au, contre];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'transf';
  @override
  VerificationContext validateIntegrity(Insertable<TransfData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('num')) {
      context.handle(
          _numMeta, num.isAcceptableOrUnknown(data['num']!, _numMeta));
    }
    if (data.containsKey('numtransf')) {
      context.handle(_numtransfMeta,
          numtransf.isAcceptableOrUnknown(data['numtransf']!, _numtransfMeta));
    }
    if (data.containsKey('daty')) {
      context.handle(
          _datyMeta, daty.isAcceptableOrUnknown(data['daty']!, _datyMeta));
    }
    if (data.containsKey('de')) {
      context.handle(_deMeta, de.isAcceptableOrUnknown(data['de']!, _deMeta));
    }
    if (data.containsKey('au')) {
      context.handle(_auMeta, au.isAcceptableOrUnknown(data['au']!, _auMeta));
    }
    if (data.containsKey('contre')) {
      context.handle(_contreMeta,
          contre.isAcceptableOrUnknown(data['contre']!, _contreMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {num};
  @override
  TransfData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return TransfData(
      num: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}num'])!,
      numtransf: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}numtransf']),
      daty: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}daty']),
      de: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}de']),
      au: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}au']),
      contre: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}contre']),
    );
  }

  @override
  $TransfTable createAlias(String alias) {
    return $TransfTable(attachedDatabase, alias);
  }
}

class TransfData extends DataClass implements Insertable<TransfData> {
  final int num;
  final String? numtransf;
  final DateTime? daty;
  final String? de;
  final String? au;
  final String? contre;
  const TransfData(
      {required this.num,
      this.numtransf,
      this.daty,
      this.de,
      this.au,
      this.contre});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['num'] = Variable<int>(num);
    if (!nullToAbsent || numtransf != null) {
      map['numtransf'] = Variable<String>(numtransf);
    }
    if (!nullToAbsent || daty != null) {
      map['daty'] = Variable<DateTime>(daty);
    }
    if (!nullToAbsent || de != null) {
      map['de'] = Variable<String>(de);
    }
    if (!nullToAbsent || au != null) {
      map['au'] = Variable<String>(au);
    }
    if (!nullToAbsent || contre != null) {
      map['contre'] = Variable<String>(contre);
    }
    return map;
  }

  TransfCompanion toCompanion(bool nullToAbsent) {
    return TransfCompanion(
      num: Value(num),
      numtransf: numtransf == null && nullToAbsent
          ? const Value.absent()
          : Value(numtransf),
      daty: daty == null && nullToAbsent ? const Value.absent() : Value(daty),
      de: de == null && nullToAbsent ? const Value.absent() : Value(de),
      au: au == null && nullToAbsent ? const Value.absent() : Value(au),
      contre:
          contre == null && nullToAbsent ? const Value.absent() : Value(contre),
    );
  }

  factory TransfData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return TransfData(
      num: serializer.fromJson<int>(json['num']),
      numtransf: serializer.fromJson<String?>(json['numtransf']),
      daty: serializer.fromJson<DateTime?>(json['daty']),
      de: serializer.fromJson<String?>(json['de']),
      au: serializer.fromJson<String?>(json['au']),
      contre: serializer.fromJson<String?>(json['contre']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'num': serializer.toJson<int>(num),
      'numtransf': serializer.toJson<String?>(numtransf),
      'daty': serializer.toJson<DateTime?>(daty),
      'de': serializer.toJson<String?>(de),
      'au': serializer.toJson<String?>(au),
      'contre': serializer.toJson<String?>(contre),
    };
  }

  TransfData copyWith(
          {int? num,
          Value<String?> numtransf = const Value.absent(),
          Value<DateTime?> daty = const Value.absent(),
          Value<String?> de = const Value.absent(),
          Value<String?> au = const Value.absent(),
          Value<String?> contre = const Value.absent()}) =>
      TransfData(
        num: num ?? this.num,
        numtransf: numtransf.present ? numtransf.value : this.numtransf,
        daty: daty.present ? daty.value : this.daty,
        de: de.present ? de.value : this.de,
        au: au.present ? au.value : this.au,
        contre: contre.present ? contre.value : this.contre,
      );
  TransfData copyWithCompanion(TransfCompanion data) {
    return TransfData(
      num: data.num.present ? data.num.value : this.num,
      numtransf: data.numtransf.present ? data.numtransf.value : this.numtransf,
      daty: data.daty.present ? data.daty.value : this.daty,
      de: data.de.present ? data.de.value : this.de,
      au: data.au.present ? data.au.value : this.au,
      contre: data.contre.present ? data.contre.value : this.contre,
    );
  }

  @override
  String toString() {
    return (StringBuffer('TransfData(')
          ..write('num: $num, ')
          ..write('numtransf: $numtransf, ')
          ..write('daty: $daty, ')
          ..write('de: $de, ')
          ..write('au: $au, ')
          ..write('contre: $contre')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(num, numtransf, daty, de, au, contre);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is TransfData &&
          other.num == this.num &&
          other.numtransf == this.numtransf &&
          other.daty == this.daty &&
          other.de == this.de &&
          other.au == this.au &&
          other.contre == this.contre);
}

class TransfCompanion extends UpdateCompanion<TransfData> {
  final Value<int> num;
  final Value<String?> numtransf;
  final Value<DateTime?> daty;
  final Value<String?> de;
  final Value<String?> au;
  final Value<String?> contre;
  const TransfCompanion({
    this.num = const Value.absent(),
    this.numtransf = const Value.absent(),
    this.daty = const Value.absent(),
    this.de = const Value.absent(),
    this.au = const Value.absent(),
    this.contre = const Value.absent(),
  });
  TransfCompanion.insert({
    this.num = const Value.absent(),
    this.numtransf = const Value.absent(),
    this.daty = const Value.absent(),
    this.de = const Value.absent(),
    this.au = const Value.absent(),
    this.contre = const Value.absent(),
  });
  static Insertable<TransfData> custom({
    Expression<int>? num,
    Expression<String>? numtransf,
    Expression<DateTime>? daty,
    Expression<String>? de,
    Expression<String>? au,
    Expression<String>? contre,
  }) {
    return RawValuesInsertable({
      if (num != null) 'num': num,
      if (numtransf != null) 'numtransf': numtransf,
      if (daty != null) 'daty': daty,
      if (de != null) 'de': de,
      if (au != null) 'au': au,
      if (contre != null) 'contre': contre,
    });
  }

  TransfCompanion copyWith(
      {Value<int>? num,
      Value<String?>? numtransf,
      Value<DateTime?>? daty,
      Value<String?>? de,
      Value<String?>? au,
      Value<String?>? contre}) {
    return TransfCompanion(
      num: num ?? this.num,
      numtransf: numtransf ?? this.numtransf,
      daty: daty ?? this.daty,
      de: de ?? this.de,
      au: au ?? this.au,
      contre: contre ?? this.contre,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (num.present) {
      map['num'] = Variable<int>(num.value);
    }
    if (numtransf.present) {
      map['numtransf'] = Variable<String>(numtransf.value);
    }
    if (daty.present) {
      map['daty'] = Variable<DateTime>(daty.value);
    }
    if (de.present) {
      map['de'] = Variable<String>(de.value);
    }
    if (au.present) {
      map['au'] = Variable<String>(au.value);
    }
    if (contre.present) {
      map['contre'] = Variable<String>(contre.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TransfCompanion(')
          ..write('num: $num, ')
          ..write('numtransf: $numtransf, ')
          ..write('daty: $daty, ')
          ..write('de: $de, ')
          ..write('au: $au, ')
          ..write('contre: $contre')
          ..write(')'))
        .toString();
  }
}

class $TribanqueTable extends Tribanque
    with TableInfo<$TribanqueTable, TribanqueData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $TribanqueTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _refMeta = const VerificationMeta('ref');
  @override
  late final GeneratedColumn<String> ref = GeneratedColumn<String>(
      'ref', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _datyMeta = const VerificationMeta('daty');
  @override
  late final GeneratedColumn<DateTime> daty = GeneratedColumn<DateTime>(
      'daty', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _libMeta = const VerificationMeta('lib');
  @override
  late final GeneratedColumn<String> lib = GeneratedColumn<String>(
      'lib', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _debitMeta = const VerificationMeta('debit');
  @override
  late final GeneratedColumn<double> debit = GeneratedColumn<double>(
      'debit', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _creditMeta = const VerificationMeta('credit');
  @override
  late final GeneratedColumn<double> credit = GeneratedColumn<double>(
      'credit', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _soldesMeta = const VerificationMeta('soldes');
  @override
  late final GeneratedColumn<double> soldes = GeneratedColumn<double>(
      'soldes', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns =>
      [ref, daty, lib, debit, credit, soldes, code];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'tribanque';
  @override
  VerificationContext validateIntegrity(Insertable<TribanqueData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('ref')) {
      context.handle(
          _refMeta, ref.isAcceptableOrUnknown(data['ref']!, _refMeta));
    } else if (isInserting) {
      context.missing(_refMeta);
    }
    if (data.containsKey('daty')) {
      context.handle(
          _datyMeta, daty.isAcceptableOrUnknown(data['daty']!, _datyMeta));
    }
    if (data.containsKey('lib')) {
      context.handle(
          _libMeta, lib.isAcceptableOrUnknown(data['lib']!, _libMeta));
    }
    if (data.containsKey('debit')) {
      context.handle(
          _debitMeta, debit.isAcceptableOrUnknown(data['debit']!, _debitMeta));
    }
    if (data.containsKey('credit')) {
      context.handle(_creditMeta,
          credit.isAcceptableOrUnknown(data['credit']!, _creditMeta));
    }
    if (data.containsKey('soldes')) {
      context.handle(_soldesMeta,
          soldes.isAcceptableOrUnknown(data['soldes']!, _soldesMeta));
    }
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {ref};
  @override
  TribanqueData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return TribanqueData(
      ref: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}ref'])!,
      daty: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}daty']),
      lib: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}lib']),
      debit: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}debit']),
      credit: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}credit']),
      soldes: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}soldes']),
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code']),
    );
  }

  @override
  $TribanqueTable createAlias(String alias) {
    return $TribanqueTable(attachedDatabase, alias);
  }
}

class TribanqueData extends DataClass implements Insertable<TribanqueData> {
  final String ref;
  final DateTime? daty;
  final String? lib;
  final double? debit;
  final double? credit;
  final double? soldes;
  final String? code;
  const TribanqueData(
      {required this.ref,
      this.daty,
      this.lib,
      this.debit,
      this.credit,
      this.soldes,
      this.code});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['ref'] = Variable<String>(ref);
    if (!nullToAbsent || daty != null) {
      map['daty'] = Variable<DateTime>(daty);
    }
    if (!nullToAbsent || lib != null) {
      map['lib'] = Variable<String>(lib);
    }
    if (!nullToAbsent || debit != null) {
      map['debit'] = Variable<double>(debit);
    }
    if (!nullToAbsent || credit != null) {
      map['credit'] = Variable<double>(credit);
    }
    if (!nullToAbsent || soldes != null) {
      map['soldes'] = Variable<double>(soldes);
    }
    if (!nullToAbsent || code != null) {
      map['code'] = Variable<String>(code);
    }
    return map;
  }

  TribanqueCompanion toCompanion(bool nullToAbsent) {
    return TribanqueCompanion(
      ref: Value(ref),
      daty: daty == null && nullToAbsent ? const Value.absent() : Value(daty),
      lib: lib == null && nullToAbsent ? const Value.absent() : Value(lib),
      debit:
          debit == null && nullToAbsent ? const Value.absent() : Value(debit),
      credit:
          credit == null && nullToAbsent ? const Value.absent() : Value(credit),
      soldes:
          soldes == null && nullToAbsent ? const Value.absent() : Value(soldes),
      code: code == null && nullToAbsent ? const Value.absent() : Value(code),
    );
  }

  factory TribanqueData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return TribanqueData(
      ref: serializer.fromJson<String>(json['ref']),
      daty: serializer.fromJson<DateTime?>(json['daty']),
      lib: serializer.fromJson<String?>(json['lib']),
      debit: serializer.fromJson<double?>(json['debit']),
      credit: serializer.fromJson<double?>(json['credit']),
      soldes: serializer.fromJson<double?>(json['soldes']),
      code: serializer.fromJson<String?>(json['code']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'ref': serializer.toJson<String>(ref),
      'daty': serializer.toJson<DateTime?>(daty),
      'lib': serializer.toJson<String?>(lib),
      'debit': serializer.toJson<double?>(debit),
      'credit': serializer.toJson<double?>(credit),
      'soldes': serializer.toJson<double?>(soldes),
      'code': serializer.toJson<String?>(code),
    };
  }

  TribanqueData copyWith(
          {String? ref,
          Value<DateTime?> daty = const Value.absent(),
          Value<String?> lib = const Value.absent(),
          Value<double?> debit = const Value.absent(),
          Value<double?> credit = const Value.absent(),
          Value<double?> soldes = const Value.absent(),
          Value<String?> code = const Value.absent()}) =>
      TribanqueData(
        ref: ref ?? this.ref,
        daty: daty.present ? daty.value : this.daty,
        lib: lib.present ? lib.value : this.lib,
        debit: debit.present ? debit.value : this.debit,
        credit: credit.present ? credit.value : this.credit,
        soldes: soldes.present ? soldes.value : this.soldes,
        code: code.present ? code.value : this.code,
      );
  TribanqueData copyWithCompanion(TribanqueCompanion data) {
    return TribanqueData(
      ref: data.ref.present ? data.ref.value : this.ref,
      daty: data.daty.present ? data.daty.value : this.daty,
      lib: data.lib.present ? data.lib.value : this.lib,
      debit: data.debit.present ? data.debit.value : this.debit,
      credit: data.credit.present ? data.credit.value : this.credit,
      soldes: data.soldes.present ? data.soldes.value : this.soldes,
      code: data.code.present ? data.code.value : this.code,
    );
  }

  @override
  String toString() {
    return (StringBuffer('TribanqueData(')
          ..write('ref: $ref, ')
          ..write('daty: $daty, ')
          ..write('lib: $lib, ')
          ..write('debit: $debit, ')
          ..write('credit: $credit, ')
          ..write('soldes: $soldes, ')
          ..write('code: $code')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(ref, daty, lib, debit, credit, soldes, code);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is TribanqueData &&
          other.ref == this.ref &&
          other.daty == this.daty &&
          other.lib == this.lib &&
          other.debit == this.debit &&
          other.credit == this.credit &&
          other.soldes == this.soldes &&
          other.code == this.code);
}

class TribanqueCompanion extends UpdateCompanion<TribanqueData> {
  final Value<String> ref;
  final Value<DateTime?> daty;
  final Value<String?> lib;
  final Value<double?> debit;
  final Value<double?> credit;
  final Value<double?> soldes;
  final Value<String?> code;
  final Value<int> rowid;
  const TribanqueCompanion({
    this.ref = const Value.absent(),
    this.daty = const Value.absent(),
    this.lib = const Value.absent(),
    this.debit = const Value.absent(),
    this.credit = const Value.absent(),
    this.soldes = const Value.absent(),
    this.code = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  TribanqueCompanion.insert({
    required String ref,
    this.daty = const Value.absent(),
    this.lib = const Value.absent(),
    this.debit = const Value.absent(),
    this.credit = const Value.absent(),
    this.soldes = const Value.absent(),
    this.code = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : ref = Value(ref);
  static Insertable<TribanqueData> custom({
    Expression<String>? ref,
    Expression<DateTime>? daty,
    Expression<String>? lib,
    Expression<double>? debit,
    Expression<double>? credit,
    Expression<double>? soldes,
    Expression<String>? code,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (ref != null) 'ref': ref,
      if (daty != null) 'daty': daty,
      if (lib != null) 'lib': lib,
      if (debit != null) 'debit': debit,
      if (credit != null) 'credit': credit,
      if (soldes != null) 'soldes': soldes,
      if (code != null) 'code': code,
      if (rowid != null) 'rowid': rowid,
    });
  }

  TribanqueCompanion copyWith(
      {Value<String>? ref,
      Value<DateTime?>? daty,
      Value<String?>? lib,
      Value<double?>? debit,
      Value<double?>? credit,
      Value<double?>? soldes,
      Value<String?>? code,
      Value<int>? rowid}) {
    return TribanqueCompanion(
      ref: ref ?? this.ref,
      daty: daty ?? this.daty,
      lib: lib ?? this.lib,
      debit: debit ?? this.debit,
      credit: credit ?? this.credit,
      soldes: soldes ?? this.soldes,
      code: code ?? this.code,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (ref.present) {
      map['ref'] = Variable<String>(ref.value);
    }
    if (daty.present) {
      map['daty'] = Variable<DateTime>(daty.value);
    }
    if (lib.present) {
      map['lib'] = Variable<String>(lib.value);
    }
    if (debit.present) {
      map['debit'] = Variable<double>(debit.value);
    }
    if (credit.present) {
      map['credit'] = Variable<double>(credit.value);
    }
    if (soldes.present) {
      map['soldes'] = Variable<double>(soldes.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TribanqueCompanion(')
          ..write('ref: $ref, ')
          ..write('daty: $daty, ')
          ..write('lib: $lib, ')
          ..write('debit: $debit, ')
          ..write('credit: $credit, ')
          ..write('soldes: $soldes, ')
          ..write('code: $code, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $TricaisseTable extends Tricaisse
    with TableInfo<$TricaisseTable, TricaisseData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $TricaisseTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _refMeta = const VerificationMeta('ref');
  @override
  late final GeneratedColumn<String> ref = GeneratedColumn<String>(
      'ref', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 50),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _datyMeta = const VerificationMeta('daty');
  @override
  late final GeneratedColumn<DateTime> daty = GeneratedColumn<DateTime>(
      'daty', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _libMeta = const VerificationMeta('lib');
  @override
  late final GeneratedColumn<String> lib = GeneratedColumn<String>(
      'lib', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _debitMeta = const VerificationMeta('debit');
  @override
  late final GeneratedColumn<double> debit = GeneratedColumn<double>(
      'debit', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _creditMeta = const VerificationMeta('credit');
  @override
  late final GeneratedColumn<double> credit = GeneratedColumn<double>(
      'credit', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _soldesMeta = const VerificationMeta('soldes');
  @override
  late final GeneratedColumn<double> soldes = GeneratedColumn<double>(
      'soldes', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [ref, daty, lib, debit, credit, soldes];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'tricaisse';
  @override
  VerificationContext validateIntegrity(Insertable<TricaisseData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('ref')) {
      context.handle(
          _refMeta, ref.isAcceptableOrUnknown(data['ref']!, _refMeta));
    } else if (isInserting) {
      context.missing(_refMeta);
    }
    if (data.containsKey('daty')) {
      context.handle(
          _datyMeta, daty.isAcceptableOrUnknown(data['daty']!, _datyMeta));
    }
    if (data.containsKey('lib')) {
      context.handle(
          _libMeta, lib.isAcceptableOrUnknown(data['lib']!, _libMeta));
    }
    if (data.containsKey('debit')) {
      context.handle(
          _debitMeta, debit.isAcceptableOrUnknown(data['debit']!, _debitMeta));
    }
    if (data.containsKey('credit')) {
      context.handle(_creditMeta,
          credit.isAcceptableOrUnknown(data['credit']!, _creditMeta));
    }
    if (data.containsKey('soldes')) {
      context.handle(_soldesMeta,
          soldes.isAcceptableOrUnknown(data['soldes']!, _soldesMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {ref};
  @override
  TricaisseData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return TricaisseData(
      ref: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}ref'])!,
      daty: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}daty']),
      lib: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}lib']),
      debit: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}debit']),
      credit: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}credit']),
      soldes: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}soldes']),
    );
  }

  @override
  $TricaisseTable createAlias(String alias) {
    return $TricaisseTable(attachedDatabase, alias);
  }
}

class TricaisseData extends DataClass implements Insertable<TricaisseData> {
  final String ref;
  final DateTime? daty;
  final String? lib;
  final double? debit;
  final double? credit;
  final double? soldes;
  const TricaisseData(
      {required this.ref,
      this.daty,
      this.lib,
      this.debit,
      this.credit,
      this.soldes});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['ref'] = Variable<String>(ref);
    if (!nullToAbsent || daty != null) {
      map['daty'] = Variable<DateTime>(daty);
    }
    if (!nullToAbsent || lib != null) {
      map['lib'] = Variable<String>(lib);
    }
    if (!nullToAbsent || debit != null) {
      map['debit'] = Variable<double>(debit);
    }
    if (!nullToAbsent || credit != null) {
      map['credit'] = Variable<double>(credit);
    }
    if (!nullToAbsent || soldes != null) {
      map['soldes'] = Variable<double>(soldes);
    }
    return map;
  }

  TricaisseCompanion toCompanion(bool nullToAbsent) {
    return TricaisseCompanion(
      ref: Value(ref),
      daty: daty == null && nullToAbsent ? const Value.absent() : Value(daty),
      lib: lib == null && nullToAbsent ? const Value.absent() : Value(lib),
      debit:
          debit == null && nullToAbsent ? const Value.absent() : Value(debit),
      credit:
          credit == null && nullToAbsent ? const Value.absent() : Value(credit),
      soldes:
          soldes == null && nullToAbsent ? const Value.absent() : Value(soldes),
    );
  }

  factory TricaisseData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return TricaisseData(
      ref: serializer.fromJson<String>(json['ref']),
      daty: serializer.fromJson<DateTime?>(json['daty']),
      lib: serializer.fromJson<String?>(json['lib']),
      debit: serializer.fromJson<double?>(json['debit']),
      credit: serializer.fromJson<double?>(json['credit']),
      soldes: serializer.fromJson<double?>(json['soldes']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'ref': serializer.toJson<String>(ref),
      'daty': serializer.toJson<DateTime?>(daty),
      'lib': serializer.toJson<String?>(lib),
      'debit': serializer.toJson<double?>(debit),
      'credit': serializer.toJson<double?>(credit),
      'soldes': serializer.toJson<double?>(soldes),
    };
  }

  TricaisseData copyWith(
          {String? ref,
          Value<DateTime?> daty = const Value.absent(),
          Value<String?> lib = const Value.absent(),
          Value<double?> debit = const Value.absent(),
          Value<double?> credit = const Value.absent(),
          Value<double?> soldes = const Value.absent()}) =>
      TricaisseData(
        ref: ref ?? this.ref,
        daty: daty.present ? daty.value : this.daty,
        lib: lib.present ? lib.value : this.lib,
        debit: debit.present ? debit.value : this.debit,
        credit: credit.present ? credit.value : this.credit,
        soldes: soldes.present ? soldes.value : this.soldes,
      );
  TricaisseData copyWithCompanion(TricaisseCompanion data) {
    return TricaisseData(
      ref: data.ref.present ? data.ref.value : this.ref,
      daty: data.daty.present ? data.daty.value : this.daty,
      lib: data.lib.present ? data.lib.value : this.lib,
      debit: data.debit.present ? data.debit.value : this.debit,
      credit: data.credit.present ? data.credit.value : this.credit,
      soldes: data.soldes.present ? data.soldes.value : this.soldes,
    );
  }

  @override
  String toString() {
    return (StringBuffer('TricaisseData(')
          ..write('ref: $ref, ')
          ..write('daty: $daty, ')
          ..write('lib: $lib, ')
          ..write('debit: $debit, ')
          ..write('credit: $credit, ')
          ..write('soldes: $soldes')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(ref, daty, lib, debit, credit, soldes);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is TricaisseData &&
          other.ref == this.ref &&
          other.daty == this.daty &&
          other.lib == this.lib &&
          other.debit == this.debit &&
          other.credit == this.credit &&
          other.soldes == this.soldes);
}

class TricaisseCompanion extends UpdateCompanion<TricaisseData> {
  final Value<String> ref;
  final Value<DateTime?> daty;
  final Value<String?> lib;
  final Value<double?> debit;
  final Value<double?> credit;
  final Value<double?> soldes;
  final Value<int> rowid;
  const TricaisseCompanion({
    this.ref = const Value.absent(),
    this.daty = const Value.absent(),
    this.lib = const Value.absent(),
    this.debit = const Value.absent(),
    this.credit = const Value.absent(),
    this.soldes = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  TricaisseCompanion.insert({
    required String ref,
    this.daty = const Value.absent(),
    this.lib = const Value.absent(),
    this.debit = const Value.absent(),
    this.credit = const Value.absent(),
    this.soldes = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : ref = Value(ref);
  static Insertable<TricaisseData> custom({
    Expression<String>? ref,
    Expression<DateTime>? daty,
    Expression<String>? lib,
    Expression<double>? debit,
    Expression<double>? credit,
    Expression<double>? soldes,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (ref != null) 'ref': ref,
      if (daty != null) 'daty': daty,
      if (lib != null) 'lib': lib,
      if (debit != null) 'debit': debit,
      if (credit != null) 'credit': credit,
      if (soldes != null) 'soldes': soldes,
      if (rowid != null) 'rowid': rowid,
    });
  }

  TricaisseCompanion copyWith(
      {Value<String>? ref,
      Value<DateTime?>? daty,
      Value<String?>? lib,
      Value<double?>? debit,
      Value<double?>? credit,
      Value<double?>? soldes,
      Value<int>? rowid}) {
    return TricaisseCompanion(
      ref: ref ?? this.ref,
      daty: daty ?? this.daty,
      lib: lib ?? this.lib,
      debit: debit ?? this.debit,
      credit: credit ?? this.credit,
      soldes: soldes ?? this.soldes,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (ref.present) {
      map['ref'] = Variable<String>(ref.value);
    }
    if (daty.present) {
      map['daty'] = Variable<DateTime>(daty.value);
    }
    if (lib.present) {
      map['lib'] = Variable<String>(lib.value);
    }
    if (debit.present) {
      map['debit'] = Variable<double>(debit.value);
    }
    if (credit.present) {
      map['credit'] = Variable<double>(credit.value);
    }
    if (soldes.present) {
      map['soldes'] = Variable<double>(soldes.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TricaisseCompanion(')
          ..write('ref: $ref, ')
          ..write('daty: $daty, ')
          ..write('lib: $lib, ')
          ..write('debit: $debit, ')
          ..write('credit: $credit, ')
          ..write('soldes: $soldes, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

abstract class _$AppDatabase extends GeneratedDatabase {
  _$AppDatabase(QueryExecutor e) : super(e);
  $AppDatabaseManager get managers => $AppDatabaseManager(this);
  late final $SocTable soc = $SocTable(this);
  late final $DepotsTable depots = $DepotsTable(this);
  late final $ArticlesTable articles = $ArticlesTable(this);
  late final $CltTable clt = $CltTable(this);
  late final $FrnsTable frns = $FrnsTable(this);
  late final $ComTable com = $ComTable(this);
  late final $VentesTable ventes = $VentesTable(this);
  late final $AchatsTable achats = $AchatsTable(this);
  late final $StocksTable stocks = $StocksTable(this);
  late final $AutrescompteTable autrescompte = $AutrescompteTable(this);
  late final $BanqueTable banque = $BanqueTable(this);
  late final $BlcltTable blclt = $BlcltTable(this);
  late final $BqTable bq = $BqTable(this);
  late final $CaTable ca = $CaTable(this);
  late final $CaisseTable caisse = $CaisseTable(this);
  late final $ChequierTable chequier = $ChequierTable(this);
  late final $CltiTable clti = $CltiTable(this);
  late final $ComptecltTable compteclt = $ComptecltTable(this);
  late final $ComptecomTable comptecom = $ComptecomTable(this);
  late final $ComptefrnsTable comptefrns = $ComptefrnsTable(this);
  late final $DepartTable depart = $DepartTable(this);
  late final $DetachatsTable detachats = $DetachatsTable(this);
  late final $DetprodTable detprod = $DetprodTable(this);
  late final $DettransfTable dettransf = $DettransfTable(this);
  late final $DetventesTable detventes = $DetventesTable(this);
  late final $EffetsTable effets = $EffetsTable(this);
  late final $EmbTable emb = $EmbTable(this);
  late final $EmblcltTable emblclt = $EmblcltTable(this);
  late final $FstocksTable fstocks = $FstocksTable(this);
  late final $MpTable mp = $MpTable(this);
  late final $ProdTable prod = $ProdTable(this);
  late final $PvTable pv = $PvTable(this);
  late final $RetachatsTable retachats = $RetachatsTable(this);
  late final $RetdetachatsTable retdetachats = $RetdetachatsTable(this);
  late final $RetdeventesTable retdeventes = $RetdeventesTable(this);
  late final $RetventesTable retventes = $RetventesTable(this);
  late final $SintrantTable sintrant = $SintrantTable(this);
  late final $SproduitTable sproduit = $SproduitTable(this);
  late final $TblunitTable tblunit = $TblunitTable(this);
  late final $TransfTable transf = $TransfTable(this);
  late final $TribanqueTable tribanque = $TribanqueTable(this);
  late final $TricaisseTable tricaisse = $TricaisseTable(this);
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
        soc,
        depots,
        articles,
        clt,
        frns,
        com,
        ventes,
        achats,
        stocks,
        autrescompte,
        banque,
        blclt,
        bq,
        ca,
        caisse,
        chequier,
        clti,
        compteclt,
        comptecom,
        comptefrns,
        depart,
        detachats,
        detprod,
        dettransf,
        detventes,
        effets,
        emb,
        emblclt,
        fstocks,
        mp,
        prod,
        pv,
        retachats,
        retdetachats,
        retdeventes,
        retventes,
        sintrant,
        sproduit,
        tblunit,
        transf,
        tribanque,
        tricaisse
      ];
}

typedef $$SocTableCreateCompanionBuilder = SocCompanion Function({
  required String ref,
  Value<String?> rsoc,
  Value<String?> activites,
  Value<String?> adr,
  Value<String?> logo,
  Value<double?> capital,
  Value<String?> rcs,
  Value<String?> nif,
  Value<String?> stat,
  Value<String?> tel,
  Value<String?> port,
  Value<String?> email,
  Value<String?> site,
  Value<String?> fax,
  Value<String?> telex,
  Value<double?> tva,
  Value<double?> t,
  Value<String?> val,
  Value<String?> cif,
  Value<int> rowid,
});
typedef $$SocTableUpdateCompanionBuilder = SocCompanion Function({
  Value<String> ref,
  Value<String?> rsoc,
  Value<String?> activites,
  Value<String?> adr,
  Value<String?> logo,
  Value<double?> capital,
  Value<String?> rcs,
  Value<String?> nif,
  Value<String?> stat,
  Value<String?> tel,
  Value<String?> port,
  Value<String?> email,
  Value<String?> site,
  Value<String?> fax,
  Value<String?> telex,
  Value<double?> tva,
  Value<double?> t,
  Value<String?> val,
  Value<String?> cif,
  Value<int> rowid,
});

class $$SocTableFilterComposer extends Composer<_$AppDatabase, $SocTable> {
  $$SocTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get ref => $composableBuilder(
      column: $table.ref, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get rsoc => $composableBuilder(
      column: $table.rsoc, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get activites => $composableBuilder(
      column: $table.activites, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get adr => $composableBuilder(
      column: $table.adr, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get logo => $composableBuilder(
      column: $table.logo, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get capital => $composableBuilder(
      column: $table.capital, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get rcs => $composableBuilder(
      column: $table.rcs, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nif => $composableBuilder(
      column: $table.nif, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get stat => $composableBuilder(
      column: $table.stat, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get tel => $composableBuilder(
      column: $table.tel, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get port => $composableBuilder(
      column: $table.port, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get email => $composableBuilder(
      column: $table.email, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get site => $composableBuilder(
      column: $table.site, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get fax => $composableBuilder(
      column: $table.fax, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get telex => $composableBuilder(
      column: $table.telex, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get tva => $composableBuilder(
      column: $table.tva, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get t => $composableBuilder(
      column: $table.t, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get val => $composableBuilder(
      column: $table.val, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get cif => $composableBuilder(
      column: $table.cif, builder: (column) => ColumnFilters(column));
}

class $$SocTableOrderingComposer extends Composer<_$AppDatabase, $SocTable> {
  $$SocTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get ref => $composableBuilder(
      column: $table.ref, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get rsoc => $composableBuilder(
      column: $table.rsoc, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get activites => $composableBuilder(
      column: $table.activites, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get adr => $composableBuilder(
      column: $table.adr, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get logo => $composableBuilder(
      column: $table.logo, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get capital => $composableBuilder(
      column: $table.capital, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get rcs => $composableBuilder(
      column: $table.rcs, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nif => $composableBuilder(
      column: $table.nif, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get stat => $composableBuilder(
      column: $table.stat, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get tel => $composableBuilder(
      column: $table.tel, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get port => $composableBuilder(
      column: $table.port, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get email => $composableBuilder(
      column: $table.email, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get site => $composableBuilder(
      column: $table.site, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get fax => $composableBuilder(
      column: $table.fax, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get telex => $composableBuilder(
      column: $table.telex, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get tva => $composableBuilder(
      column: $table.tva, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get t => $composableBuilder(
      column: $table.t, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get val => $composableBuilder(
      column: $table.val, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get cif => $composableBuilder(
      column: $table.cif, builder: (column) => ColumnOrderings(column));
}

class $$SocTableAnnotationComposer extends Composer<_$AppDatabase, $SocTable> {
  $$SocTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get ref =>
      $composableBuilder(column: $table.ref, builder: (column) => column);

  GeneratedColumn<String> get rsoc =>
      $composableBuilder(column: $table.rsoc, builder: (column) => column);

  GeneratedColumn<String> get activites =>
      $composableBuilder(column: $table.activites, builder: (column) => column);

  GeneratedColumn<String> get adr =>
      $composableBuilder(column: $table.adr, builder: (column) => column);

  GeneratedColumn<String> get logo =>
      $composableBuilder(column: $table.logo, builder: (column) => column);

  GeneratedColumn<double> get capital =>
      $composableBuilder(column: $table.capital, builder: (column) => column);

  GeneratedColumn<String> get rcs =>
      $composableBuilder(column: $table.rcs, builder: (column) => column);

  GeneratedColumn<String> get nif =>
      $composableBuilder(column: $table.nif, builder: (column) => column);

  GeneratedColumn<String> get stat =>
      $composableBuilder(column: $table.stat, builder: (column) => column);

  GeneratedColumn<String> get tel =>
      $composableBuilder(column: $table.tel, builder: (column) => column);

  GeneratedColumn<String> get port =>
      $composableBuilder(column: $table.port, builder: (column) => column);

  GeneratedColumn<String> get email =>
      $composableBuilder(column: $table.email, builder: (column) => column);

  GeneratedColumn<String> get site =>
      $composableBuilder(column: $table.site, builder: (column) => column);

  GeneratedColumn<String> get fax =>
      $composableBuilder(column: $table.fax, builder: (column) => column);

  GeneratedColumn<String> get telex =>
      $composableBuilder(column: $table.telex, builder: (column) => column);

  GeneratedColumn<double> get tva =>
      $composableBuilder(column: $table.tva, builder: (column) => column);

  GeneratedColumn<double> get t =>
      $composableBuilder(column: $table.t, builder: (column) => column);

  GeneratedColumn<String> get val =>
      $composableBuilder(column: $table.val, builder: (column) => column);

  GeneratedColumn<String> get cif =>
      $composableBuilder(column: $table.cif, builder: (column) => column);
}

class $$SocTableTableManager extends RootTableManager<
    _$AppDatabase,
    $SocTable,
    SocData,
    $$SocTableFilterComposer,
    $$SocTableOrderingComposer,
    $$SocTableAnnotationComposer,
    $$SocTableCreateCompanionBuilder,
    $$SocTableUpdateCompanionBuilder,
    (SocData, BaseReferences<_$AppDatabase, $SocTable, SocData>),
    SocData,
    PrefetchHooks Function()> {
  $$SocTableTableManager(_$AppDatabase db, $SocTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SocTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SocTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SocTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> ref = const Value.absent(),
            Value<String?> rsoc = const Value.absent(),
            Value<String?> activites = const Value.absent(),
            Value<String?> adr = const Value.absent(),
            Value<String?> logo = const Value.absent(),
            Value<double?> capital = const Value.absent(),
            Value<String?> rcs = const Value.absent(),
            Value<String?> nif = const Value.absent(),
            Value<String?> stat = const Value.absent(),
            Value<String?> tel = const Value.absent(),
            Value<String?> port = const Value.absent(),
            Value<String?> email = const Value.absent(),
            Value<String?> site = const Value.absent(),
            Value<String?> fax = const Value.absent(),
            Value<String?> telex = const Value.absent(),
            Value<double?> tva = const Value.absent(),
            Value<double?> t = const Value.absent(),
            Value<String?> val = const Value.absent(),
            Value<String?> cif = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              SocCompanion(
            ref: ref,
            rsoc: rsoc,
            activites: activites,
            adr: adr,
            logo: logo,
            capital: capital,
            rcs: rcs,
            nif: nif,
            stat: stat,
            tel: tel,
            port: port,
            email: email,
            site: site,
            fax: fax,
            telex: telex,
            tva: tva,
            t: t,
            val: val,
            cif: cif,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String ref,
            Value<String?> rsoc = const Value.absent(),
            Value<String?> activites = const Value.absent(),
            Value<String?> adr = const Value.absent(),
            Value<String?> logo = const Value.absent(),
            Value<double?> capital = const Value.absent(),
            Value<String?> rcs = const Value.absent(),
            Value<String?> nif = const Value.absent(),
            Value<String?> stat = const Value.absent(),
            Value<String?> tel = const Value.absent(),
            Value<String?> port = const Value.absent(),
            Value<String?> email = const Value.absent(),
            Value<String?> site = const Value.absent(),
            Value<String?> fax = const Value.absent(),
            Value<String?> telex = const Value.absent(),
            Value<double?> tva = const Value.absent(),
            Value<double?> t = const Value.absent(),
            Value<String?> val = const Value.absent(),
            Value<String?> cif = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              SocCompanion.insert(
            ref: ref,
            rsoc: rsoc,
            activites: activites,
            adr: adr,
            logo: logo,
            capital: capital,
            rcs: rcs,
            nif: nif,
            stat: stat,
            tel: tel,
            port: port,
            email: email,
            site: site,
            fax: fax,
            telex: telex,
            tva: tva,
            t: t,
            val: val,
            cif: cif,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$SocTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $SocTable,
    SocData,
    $$SocTableFilterComposer,
    $$SocTableOrderingComposer,
    $$SocTableAnnotationComposer,
    $$SocTableCreateCompanionBuilder,
    $$SocTableUpdateCompanionBuilder,
    (SocData, BaseReferences<_$AppDatabase, $SocTable, SocData>),
    SocData,
    PrefetchHooks Function()>;
typedef $$DepotsTableCreateCompanionBuilder = DepotsCompanion Function({
  required String depots,
  Value<int> rowid,
});
typedef $$DepotsTableUpdateCompanionBuilder = DepotsCompanion Function({
  Value<String> depots,
  Value<int> rowid,
});

class $$DepotsTableFilterComposer
    extends Composer<_$AppDatabase, $DepotsTable> {
  $$DepotsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get depots => $composableBuilder(
      column: $table.depots, builder: (column) => ColumnFilters(column));
}

class $$DepotsTableOrderingComposer
    extends Composer<_$AppDatabase, $DepotsTable> {
  $$DepotsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get depots => $composableBuilder(
      column: $table.depots, builder: (column) => ColumnOrderings(column));
}

class $$DepotsTableAnnotationComposer
    extends Composer<_$AppDatabase, $DepotsTable> {
  $$DepotsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get depots =>
      $composableBuilder(column: $table.depots, builder: (column) => column);
}

class $$DepotsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $DepotsTable,
    Depot,
    $$DepotsTableFilterComposer,
    $$DepotsTableOrderingComposer,
    $$DepotsTableAnnotationComposer,
    $$DepotsTableCreateCompanionBuilder,
    $$DepotsTableUpdateCompanionBuilder,
    (Depot, BaseReferences<_$AppDatabase, $DepotsTable, Depot>),
    Depot,
    PrefetchHooks Function()> {
  $$DepotsTableTableManager(_$AppDatabase db, $DepotsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$DepotsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$DepotsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$DepotsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> depots = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              DepotsCompanion(
            depots: depots,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String depots,
            Value<int> rowid = const Value.absent(),
          }) =>
              DepotsCompanion.insert(
            depots: depots,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$DepotsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $DepotsTable,
    Depot,
    $$DepotsTableFilterComposer,
    $$DepotsTableOrderingComposer,
    $$DepotsTableAnnotationComposer,
    $$DepotsTableCreateCompanionBuilder,
    $$DepotsTableUpdateCompanionBuilder,
    (Depot, BaseReferences<_$AppDatabase, $DepotsTable, Depot>),
    Depot,
    PrefetchHooks Function()>;
typedef $$ArticlesTableCreateCompanionBuilder = ArticlesCompanion Function({
  required String designation,
  Value<String?> u1,
  Value<String?> u2,
  Value<double?> tu2u1,
  Value<String?> u3,
  Value<double?> tu3u2,
  Value<double?> pvu1,
  Value<double?> pvu2,
  Value<double?> pvu3,
  Value<double?> stocksu1,
  Value<double?> stocksu2,
  Value<double?> stocksu3,
  Value<String?> sec,
  Value<double?> usec,
  Value<double?> cmup,
  Value<String?> dep,
  Value<String?> action,
  Value<String?> categorie,
  Value<String?> classification,
  Value<String?> emb,
  Value<int> rowid,
});
typedef $$ArticlesTableUpdateCompanionBuilder = ArticlesCompanion Function({
  Value<String> designation,
  Value<String?> u1,
  Value<String?> u2,
  Value<double?> tu2u1,
  Value<String?> u3,
  Value<double?> tu3u2,
  Value<double?> pvu1,
  Value<double?> pvu2,
  Value<double?> pvu3,
  Value<double?> stocksu1,
  Value<double?> stocksu2,
  Value<double?> stocksu3,
  Value<String?> sec,
  Value<double?> usec,
  Value<double?> cmup,
  Value<String?> dep,
  Value<String?> action,
  Value<String?> categorie,
  Value<String?> classification,
  Value<String?> emb,
  Value<int> rowid,
});

class $$ArticlesTableFilterComposer
    extends Composer<_$AppDatabase, $ArticlesTable> {
  $$ArticlesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get designation => $composableBuilder(
      column: $table.designation, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get u1 => $composableBuilder(
      column: $table.u1, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get u2 => $composableBuilder(
      column: $table.u2, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get tu2u1 => $composableBuilder(
      column: $table.tu2u1, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get u3 => $composableBuilder(
      column: $table.u3, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get tu3u2 => $composableBuilder(
      column: $table.tu3u2, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get pvu1 => $composableBuilder(
      column: $table.pvu1, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get pvu2 => $composableBuilder(
      column: $table.pvu2, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get pvu3 => $composableBuilder(
      column: $table.pvu3, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get stocksu1 => $composableBuilder(
      column: $table.stocksu1, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get stocksu2 => $composableBuilder(
      column: $table.stocksu2, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get stocksu3 => $composableBuilder(
      column: $table.stocksu3, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get sec => $composableBuilder(
      column: $table.sec, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get usec => $composableBuilder(
      column: $table.usec, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get cmup => $composableBuilder(
      column: $table.cmup, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get dep => $composableBuilder(
      column: $table.dep, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get action => $composableBuilder(
      column: $table.action, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get categorie => $composableBuilder(
      column: $table.categorie, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get classification => $composableBuilder(
      column: $table.classification,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get emb => $composableBuilder(
      column: $table.emb, builder: (column) => ColumnFilters(column));
}

class $$ArticlesTableOrderingComposer
    extends Composer<_$AppDatabase, $ArticlesTable> {
  $$ArticlesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get designation => $composableBuilder(
      column: $table.designation, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get u1 => $composableBuilder(
      column: $table.u1, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get u2 => $composableBuilder(
      column: $table.u2, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get tu2u1 => $composableBuilder(
      column: $table.tu2u1, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get u3 => $composableBuilder(
      column: $table.u3, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get tu3u2 => $composableBuilder(
      column: $table.tu3u2, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get pvu1 => $composableBuilder(
      column: $table.pvu1, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get pvu2 => $composableBuilder(
      column: $table.pvu2, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get pvu3 => $composableBuilder(
      column: $table.pvu3, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get stocksu1 => $composableBuilder(
      column: $table.stocksu1, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get stocksu2 => $composableBuilder(
      column: $table.stocksu2, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get stocksu3 => $composableBuilder(
      column: $table.stocksu3, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get sec => $composableBuilder(
      column: $table.sec, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get usec => $composableBuilder(
      column: $table.usec, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get cmup => $composableBuilder(
      column: $table.cmup, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get dep => $composableBuilder(
      column: $table.dep, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get action => $composableBuilder(
      column: $table.action, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get categorie => $composableBuilder(
      column: $table.categorie, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get classification => $composableBuilder(
      column: $table.classification,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get emb => $composableBuilder(
      column: $table.emb, builder: (column) => ColumnOrderings(column));
}

class $$ArticlesTableAnnotationComposer
    extends Composer<_$AppDatabase, $ArticlesTable> {
  $$ArticlesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get designation => $composableBuilder(
      column: $table.designation, builder: (column) => column);

  GeneratedColumn<String> get u1 =>
      $composableBuilder(column: $table.u1, builder: (column) => column);

  GeneratedColumn<String> get u2 =>
      $composableBuilder(column: $table.u2, builder: (column) => column);

  GeneratedColumn<double> get tu2u1 =>
      $composableBuilder(column: $table.tu2u1, builder: (column) => column);

  GeneratedColumn<String> get u3 =>
      $composableBuilder(column: $table.u3, builder: (column) => column);

  GeneratedColumn<double> get tu3u2 =>
      $composableBuilder(column: $table.tu3u2, builder: (column) => column);

  GeneratedColumn<double> get pvu1 =>
      $composableBuilder(column: $table.pvu1, builder: (column) => column);

  GeneratedColumn<double> get pvu2 =>
      $composableBuilder(column: $table.pvu2, builder: (column) => column);

  GeneratedColumn<double> get pvu3 =>
      $composableBuilder(column: $table.pvu3, builder: (column) => column);

  GeneratedColumn<double> get stocksu1 =>
      $composableBuilder(column: $table.stocksu1, builder: (column) => column);

  GeneratedColumn<double> get stocksu2 =>
      $composableBuilder(column: $table.stocksu2, builder: (column) => column);

  GeneratedColumn<double> get stocksu3 =>
      $composableBuilder(column: $table.stocksu3, builder: (column) => column);

  GeneratedColumn<String> get sec =>
      $composableBuilder(column: $table.sec, builder: (column) => column);

  GeneratedColumn<double> get usec =>
      $composableBuilder(column: $table.usec, builder: (column) => column);

  GeneratedColumn<double> get cmup =>
      $composableBuilder(column: $table.cmup, builder: (column) => column);

  GeneratedColumn<String> get dep =>
      $composableBuilder(column: $table.dep, builder: (column) => column);

  GeneratedColumn<String> get action =>
      $composableBuilder(column: $table.action, builder: (column) => column);

  GeneratedColumn<String> get categorie =>
      $composableBuilder(column: $table.categorie, builder: (column) => column);

  GeneratedColumn<String> get classification => $composableBuilder(
      column: $table.classification, builder: (column) => column);

  GeneratedColumn<String> get emb =>
      $composableBuilder(column: $table.emb, builder: (column) => column);
}

class $$ArticlesTableTableManager extends RootTableManager<
    _$AppDatabase,
    $ArticlesTable,
    Article,
    $$ArticlesTableFilterComposer,
    $$ArticlesTableOrderingComposer,
    $$ArticlesTableAnnotationComposer,
    $$ArticlesTableCreateCompanionBuilder,
    $$ArticlesTableUpdateCompanionBuilder,
    (Article, BaseReferences<_$AppDatabase, $ArticlesTable, Article>),
    Article,
    PrefetchHooks Function()> {
  $$ArticlesTableTableManager(_$AppDatabase db, $ArticlesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ArticlesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ArticlesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ArticlesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> designation = const Value.absent(),
            Value<String?> u1 = const Value.absent(),
            Value<String?> u2 = const Value.absent(),
            Value<double?> tu2u1 = const Value.absent(),
            Value<String?> u3 = const Value.absent(),
            Value<double?> tu3u2 = const Value.absent(),
            Value<double?> pvu1 = const Value.absent(),
            Value<double?> pvu2 = const Value.absent(),
            Value<double?> pvu3 = const Value.absent(),
            Value<double?> stocksu1 = const Value.absent(),
            Value<double?> stocksu2 = const Value.absent(),
            Value<double?> stocksu3 = const Value.absent(),
            Value<String?> sec = const Value.absent(),
            Value<double?> usec = const Value.absent(),
            Value<double?> cmup = const Value.absent(),
            Value<String?> dep = const Value.absent(),
            Value<String?> action = const Value.absent(),
            Value<String?> categorie = const Value.absent(),
            Value<String?> classification = const Value.absent(),
            Value<String?> emb = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ArticlesCompanion(
            designation: designation,
            u1: u1,
            u2: u2,
            tu2u1: tu2u1,
            u3: u3,
            tu3u2: tu3u2,
            pvu1: pvu1,
            pvu2: pvu2,
            pvu3: pvu3,
            stocksu1: stocksu1,
            stocksu2: stocksu2,
            stocksu3: stocksu3,
            sec: sec,
            usec: usec,
            cmup: cmup,
            dep: dep,
            action: action,
            categorie: categorie,
            classification: classification,
            emb: emb,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String designation,
            Value<String?> u1 = const Value.absent(),
            Value<String?> u2 = const Value.absent(),
            Value<double?> tu2u1 = const Value.absent(),
            Value<String?> u3 = const Value.absent(),
            Value<double?> tu3u2 = const Value.absent(),
            Value<double?> pvu1 = const Value.absent(),
            Value<double?> pvu2 = const Value.absent(),
            Value<double?> pvu3 = const Value.absent(),
            Value<double?> stocksu1 = const Value.absent(),
            Value<double?> stocksu2 = const Value.absent(),
            Value<double?> stocksu3 = const Value.absent(),
            Value<String?> sec = const Value.absent(),
            Value<double?> usec = const Value.absent(),
            Value<double?> cmup = const Value.absent(),
            Value<String?> dep = const Value.absent(),
            Value<String?> action = const Value.absent(),
            Value<String?> categorie = const Value.absent(),
            Value<String?> classification = const Value.absent(),
            Value<String?> emb = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ArticlesCompanion.insert(
            designation: designation,
            u1: u1,
            u2: u2,
            tu2u1: tu2u1,
            u3: u3,
            tu3u2: tu3u2,
            pvu1: pvu1,
            pvu2: pvu2,
            pvu3: pvu3,
            stocksu1: stocksu1,
            stocksu2: stocksu2,
            stocksu3: stocksu3,
            sec: sec,
            usec: usec,
            cmup: cmup,
            dep: dep,
            action: action,
            categorie: categorie,
            classification: classification,
            emb: emb,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$ArticlesTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $ArticlesTable,
    Article,
    $$ArticlesTableFilterComposer,
    $$ArticlesTableOrderingComposer,
    $$ArticlesTableAnnotationComposer,
    $$ArticlesTableCreateCompanionBuilder,
    $$ArticlesTableUpdateCompanionBuilder,
    (Article, BaseReferences<_$AppDatabase, $ArticlesTable, Article>),
    Article,
    PrefetchHooks Function()>;
typedef $$CltTableCreateCompanionBuilder = CltCompanion Function({
  required String rsoc,
  Value<String?> adr,
  Value<double?> capital,
  Value<String?> rcs,
  Value<String?> nif,
  Value<String?> stat,
  Value<String?> tel,
  Value<String?> port,
  Value<String?> email,
  Value<String?> site,
  Value<String?> fax,
  Value<String?> telex,
  Value<double?> soldes,
  Value<DateTime?> datedernop,
  Value<int?> delai,
  Value<double?> soldesa,
  Value<String?> action,
  Value<String?> commercial,
  Value<double?> plafon,
  Value<double?> taux,
  Value<String?> categorie,
  Value<double?> plafonbl,
  Value<int> rowid,
});
typedef $$CltTableUpdateCompanionBuilder = CltCompanion Function({
  Value<String> rsoc,
  Value<String?> adr,
  Value<double?> capital,
  Value<String?> rcs,
  Value<String?> nif,
  Value<String?> stat,
  Value<String?> tel,
  Value<String?> port,
  Value<String?> email,
  Value<String?> site,
  Value<String?> fax,
  Value<String?> telex,
  Value<double?> soldes,
  Value<DateTime?> datedernop,
  Value<int?> delai,
  Value<double?> soldesa,
  Value<String?> action,
  Value<String?> commercial,
  Value<double?> plafon,
  Value<double?> taux,
  Value<String?> categorie,
  Value<double?> plafonbl,
  Value<int> rowid,
});

class $$CltTableFilterComposer extends Composer<_$AppDatabase, $CltTable> {
  $$CltTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get rsoc => $composableBuilder(
      column: $table.rsoc, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get adr => $composableBuilder(
      column: $table.adr, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get capital => $composableBuilder(
      column: $table.capital, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get rcs => $composableBuilder(
      column: $table.rcs, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nif => $composableBuilder(
      column: $table.nif, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get stat => $composableBuilder(
      column: $table.stat, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get tel => $composableBuilder(
      column: $table.tel, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get port => $composableBuilder(
      column: $table.port, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get email => $composableBuilder(
      column: $table.email, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get site => $composableBuilder(
      column: $table.site, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get fax => $composableBuilder(
      column: $table.fax, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get telex => $composableBuilder(
      column: $table.telex, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get soldes => $composableBuilder(
      column: $table.soldes, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get datedernop => $composableBuilder(
      column: $table.datedernop, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get delai => $composableBuilder(
      column: $table.delai, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get soldesa => $composableBuilder(
      column: $table.soldesa, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get action => $composableBuilder(
      column: $table.action, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get commercial => $composableBuilder(
      column: $table.commercial, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get plafon => $composableBuilder(
      column: $table.plafon, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get taux => $composableBuilder(
      column: $table.taux, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get categorie => $composableBuilder(
      column: $table.categorie, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get plafonbl => $composableBuilder(
      column: $table.plafonbl, builder: (column) => ColumnFilters(column));
}

class $$CltTableOrderingComposer extends Composer<_$AppDatabase, $CltTable> {
  $$CltTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get rsoc => $composableBuilder(
      column: $table.rsoc, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get adr => $composableBuilder(
      column: $table.adr, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get capital => $composableBuilder(
      column: $table.capital, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get rcs => $composableBuilder(
      column: $table.rcs, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nif => $composableBuilder(
      column: $table.nif, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get stat => $composableBuilder(
      column: $table.stat, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get tel => $composableBuilder(
      column: $table.tel, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get port => $composableBuilder(
      column: $table.port, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get email => $composableBuilder(
      column: $table.email, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get site => $composableBuilder(
      column: $table.site, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get fax => $composableBuilder(
      column: $table.fax, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get telex => $composableBuilder(
      column: $table.telex, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get soldes => $composableBuilder(
      column: $table.soldes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get datedernop => $composableBuilder(
      column: $table.datedernop, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get delai => $composableBuilder(
      column: $table.delai, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get soldesa => $composableBuilder(
      column: $table.soldesa, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get action => $composableBuilder(
      column: $table.action, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get commercial => $composableBuilder(
      column: $table.commercial, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get plafon => $composableBuilder(
      column: $table.plafon, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get taux => $composableBuilder(
      column: $table.taux, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get categorie => $composableBuilder(
      column: $table.categorie, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get plafonbl => $composableBuilder(
      column: $table.plafonbl, builder: (column) => ColumnOrderings(column));
}

class $$CltTableAnnotationComposer extends Composer<_$AppDatabase, $CltTable> {
  $$CltTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get rsoc =>
      $composableBuilder(column: $table.rsoc, builder: (column) => column);

  GeneratedColumn<String> get adr =>
      $composableBuilder(column: $table.adr, builder: (column) => column);

  GeneratedColumn<double> get capital =>
      $composableBuilder(column: $table.capital, builder: (column) => column);

  GeneratedColumn<String> get rcs =>
      $composableBuilder(column: $table.rcs, builder: (column) => column);

  GeneratedColumn<String> get nif =>
      $composableBuilder(column: $table.nif, builder: (column) => column);

  GeneratedColumn<String> get stat =>
      $composableBuilder(column: $table.stat, builder: (column) => column);

  GeneratedColumn<String> get tel =>
      $composableBuilder(column: $table.tel, builder: (column) => column);

  GeneratedColumn<String> get port =>
      $composableBuilder(column: $table.port, builder: (column) => column);

  GeneratedColumn<String> get email =>
      $composableBuilder(column: $table.email, builder: (column) => column);

  GeneratedColumn<String> get site =>
      $composableBuilder(column: $table.site, builder: (column) => column);

  GeneratedColumn<String> get fax =>
      $composableBuilder(column: $table.fax, builder: (column) => column);

  GeneratedColumn<String> get telex =>
      $composableBuilder(column: $table.telex, builder: (column) => column);

  GeneratedColumn<double> get soldes =>
      $composableBuilder(column: $table.soldes, builder: (column) => column);

  GeneratedColumn<DateTime> get datedernop => $composableBuilder(
      column: $table.datedernop, builder: (column) => column);

  GeneratedColumn<int> get delai =>
      $composableBuilder(column: $table.delai, builder: (column) => column);

  GeneratedColumn<double> get soldesa =>
      $composableBuilder(column: $table.soldesa, builder: (column) => column);

  GeneratedColumn<String> get action =>
      $composableBuilder(column: $table.action, builder: (column) => column);

  GeneratedColumn<String> get commercial => $composableBuilder(
      column: $table.commercial, builder: (column) => column);

  GeneratedColumn<double> get plafon =>
      $composableBuilder(column: $table.plafon, builder: (column) => column);

  GeneratedColumn<double> get taux =>
      $composableBuilder(column: $table.taux, builder: (column) => column);

  GeneratedColumn<String> get categorie =>
      $composableBuilder(column: $table.categorie, builder: (column) => column);

  GeneratedColumn<double> get plafonbl =>
      $composableBuilder(column: $table.plafonbl, builder: (column) => column);
}

class $$CltTableTableManager extends RootTableManager<
    _$AppDatabase,
    $CltTable,
    CltData,
    $$CltTableFilterComposer,
    $$CltTableOrderingComposer,
    $$CltTableAnnotationComposer,
    $$CltTableCreateCompanionBuilder,
    $$CltTableUpdateCompanionBuilder,
    (CltData, BaseReferences<_$AppDatabase, $CltTable, CltData>),
    CltData,
    PrefetchHooks Function()> {
  $$CltTableTableManager(_$AppDatabase db, $CltTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CltTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CltTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CltTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> rsoc = const Value.absent(),
            Value<String?> adr = const Value.absent(),
            Value<double?> capital = const Value.absent(),
            Value<String?> rcs = const Value.absent(),
            Value<String?> nif = const Value.absent(),
            Value<String?> stat = const Value.absent(),
            Value<String?> tel = const Value.absent(),
            Value<String?> port = const Value.absent(),
            Value<String?> email = const Value.absent(),
            Value<String?> site = const Value.absent(),
            Value<String?> fax = const Value.absent(),
            Value<String?> telex = const Value.absent(),
            Value<double?> soldes = const Value.absent(),
            Value<DateTime?> datedernop = const Value.absent(),
            Value<int?> delai = const Value.absent(),
            Value<double?> soldesa = const Value.absent(),
            Value<String?> action = const Value.absent(),
            Value<String?> commercial = const Value.absent(),
            Value<double?> plafon = const Value.absent(),
            Value<double?> taux = const Value.absent(),
            Value<String?> categorie = const Value.absent(),
            Value<double?> plafonbl = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              CltCompanion(
            rsoc: rsoc,
            adr: adr,
            capital: capital,
            rcs: rcs,
            nif: nif,
            stat: stat,
            tel: tel,
            port: port,
            email: email,
            site: site,
            fax: fax,
            telex: telex,
            soldes: soldes,
            datedernop: datedernop,
            delai: delai,
            soldesa: soldesa,
            action: action,
            commercial: commercial,
            plafon: plafon,
            taux: taux,
            categorie: categorie,
            plafonbl: plafonbl,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String rsoc,
            Value<String?> adr = const Value.absent(),
            Value<double?> capital = const Value.absent(),
            Value<String?> rcs = const Value.absent(),
            Value<String?> nif = const Value.absent(),
            Value<String?> stat = const Value.absent(),
            Value<String?> tel = const Value.absent(),
            Value<String?> port = const Value.absent(),
            Value<String?> email = const Value.absent(),
            Value<String?> site = const Value.absent(),
            Value<String?> fax = const Value.absent(),
            Value<String?> telex = const Value.absent(),
            Value<double?> soldes = const Value.absent(),
            Value<DateTime?> datedernop = const Value.absent(),
            Value<int?> delai = const Value.absent(),
            Value<double?> soldesa = const Value.absent(),
            Value<String?> action = const Value.absent(),
            Value<String?> commercial = const Value.absent(),
            Value<double?> plafon = const Value.absent(),
            Value<double?> taux = const Value.absent(),
            Value<String?> categorie = const Value.absent(),
            Value<double?> plafonbl = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              CltCompanion.insert(
            rsoc: rsoc,
            adr: adr,
            capital: capital,
            rcs: rcs,
            nif: nif,
            stat: stat,
            tel: tel,
            port: port,
            email: email,
            site: site,
            fax: fax,
            telex: telex,
            soldes: soldes,
            datedernop: datedernop,
            delai: delai,
            soldesa: soldesa,
            action: action,
            commercial: commercial,
            plafon: plafon,
            taux: taux,
            categorie: categorie,
            plafonbl: plafonbl,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$CltTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $CltTable,
    CltData,
    $$CltTableFilterComposer,
    $$CltTableOrderingComposer,
    $$CltTableAnnotationComposer,
    $$CltTableCreateCompanionBuilder,
    $$CltTableUpdateCompanionBuilder,
    (CltData, BaseReferences<_$AppDatabase, $CltTable, CltData>),
    CltData,
    PrefetchHooks Function()>;
typedef $$FrnsTableCreateCompanionBuilder = FrnsCompanion Function({
  required String rsoc,
  Value<String?> adr,
  Value<double?> capital,
  Value<String?> rcs,
  Value<String?> nif,
  Value<String?> stat,
  Value<String?> tel,
  Value<String?> port,
  Value<String?> email,
  Value<String?> site,
  Value<String?> fax,
  Value<String?> telex,
  Value<double?> soldes,
  Value<DateTime?> datedernop,
  Value<int?> delai,
  Value<double?> soldesa,
  Value<String?> action,
  Value<int> rowid,
});
typedef $$FrnsTableUpdateCompanionBuilder = FrnsCompanion Function({
  Value<String> rsoc,
  Value<String?> adr,
  Value<double?> capital,
  Value<String?> rcs,
  Value<String?> nif,
  Value<String?> stat,
  Value<String?> tel,
  Value<String?> port,
  Value<String?> email,
  Value<String?> site,
  Value<String?> fax,
  Value<String?> telex,
  Value<double?> soldes,
  Value<DateTime?> datedernop,
  Value<int?> delai,
  Value<double?> soldesa,
  Value<String?> action,
  Value<int> rowid,
});

class $$FrnsTableFilterComposer extends Composer<_$AppDatabase, $FrnsTable> {
  $$FrnsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get rsoc => $composableBuilder(
      column: $table.rsoc, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get adr => $composableBuilder(
      column: $table.adr, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get capital => $composableBuilder(
      column: $table.capital, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get rcs => $composableBuilder(
      column: $table.rcs, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nif => $composableBuilder(
      column: $table.nif, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get stat => $composableBuilder(
      column: $table.stat, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get tel => $composableBuilder(
      column: $table.tel, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get port => $composableBuilder(
      column: $table.port, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get email => $composableBuilder(
      column: $table.email, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get site => $composableBuilder(
      column: $table.site, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get fax => $composableBuilder(
      column: $table.fax, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get telex => $composableBuilder(
      column: $table.telex, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get soldes => $composableBuilder(
      column: $table.soldes, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get datedernop => $composableBuilder(
      column: $table.datedernop, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get delai => $composableBuilder(
      column: $table.delai, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get soldesa => $composableBuilder(
      column: $table.soldesa, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get action => $composableBuilder(
      column: $table.action, builder: (column) => ColumnFilters(column));
}

class $$FrnsTableOrderingComposer extends Composer<_$AppDatabase, $FrnsTable> {
  $$FrnsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get rsoc => $composableBuilder(
      column: $table.rsoc, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get adr => $composableBuilder(
      column: $table.adr, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get capital => $composableBuilder(
      column: $table.capital, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get rcs => $composableBuilder(
      column: $table.rcs, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nif => $composableBuilder(
      column: $table.nif, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get stat => $composableBuilder(
      column: $table.stat, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get tel => $composableBuilder(
      column: $table.tel, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get port => $composableBuilder(
      column: $table.port, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get email => $composableBuilder(
      column: $table.email, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get site => $composableBuilder(
      column: $table.site, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get fax => $composableBuilder(
      column: $table.fax, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get telex => $composableBuilder(
      column: $table.telex, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get soldes => $composableBuilder(
      column: $table.soldes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get datedernop => $composableBuilder(
      column: $table.datedernop, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get delai => $composableBuilder(
      column: $table.delai, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get soldesa => $composableBuilder(
      column: $table.soldesa, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get action => $composableBuilder(
      column: $table.action, builder: (column) => ColumnOrderings(column));
}

class $$FrnsTableAnnotationComposer
    extends Composer<_$AppDatabase, $FrnsTable> {
  $$FrnsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get rsoc =>
      $composableBuilder(column: $table.rsoc, builder: (column) => column);

  GeneratedColumn<String> get adr =>
      $composableBuilder(column: $table.adr, builder: (column) => column);

  GeneratedColumn<double> get capital =>
      $composableBuilder(column: $table.capital, builder: (column) => column);

  GeneratedColumn<String> get rcs =>
      $composableBuilder(column: $table.rcs, builder: (column) => column);

  GeneratedColumn<String> get nif =>
      $composableBuilder(column: $table.nif, builder: (column) => column);

  GeneratedColumn<String> get stat =>
      $composableBuilder(column: $table.stat, builder: (column) => column);

  GeneratedColumn<String> get tel =>
      $composableBuilder(column: $table.tel, builder: (column) => column);

  GeneratedColumn<String> get port =>
      $composableBuilder(column: $table.port, builder: (column) => column);

  GeneratedColumn<String> get email =>
      $composableBuilder(column: $table.email, builder: (column) => column);

  GeneratedColumn<String> get site =>
      $composableBuilder(column: $table.site, builder: (column) => column);

  GeneratedColumn<String> get fax =>
      $composableBuilder(column: $table.fax, builder: (column) => column);

  GeneratedColumn<String> get telex =>
      $composableBuilder(column: $table.telex, builder: (column) => column);

  GeneratedColumn<double> get soldes =>
      $composableBuilder(column: $table.soldes, builder: (column) => column);

  GeneratedColumn<DateTime> get datedernop => $composableBuilder(
      column: $table.datedernop, builder: (column) => column);

  GeneratedColumn<int> get delai =>
      $composableBuilder(column: $table.delai, builder: (column) => column);

  GeneratedColumn<double> get soldesa =>
      $composableBuilder(column: $table.soldesa, builder: (column) => column);

  GeneratedColumn<String> get action =>
      $composableBuilder(column: $table.action, builder: (column) => column);
}

class $$FrnsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $FrnsTable,
    Frn,
    $$FrnsTableFilterComposer,
    $$FrnsTableOrderingComposer,
    $$FrnsTableAnnotationComposer,
    $$FrnsTableCreateCompanionBuilder,
    $$FrnsTableUpdateCompanionBuilder,
    (Frn, BaseReferences<_$AppDatabase, $FrnsTable, Frn>),
    Frn,
    PrefetchHooks Function()> {
  $$FrnsTableTableManager(_$AppDatabase db, $FrnsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$FrnsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$FrnsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$FrnsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> rsoc = const Value.absent(),
            Value<String?> adr = const Value.absent(),
            Value<double?> capital = const Value.absent(),
            Value<String?> rcs = const Value.absent(),
            Value<String?> nif = const Value.absent(),
            Value<String?> stat = const Value.absent(),
            Value<String?> tel = const Value.absent(),
            Value<String?> port = const Value.absent(),
            Value<String?> email = const Value.absent(),
            Value<String?> site = const Value.absent(),
            Value<String?> fax = const Value.absent(),
            Value<String?> telex = const Value.absent(),
            Value<double?> soldes = const Value.absent(),
            Value<DateTime?> datedernop = const Value.absent(),
            Value<int?> delai = const Value.absent(),
            Value<double?> soldesa = const Value.absent(),
            Value<String?> action = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              FrnsCompanion(
            rsoc: rsoc,
            adr: adr,
            capital: capital,
            rcs: rcs,
            nif: nif,
            stat: stat,
            tel: tel,
            port: port,
            email: email,
            site: site,
            fax: fax,
            telex: telex,
            soldes: soldes,
            datedernop: datedernop,
            delai: delai,
            soldesa: soldesa,
            action: action,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String rsoc,
            Value<String?> adr = const Value.absent(),
            Value<double?> capital = const Value.absent(),
            Value<String?> rcs = const Value.absent(),
            Value<String?> nif = const Value.absent(),
            Value<String?> stat = const Value.absent(),
            Value<String?> tel = const Value.absent(),
            Value<String?> port = const Value.absent(),
            Value<String?> email = const Value.absent(),
            Value<String?> site = const Value.absent(),
            Value<String?> fax = const Value.absent(),
            Value<String?> telex = const Value.absent(),
            Value<double?> soldes = const Value.absent(),
            Value<DateTime?> datedernop = const Value.absent(),
            Value<int?> delai = const Value.absent(),
            Value<double?> soldesa = const Value.absent(),
            Value<String?> action = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              FrnsCompanion.insert(
            rsoc: rsoc,
            adr: adr,
            capital: capital,
            rcs: rcs,
            nif: nif,
            stat: stat,
            tel: tel,
            port: port,
            email: email,
            site: site,
            fax: fax,
            telex: telex,
            soldes: soldes,
            datedernop: datedernop,
            delai: delai,
            soldesa: soldesa,
            action: action,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$FrnsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $FrnsTable,
    Frn,
    $$FrnsTableFilterComposer,
    $$FrnsTableOrderingComposer,
    $$FrnsTableAnnotationComposer,
    $$FrnsTableCreateCompanionBuilder,
    $$FrnsTableUpdateCompanionBuilder,
    (Frn, BaseReferences<_$AppDatabase, $FrnsTable, Frn>),
    Frn,
    PrefetchHooks Function()>;
typedef $$ComTableCreateCompanionBuilder = ComCompanion Function({
  required String nom,
  Value<String?> adr,
  Value<String?> tel,
  Value<String?> email,
  Value<double?> soldes,
  Value<double?> taux,
  Value<String?> action,
  Value<double?> soldesa,
  Value<int> rowid,
});
typedef $$ComTableUpdateCompanionBuilder = ComCompanion Function({
  Value<String> nom,
  Value<String?> adr,
  Value<String?> tel,
  Value<String?> email,
  Value<double?> soldes,
  Value<double?> taux,
  Value<String?> action,
  Value<double?> soldesa,
  Value<int> rowid,
});

class $$ComTableFilterComposer extends Composer<_$AppDatabase, $ComTable> {
  $$ComTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get nom => $composableBuilder(
      column: $table.nom, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get adr => $composableBuilder(
      column: $table.adr, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get tel => $composableBuilder(
      column: $table.tel, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get email => $composableBuilder(
      column: $table.email, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get soldes => $composableBuilder(
      column: $table.soldes, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get taux => $composableBuilder(
      column: $table.taux, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get action => $composableBuilder(
      column: $table.action, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get soldesa => $composableBuilder(
      column: $table.soldesa, builder: (column) => ColumnFilters(column));
}

class $$ComTableOrderingComposer extends Composer<_$AppDatabase, $ComTable> {
  $$ComTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get nom => $composableBuilder(
      column: $table.nom, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get adr => $composableBuilder(
      column: $table.adr, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get tel => $composableBuilder(
      column: $table.tel, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get email => $composableBuilder(
      column: $table.email, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get soldes => $composableBuilder(
      column: $table.soldes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get taux => $composableBuilder(
      column: $table.taux, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get action => $composableBuilder(
      column: $table.action, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get soldesa => $composableBuilder(
      column: $table.soldesa, builder: (column) => ColumnOrderings(column));
}

class $$ComTableAnnotationComposer extends Composer<_$AppDatabase, $ComTable> {
  $$ComTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get nom =>
      $composableBuilder(column: $table.nom, builder: (column) => column);

  GeneratedColumn<String> get adr =>
      $composableBuilder(column: $table.adr, builder: (column) => column);

  GeneratedColumn<String> get tel =>
      $composableBuilder(column: $table.tel, builder: (column) => column);

  GeneratedColumn<String> get email =>
      $composableBuilder(column: $table.email, builder: (column) => column);

  GeneratedColumn<double> get soldes =>
      $composableBuilder(column: $table.soldes, builder: (column) => column);

  GeneratedColumn<double> get taux =>
      $composableBuilder(column: $table.taux, builder: (column) => column);

  GeneratedColumn<String> get action =>
      $composableBuilder(column: $table.action, builder: (column) => column);

  GeneratedColumn<double> get soldesa =>
      $composableBuilder(column: $table.soldesa, builder: (column) => column);
}

class $$ComTableTableManager extends RootTableManager<
    _$AppDatabase,
    $ComTable,
    ComData,
    $$ComTableFilterComposer,
    $$ComTableOrderingComposer,
    $$ComTableAnnotationComposer,
    $$ComTableCreateCompanionBuilder,
    $$ComTableUpdateCompanionBuilder,
    (ComData, BaseReferences<_$AppDatabase, $ComTable, ComData>),
    ComData,
    PrefetchHooks Function()> {
  $$ComTableTableManager(_$AppDatabase db, $ComTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ComTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ComTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ComTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> nom = const Value.absent(),
            Value<String?> adr = const Value.absent(),
            Value<String?> tel = const Value.absent(),
            Value<String?> email = const Value.absent(),
            Value<double?> soldes = const Value.absent(),
            Value<double?> taux = const Value.absent(),
            Value<String?> action = const Value.absent(),
            Value<double?> soldesa = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ComCompanion(
            nom: nom,
            adr: adr,
            tel: tel,
            email: email,
            soldes: soldes,
            taux: taux,
            action: action,
            soldesa: soldesa,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String nom,
            Value<String?> adr = const Value.absent(),
            Value<String?> tel = const Value.absent(),
            Value<String?> email = const Value.absent(),
            Value<double?> soldes = const Value.absent(),
            Value<double?> taux = const Value.absent(),
            Value<String?> action = const Value.absent(),
            Value<double?> soldesa = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ComCompanion.insert(
            nom: nom,
            adr: adr,
            tel: tel,
            email: email,
            soldes: soldes,
            taux: taux,
            action: action,
            soldesa: soldesa,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$ComTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $ComTable,
    ComData,
    $$ComTableFilterComposer,
    $$ComTableOrderingComposer,
    $$ComTableAnnotationComposer,
    $$ComTableCreateCompanionBuilder,
    $$ComTableUpdateCompanionBuilder,
    (ComData, BaseReferences<_$AppDatabase, $ComTable, ComData>),
    ComData,
    PrefetchHooks Function()>;
typedef $$VentesTableCreateCompanionBuilder = VentesCompanion Function({
  Value<int> num,
  Value<String?> numventes,
  Value<String?> nfact,
  Value<DateTime?> daty,
  Value<String?> clt,
  Value<String?> modepai,
  Value<DateTime?> echeance,
  Value<double?> totalnt,
  Value<double?> totalttc,
  Value<double?> tva,
  Value<String?> contre,
  Value<double?> avance,
  Value<String?> bq,
  Value<double?> regl,
  Value<DateTime?> datrcol,
  Value<String?> mregl,
  Value<String?> commerc,
  Value<double?> commission,
  Value<double?> remise,
  Value<String?> verification,
  Value<String?> type,
  Value<String?> as,
  Value<String?> emb,
  Value<String?> transp,
  Value<String?> heure,
  Value<String?> poste,
});
typedef $$VentesTableUpdateCompanionBuilder = VentesCompanion Function({
  Value<int> num,
  Value<String?> numventes,
  Value<String?> nfact,
  Value<DateTime?> daty,
  Value<String?> clt,
  Value<String?> modepai,
  Value<DateTime?> echeance,
  Value<double?> totalnt,
  Value<double?> totalttc,
  Value<double?> tva,
  Value<String?> contre,
  Value<double?> avance,
  Value<String?> bq,
  Value<double?> regl,
  Value<DateTime?> datrcol,
  Value<String?> mregl,
  Value<String?> commerc,
  Value<double?> commission,
  Value<double?> remise,
  Value<String?> verification,
  Value<String?> type,
  Value<String?> as,
  Value<String?> emb,
  Value<String?> transp,
  Value<String?> heure,
  Value<String?> poste,
});

class $$VentesTableFilterComposer
    extends Composer<_$AppDatabase, $VentesTable> {
  $$VentesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get num => $composableBuilder(
      column: $table.num, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get numventes => $composableBuilder(
      column: $table.numventes, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nfact => $composableBuilder(
      column: $table.nfact, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get clt => $composableBuilder(
      column: $table.clt, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get modepai => $composableBuilder(
      column: $table.modepai, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get echeance => $composableBuilder(
      column: $table.echeance, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get totalnt => $composableBuilder(
      column: $table.totalnt, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get totalttc => $composableBuilder(
      column: $table.totalttc, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get tva => $composableBuilder(
      column: $table.tva, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get contre => $composableBuilder(
      column: $table.contre, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get avance => $composableBuilder(
      column: $table.avance, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get bq => $composableBuilder(
      column: $table.bq, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get regl => $composableBuilder(
      column: $table.regl, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get datrcol => $composableBuilder(
      column: $table.datrcol, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get mregl => $composableBuilder(
      column: $table.mregl, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get commerc => $composableBuilder(
      column: $table.commerc, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get commission => $composableBuilder(
      column: $table.commission, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get remise => $composableBuilder(
      column: $table.remise, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get verification => $composableBuilder(
      column: $table.verification, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get as => $composableBuilder(
      column: $table.as, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get emb => $composableBuilder(
      column: $table.emb, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get transp => $composableBuilder(
      column: $table.transp, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get heure => $composableBuilder(
      column: $table.heure, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get poste => $composableBuilder(
      column: $table.poste, builder: (column) => ColumnFilters(column));
}

class $$VentesTableOrderingComposer
    extends Composer<_$AppDatabase, $VentesTable> {
  $$VentesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get num => $composableBuilder(
      column: $table.num, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get numventes => $composableBuilder(
      column: $table.numventes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nfact => $composableBuilder(
      column: $table.nfact, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get clt => $composableBuilder(
      column: $table.clt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get modepai => $composableBuilder(
      column: $table.modepai, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get echeance => $composableBuilder(
      column: $table.echeance, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get totalnt => $composableBuilder(
      column: $table.totalnt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get totalttc => $composableBuilder(
      column: $table.totalttc, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get tva => $composableBuilder(
      column: $table.tva, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get contre => $composableBuilder(
      column: $table.contre, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get avance => $composableBuilder(
      column: $table.avance, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get bq => $composableBuilder(
      column: $table.bq, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get regl => $composableBuilder(
      column: $table.regl, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get datrcol => $composableBuilder(
      column: $table.datrcol, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get mregl => $composableBuilder(
      column: $table.mregl, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get commerc => $composableBuilder(
      column: $table.commerc, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get commission => $composableBuilder(
      column: $table.commission, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get remise => $composableBuilder(
      column: $table.remise, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get verification => $composableBuilder(
      column: $table.verification,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get as => $composableBuilder(
      column: $table.as, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get emb => $composableBuilder(
      column: $table.emb, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get transp => $composableBuilder(
      column: $table.transp, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get heure => $composableBuilder(
      column: $table.heure, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get poste => $composableBuilder(
      column: $table.poste, builder: (column) => ColumnOrderings(column));
}

class $$VentesTableAnnotationComposer
    extends Composer<_$AppDatabase, $VentesTable> {
  $$VentesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get num =>
      $composableBuilder(column: $table.num, builder: (column) => column);

  GeneratedColumn<String> get numventes =>
      $composableBuilder(column: $table.numventes, builder: (column) => column);

  GeneratedColumn<String> get nfact =>
      $composableBuilder(column: $table.nfact, builder: (column) => column);

  GeneratedColumn<DateTime> get daty =>
      $composableBuilder(column: $table.daty, builder: (column) => column);

  GeneratedColumn<String> get clt =>
      $composableBuilder(column: $table.clt, builder: (column) => column);

  GeneratedColumn<String> get modepai =>
      $composableBuilder(column: $table.modepai, builder: (column) => column);

  GeneratedColumn<DateTime> get echeance =>
      $composableBuilder(column: $table.echeance, builder: (column) => column);

  GeneratedColumn<double> get totalnt =>
      $composableBuilder(column: $table.totalnt, builder: (column) => column);

  GeneratedColumn<double> get totalttc =>
      $composableBuilder(column: $table.totalttc, builder: (column) => column);

  GeneratedColumn<double> get tva =>
      $composableBuilder(column: $table.tva, builder: (column) => column);

  GeneratedColumn<String> get contre =>
      $composableBuilder(column: $table.contre, builder: (column) => column);

  GeneratedColumn<double> get avance =>
      $composableBuilder(column: $table.avance, builder: (column) => column);

  GeneratedColumn<String> get bq =>
      $composableBuilder(column: $table.bq, builder: (column) => column);

  GeneratedColumn<double> get regl =>
      $composableBuilder(column: $table.regl, builder: (column) => column);

  GeneratedColumn<DateTime> get datrcol =>
      $composableBuilder(column: $table.datrcol, builder: (column) => column);

  GeneratedColumn<String> get mregl =>
      $composableBuilder(column: $table.mregl, builder: (column) => column);

  GeneratedColumn<String> get commerc =>
      $composableBuilder(column: $table.commerc, builder: (column) => column);

  GeneratedColumn<double> get commission => $composableBuilder(
      column: $table.commission, builder: (column) => column);

  GeneratedColumn<double> get remise =>
      $composableBuilder(column: $table.remise, builder: (column) => column);

  GeneratedColumn<String> get verification => $composableBuilder(
      column: $table.verification, builder: (column) => column);

  GeneratedColumn<String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  GeneratedColumn<String> get as =>
      $composableBuilder(column: $table.as, builder: (column) => column);

  GeneratedColumn<String> get emb =>
      $composableBuilder(column: $table.emb, builder: (column) => column);

  GeneratedColumn<String> get transp =>
      $composableBuilder(column: $table.transp, builder: (column) => column);

  GeneratedColumn<String> get heure =>
      $composableBuilder(column: $table.heure, builder: (column) => column);

  GeneratedColumn<String> get poste =>
      $composableBuilder(column: $table.poste, builder: (column) => column);
}

class $$VentesTableTableManager extends RootTableManager<
    _$AppDatabase,
    $VentesTable,
    Vente,
    $$VentesTableFilterComposer,
    $$VentesTableOrderingComposer,
    $$VentesTableAnnotationComposer,
    $$VentesTableCreateCompanionBuilder,
    $$VentesTableUpdateCompanionBuilder,
    (Vente, BaseReferences<_$AppDatabase, $VentesTable, Vente>),
    Vente,
    PrefetchHooks Function()> {
  $$VentesTableTableManager(_$AppDatabase db, $VentesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$VentesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$VentesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$VentesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> num = const Value.absent(),
            Value<String?> numventes = const Value.absent(),
            Value<String?> nfact = const Value.absent(),
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> clt = const Value.absent(),
            Value<String?> modepai = const Value.absent(),
            Value<DateTime?> echeance = const Value.absent(),
            Value<double?> totalnt = const Value.absent(),
            Value<double?> totalttc = const Value.absent(),
            Value<double?> tva = const Value.absent(),
            Value<String?> contre = const Value.absent(),
            Value<double?> avance = const Value.absent(),
            Value<String?> bq = const Value.absent(),
            Value<double?> regl = const Value.absent(),
            Value<DateTime?> datrcol = const Value.absent(),
            Value<String?> mregl = const Value.absent(),
            Value<String?> commerc = const Value.absent(),
            Value<double?> commission = const Value.absent(),
            Value<double?> remise = const Value.absent(),
            Value<String?> verification = const Value.absent(),
            Value<String?> type = const Value.absent(),
            Value<String?> as = const Value.absent(),
            Value<String?> emb = const Value.absent(),
            Value<String?> transp = const Value.absent(),
            Value<String?> heure = const Value.absent(),
            Value<String?> poste = const Value.absent(),
          }) =>
              VentesCompanion(
            num: num,
            numventes: numventes,
            nfact: nfact,
            daty: daty,
            clt: clt,
            modepai: modepai,
            echeance: echeance,
            totalnt: totalnt,
            totalttc: totalttc,
            tva: tva,
            contre: contre,
            avance: avance,
            bq: bq,
            regl: regl,
            datrcol: datrcol,
            mregl: mregl,
            commerc: commerc,
            commission: commission,
            remise: remise,
            verification: verification,
            type: type,
            as: as,
            emb: emb,
            transp: transp,
            heure: heure,
            poste: poste,
          ),
          createCompanionCallback: ({
            Value<int> num = const Value.absent(),
            Value<String?> numventes = const Value.absent(),
            Value<String?> nfact = const Value.absent(),
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> clt = const Value.absent(),
            Value<String?> modepai = const Value.absent(),
            Value<DateTime?> echeance = const Value.absent(),
            Value<double?> totalnt = const Value.absent(),
            Value<double?> totalttc = const Value.absent(),
            Value<double?> tva = const Value.absent(),
            Value<String?> contre = const Value.absent(),
            Value<double?> avance = const Value.absent(),
            Value<String?> bq = const Value.absent(),
            Value<double?> regl = const Value.absent(),
            Value<DateTime?> datrcol = const Value.absent(),
            Value<String?> mregl = const Value.absent(),
            Value<String?> commerc = const Value.absent(),
            Value<double?> commission = const Value.absent(),
            Value<double?> remise = const Value.absent(),
            Value<String?> verification = const Value.absent(),
            Value<String?> type = const Value.absent(),
            Value<String?> as = const Value.absent(),
            Value<String?> emb = const Value.absent(),
            Value<String?> transp = const Value.absent(),
            Value<String?> heure = const Value.absent(),
            Value<String?> poste = const Value.absent(),
          }) =>
              VentesCompanion.insert(
            num: num,
            numventes: numventes,
            nfact: nfact,
            daty: daty,
            clt: clt,
            modepai: modepai,
            echeance: echeance,
            totalnt: totalnt,
            totalttc: totalttc,
            tva: tva,
            contre: contre,
            avance: avance,
            bq: bq,
            regl: regl,
            datrcol: datrcol,
            mregl: mregl,
            commerc: commerc,
            commission: commission,
            remise: remise,
            verification: verification,
            type: type,
            as: as,
            emb: emb,
            transp: transp,
            heure: heure,
            poste: poste,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$VentesTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $VentesTable,
    Vente,
    $$VentesTableFilterComposer,
    $$VentesTableOrderingComposer,
    $$VentesTableAnnotationComposer,
    $$VentesTableCreateCompanionBuilder,
    $$VentesTableUpdateCompanionBuilder,
    (Vente, BaseReferences<_$AppDatabase, $VentesTable, Vente>),
    Vente,
    PrefetchHooks Function()>;
typedef $$AchatsTableCreateCompanionBuilder = AchatsCompanion Function({
  Value<int> num,
  Value<String?> numachats,
  Value<String?> nfact,
  Value<DateTime?> daty,
  Value<String?> frns,
  Value<String?> modepai,
  Value<DateTime?> echeance,
  Value<double?> totalnt,
  Value<double?> totalttc,
  Value<double?> tva,
  Value<String?> contre,
  Value<String?> bq,
  Value<double?> regl,
  Value<DateTime?> datregl,
  Value<String?> mregl,
  Value<String?> verification,
  Value<String?> type,
  Value<String?> as,
  Value<String?> emb,
  Value<String?> transp,
});
typedef $$AchatsTableUpdateCompanionBuilder = AchatsCompanion Function({
  Value<int> num,
  Value<String?> numachats,
  Value<String?> nfact,
  Value<DateTime?> daty,
  Value<String?> frns,
  Value<String?> modepai,
  Value<DateTime?> echeance,
  Value<double?> totalnt,
  Value<double?> totalttc,
  Value<double?> tva,
  Value<String?> contre,
  Value<String?> bq,
  Value<double?> regl,
  Value<DateTime?> datregl,
  Value<String?> mregl,
  Value<String?> verification,
  Value<String?> type,
  Value<String?> as,
  Value<String?> emb,
  Value<String?> transp,
});

class $$AchatsTableFilterComposer
    extends Composer<_$AppDatabase, $AchatsTable> {
  $$AchatsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get num => $composableBuilder(
      column: $table.num, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get numachats => $composableBuilder(
      column: $table.numachats, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nfact => $composableBuilder(
      column: $table.nfact, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get frns => $composableBuilder(
      column: $table.frns, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get modepai => $composableBuilder(
      column: $table.modepai, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get echeance => $composableBuilder(
      column: $table.echeance, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get totalnt => $composableBuilder(
      column: $table.totalnt, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get totalttc => $composableBuilder(
      column: $table.totalttc, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get tva => $composableBuilder(
      column: $table.tva, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get contre => $composableBuilder(
      column: $table.contre, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get bq => $composableBuilder(
      column: $table.bq, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get regl => $composableBuilder(
      column: $table.regl, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get datregl => $composableBuilder(
      column: $table.datregl, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get mregl => $composableBuilder(
      column: $table.mregl, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get verification => $composableBuilder(
      column: $table.verification, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get as => $composableBuilder(
      column: $table.as, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get emb => $composableBuilder(
      column: $table.emb, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get transp => $composableBuilder(
      column: $table.transp, builder: (column) => ColumnFilters(column));
}

class $$AchatsTableOrderingComposer
    extends Composer<_$AppDatabase, $AchatsTable> {
  $$AchatsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get num => $composableBuilder(
      column: $table.num, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get numachats => $composableBuilder(
      column: $table.numachats, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nfact => $composableBuilder(
      column: $table.nfact, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get frns => $composableBuilder(
      column: $table.frns, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get modepai => $composableBuilder(
      column: $table.modepai, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get echeance => $composableBuilder(
      column: $table.echeance, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get totalnt => $composableBuilder(
      column: $table.totalnt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get totalttc => $composableBuilder(
      column: $table.totalttc, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get tva => $composableBuilder(
      column: $table.tva, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get contre => $composableBuilder(
      column: $table.contre, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get bq => $composableBuilder(
      column: $table.bq, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get regl => $composableBuilder(
      column: $table.regl, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get datregl => $composableBuilder(
      column: $table.datregl, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get mregl => $composableBuilder(
      column: $table.mregl, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get verification => $composableBuilder(
      column: $table.verification,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get as => $composableBuilder(
      column: $table.as, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get emb => $composableBuilder(
      column: $table.emb, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get transp => $composableBuilder(
      column: $table.transp, builder: (column) => ColumnOrderings(column));
}

class $$AchatsTableAnnotationComposer
    extends Composer<_$AppDatabase, $AchatsTable> {
  $$AchatsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get num =>
      $composableBuilder(column: $table.num, builder: (column) => column);

  GeneratedColumn<String> get numachats =>
      $composableBuilder(column: $table.numachats, builder: (column) => column);

  GeneratedColumn<String> get nfact =>
      $composableBuilder(column: $table.nfact, builder: (column) => column);

  GeneratedColumn<DateTime> get daty =>
      $composableBuilder(column: $table.daty, builder: (column) => column);

  GeneratedColumn<String> get frns =>
      $composableBuilder(column: $table.frns, builder: (column) => column);

  GeneratedColumn<String> get modepai =>
      $composableBuilder(column: $table.modepai, builder: (column) => column);

  GeneratedColumn<DateTime> get echeance =>
      $composableBuilder(column: $table.echeance, builder: (column) => column);

  GeneratedColumn<double> get totalnt =>
      $composableBuilder(column: $table.totalnt, builder: (column) => column);

  GeneratedColumn<double> get totalttc =>
      $composableBuilder(column: $table.totalttc, builder: (column) => column);

  GeneratedColumn<double> get tva =>
      $composableBuilder(column: $table.tva, builder: (column) => column);

  GeneratedColumn<String> get contre =>
      $composableBuilder(column: $table.contre, builder: (column) => column);

  GeneratedColumn<String> get bq =>
      $composableBuilder(column: $table.bq, builder: (column) => column);

  GeneratedColumn<double> get regl =>
      $composableBuilder(column: $table.regl, builder: (column) => column);

  GeneratedColumn<DateTime> get datregl =>
      $composableBuilder(column: $table.datregl, builder: (column) => column);

  GeneratedColumn<String> get mregl =>
      $composableBuilder(column: $table.mregl, builder: (column) => column);

  GeneratedColumn<String> get verification => $composableBuilder(
      column: $table.verification, builder: (column) => column);

  GeneratedColumn<String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  GeneratedColumn<String> get as =>
      $composableBuilder(column: $table.as, builder: (column) => column);

  GeneratedColumn<String> get emb =>
      $composableBuilder(column: $table.emb, builder: (column) => column);

  GeneratedColumn<String> get transp =>
      $composableBuilder(column: $table.transp, builder: (column) => column);
}

class $$AchatsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $AchatsTable,
    Achat,
    $$AchatsTableFilterComposer,
    $$AchatsTableOrderingComposer,
    $$AchatsTableAnnotationComposer,
    $$AchatsTableCreateCompanionBuilder,
    $$AchatsTableUpdateCompanionBuilder,
    (Achat, BaseReferences<_$AppDatabase, $AchatsTable, Achat>),
    Achat,
    PrefetchHooks Function()> {
  $$AchatsTableTableManager(_$AppDatabase db, $AchatsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$AchatsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$AchatsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$AchatsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> num = const Value.absent(),
            Value<String?> numachats = const Value.absent(),
            Value<String?> nfact = const Value.absent(),
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> frns = const Value.absent(),
            Value<String?> modepai = const Value.absent(),
            Value<DateTime?> echeance = const Value.absent(),
            Value<double?> totalnt = const Value.absent(),
            Value<double?> totalttc = const Value.absent(),
            Value<double?> tva = const Value.absent(),
            Value<String?> contre = const Value.absent(),
            Value<String?> bq = const Value.absent(),
            Value<double?> regl = const Value.absent(),
            Value<DateTime?> datregl = const Value.absent(),
            Value<String?> mregl = const Value.absent(),
            Value<String?> verification = const Value.absent(),
            Value<String?> type = const Value.absent(),
            Value<String?> as = const Value.absent(),
            Value<String?> emb = const Value.absent(),
            Value<String?> transp = const Value.absent(),
          }) =>
              AchatsCompanion(
            num: num,
            numachats: numachats,
            nfact: nfact,
            daty: daty,
            frns: frns,
            modepai: modepai,
            echeance: echeance,
            totalnt: totalnt,
            totalttc: totalttc,
            tva: tva,
            contre: contre,
            bq: bq,
            regl: regl,
            datregl: datregl,
            mregl: mregl,
            verification: verification,
            type: type,
            as: as,
            emb: emb,
            transp: transp,
          ),
          createCompanionCallback: ({
            Value<int> num = const Value.absent(),
            Value<String?> numachats = const Value.absent(),
            Value<String?> nfact = const Value.absent(),
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> frns = const Value.absent(),
            Value<String?> modepai = const Value.absent(),
            Value<DateTime?> echeance = const Value.absent(),
            Value<double?> totalnt = const Value.absent(),
            Value<double?> totalttc = const Value.absent(),
            Value<double?> tva = const Value.absent(),
            Value<String?> contre = const Value.absent(),
            Value<String?> bq = const Value.absent(),
            Value<double?> regl = const Value.absent(),
            Value<DateTime?> datregl = const Value.absent(),
            Value<String?> mregl = const Value.absent(),
            Value<String?> verification = const Value.absent(),
            Value<String?> type = const Value.absent(),
            Value<String?> as = const Value.absent(),
            Value<String?> emb = const Value.absent(),
            Value<String?> transp = const Value.absent(),
          }) =>
              AchatsCompanion.insert(
            num: num,
            numachats: numachats,
            nfact: nfact,
            daty: daty,
            frns: frns,
            modepai: modepai,
            echeance: echeance,
            totalnt: totalnt,
            totalttc: totalttc,
            tva: tva,
            contre: contre,
            bq: bq,
            regl: regl,
            datregl: datregl,
            mregl: mregl,
            verification: verification,
            type: type,
            as: as,
            emb: emb,
            transp: transp,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$AchatsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $AchatsTable,
    Achat,
    $$AchatsTableFilterComposer,
    $$AchatsTableOrderingComposer,
    $$AchatsTableAnnotationComposer,
    $$AchatsTableCreateCompanionBuilder,
    $$AchatsTableUpdateCompanionBuilder,
    (Achat, BaseReferences<_$AppDatabase, $AchatsTable, Achat>),
    Achat,
    PrefetchHooks Function()>;
typedef $$StocksTableCreateCompanionBuilder = StocksCompanion Function({
  required String ref,
  Value<DateTime?> daty,
  Value<String?> lib,
  Value<String?> numachats,
  Value<String?> nfact,
  Value<String?> refart,
  Value<double?> qe,
  Value<double?> entres,
  Value<double?> qs,
  Value<double?> pus,
  Value<double?> sortie,
  Value<double?> stocksu1,
  Value<String?> numventes,
  Value<String?> ue,
  Value<String?> us,
  Value<double?> stocksu2,
  Value<double?> stocksu3,
  Value<String?> depots,
  Value<double?> cmup,
  Value<String?> clt,
  Value<String?> frns,
  Value<String?> verification,
  Value<double?> stkdep,
  Value<String?> marq,
  Value<int> rowid,
});
typedef $$StocksTableUpdateCompanionBuilder = StocksCompanion Function({
  Value<String> ref,
  Value<DateTime?> daty,
  Value<String?> lib,
  Value<String?> numachats,
  Value<String?> nfact,
  Value<String?> refart,
  Value<double?> qe,
  Value<double?> entres,
  Value<double?> qs,
  Value<double?> pus,
  Value<double?> sortie,
  Value<double?> stocksu1,
  Value<String?> numventes,
  Value<String?> ue,
  Value<String?> us,
  Value<double?> stocksu2,
  Value<double?> stocksu3,
  Value<String?> depots,
  Value<double?> cmup,
  Value<String?> clt,
  Value<String?> frns,
  Value<String?> verification,
  Value<double?> stkdep,
  Value<String?> marq,
  Value<int> rowid,
});

class $$StocksTableFilterComposer
    extends Composer<_$AppDatabase, $StocksTable> {
  $$StocksTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get ref => $composableBuilder(
      column: $table.ref, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get lib => $composableBuilder(
      column: $table.lib, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get numachats => $composableBuilder(
      column: $table.numachats, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nfact => $composableBuilder(
      column: $table.nfact, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get refart => $composableBuilder(
      column: $table.refart, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get qe => $composableBuilder(
      column: $table.qe, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get entres => $composableBuilder(
      column: $table.entres, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get qs => $composableBuilder(
      column: $table.qs, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get pus => $composableBuilder(
      column: $table.pus, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get sortie => $composableBuilder(
      column: $table.sortie, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get stocksu1 => $composableBuilder(
      column: $table.stocksu1, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get numventes => $composableBuilder(
      column: $table.numventes, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get ue => $composableBuilder(
      column: $table.ue, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get us => $composableBuilder(
      column: $table.us, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get stocksu2 => $composableBuilder(
      column: $table.stocksu2, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get stocksu3 => $composableBuilder(
      column: $table.stocksu3, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get depots => $composableBuilder(
      column: $table.depots, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get cmup => $composableBuilder(
      column: $table.cmup, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get clt => $composableBuilder(
      column: $table.clt, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get frns => $composableBuilder(
      column: $table.frns, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get verification => $composableBuilder(
      column: $table.verification, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get stkdep => $composableBuilder(
      column: $table.stkdep, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get marq => $composableBuilder(
      column: $table.marq, builder: (column) => ColumnFilters(column));
}

class $$StocksTableOrderingComposer
    extends Composer<_$AppDatabase, $StocksTable> {
  $$StocksTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get ref => $composableBuilder(
      column: $table.ref, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get lib => $composableBuilder(
      column: $table.lib, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get numachats => $composableBuilder(
      column: $table.numachats, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nfact => $composableBuilder(
      column: $table.nfact, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get refart => $composableBuilder(
      column: $table.refart, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get qe => $composableBuilder(
      column: $table.qe, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get entres => $composableBuilder(
      column: $table.entres, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get qs => $composableBuilder(
      column: $table.qs, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get pus => $composableBuilder(
      column: $table.pus, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get sortie => $composableBuilder(
      column: $table.sortie, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get stocksu1 => $composableBuilder(
      column: $table.stocksu1, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get numventes => $composableBuilder(
      column: $table.numventes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get ue => $composableBuilder(
      column: $table.ue, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get us => $composableBuilder(
      column: $table.us, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get stocksu2 => $composableBuilder(
      column: $table.stocksu2, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get stocksu3 => $composableBuilder(
      column: $table.stocksu3, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get depots => $composableBuilder(
      column: $table.depots, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get cmup => $composableBuilder(
      column: $table.cmup, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get clt => $composableBuilder(
      column: $table.clt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get frns => $composableBuilder(
      column: $table.frns, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get verification => $composableBuilder(
      column: $table.verification,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get stkdep => $composableBuilder(
      column: $table.stkdep, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get marq => $composableBuilder(
      column: $table.marq, builder: (column) => ColumnOrderings(column));
}

class $$StocksTableAnnotationComposer
    extends Composer<_$AppDatabase, $StocksTable> {
  $$StocksTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get ref =>
      $composableBuilder(column: $table.ref, builder: (column) => column);

  GeneratedColumn<DateTime> get daty =>
      $composableBuilder(column: $table.daty, builder: (column) => column);

  GeneratedColumn<String> get lib =>
      $composableBuilder(column: $table.lib, builder: (column) => column);

  GeneratedColumn<String> get numachats =>
      $composableBuilder(column: $table.numachats, builder: (column) => column);

  GeneratedColumn<String> get nfact =>
      $composableBuilder(column: $table.nfact, builder: (column) => column);

  GeneratedColumn<String> get refart =>
      $composableBuilder(column: $table.refart, builder: (column) => column);

  GeneratedColumn<double> get qe =>
      $composableBuilder(column: $table.qe, builder: (column) => column);

  GeneratedColumn<double> get entres =>
      $composableBuilder(column: $table.entres, builder: (column) => column);

  GeneratedColumn<double> get qs =>
      $composableBuilder(column: $table.qs, builder: (column) => column);

  GeneratedColumn<double> get pus =>
      $composableBuilder(column: $table.pus, builder: (column) => column);

  GeneratedColumn<double> get sortie =>
      $composableBuilder(column: $table.sortie, builder: (column) => column);

  GeneratedColumn<double> get stocksu1 =>
      $composableBuilder(column: $table.stocksu1, builder: (column) => column);

  GeneratedColumn<String> get numventes =>
      $composableBuilder(column: $table.numventes, builder: (column) => column);

  GeneratedColumn<String> get ue =>
      $composableBuilder(column: $table.ue, builder: (column) => column);

  GeneratedColumn<String> get us =>
      $composableBuilder(column: $table.us, builder: (column) => column);

  GeneratedColumn<double> get stocksu2 =>
      $composableBuilder(column: $table.stocksu2, builder: (column) => column);

  GeneratedColumn<double> get stocksu3 =>
      $composableBuilder(column: $table.stocksu3, builder: (column) => column);

  GeneratedColumn<String> get depots =>
      $composableBuilder(column: $table.depots, builder: (column) => column);

  GeneratedColumn<double> get cmup =>
      $composableBuilder(column: $table.cmup, builder: (column) => column);

  GeneratedColumn<String> get clt =>
      $composableBuilder(column: $table.clt, builder: (column) => column);

  GeneratedColumn<String> get frns =>
      $composableBuilder(column: $table.frns, builder: (column) => column);

  GeneratedColumn<String> get verification => $composableBuilder(
      column: $table.verification, builder: (column) => column);

  GeneratedColumn<double> get stkdep =>
      $composableBuilder(column: $table.stkdep, builder: (column) => column);

  GeneratedColumn<String> get marq =>
      $composableBuilder(column: $table.marq, builder: (column) => column);
}

class $$StocksTableTableManager extends RootTableManager<
    _$AppDatabase,
    $StocksTable,
    Stock,
    $$StocksTableFilterComposer,
    $$StocksTableOrderingComposer,
    $$StocksTableAnnotationComposer,
    $$StocksTableCreateCompanionBuilder,
    $$StocksTableUpdateCompanionBuilder,
    (Stock, BaseReferences<_$AppDatabase, $StocksTable, Stock>),
    Stock,
    PrefetchHooks Function()> {
  $$StocksTableTableManager(_$AppDatabase db, $StocksTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$StocksTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$StocksTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$StocksTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> ref = const Value.absent(),
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> lib = const Value.absent(),
            Value<String?> numachats = const Value.absent(),
            Value<String?> nfact = const Value.absent(),
            Value<String?> refart = const Value.absent(),
            Value<double?> qe = const Value.absent(),
            Value<double?> entres = const Value.absent(),
            Value<double?> qs = const Value.absent(),
            Value<double?> pus = const Value.absent(),
            Value<double?> sortie = const Value.absent(),
            Value<double?> stocksu1 = const Value.absent(),
            Value<String?> numventes = const Value.absent(),
            Value<String?> ue = const Value.absent(),
            Value<String?> us = const Value.absent(),
            Value<double?> stocksu2 = const Value.absent(),
            Value<double?> stocksu3 = const Value.absent(),
            Value<String?> depots = const Value.absent(),
            Value<double?> cmup = const Value.absent(),
            Value<String?> clt = const Value.absent(),
            Value<String?> frns = const Value.absent(),
            Value<String?> verification = const Value.absent(),
            Value<double?> stkdep = const Value.absent(),
            Value<String?> marq = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              StocksCompanion(
            ref: ref,
            daty: daty,
            lib: lib,
            numachats: numachats,
            nfact: nfact,
            refart: refart,
            qe: qe,
            entres: entres,
            qs: qs,
            pus: pus,
            sortie: sortie,
            stocksu1: stocksu1,
            numventes: numventes,
            ue: ue,
            us: us,
            stocksu2: stocksu2,
            stocksu3: stocksu3,
            depots: depots,
            cmup: cmup,
            clt: clt,
            frns: frns,
            verification: verification,
            stkdep: stkdep,
            marq: marq,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String ref,
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> lib = const Value.absent(),
            Value<String?> numachats = const Value.absent(),
            Value<String?> nfact = const Value.absent(),
            Value<String?> refart = const Value.absent(),
            Value<double?> qe = const Value.absent(),
            Value<double?> entres = const Value.absent(),
            Value<double?> qs = const Value.absent(),
            Value<double?> pus = const Value.absent(),
            Value<double?> sortie = const Value.absent(),
            Value<double?> stocksu1 = const Value.absent(),
            Value<String?> numventes = const Value.absent(),
            Value<String?> ue = const Value.absent(),
            Value<String?> us = const Value.absent(),
            Value<double?> stocksu2 = const Value.absent(),
            Value<double?> stocksu3 = const Value.absent(),
            Value<String?> depots = const Value.absent(),
            Value<double?> cmup = const Value.absent(),
            Value<String?> clt = const Value.absent(),
            Value<String?> frns = const Value.absent(),
            Value<String?> verification = const Value.absent(),
            Value<double?> stkdep = const Value.absent(),
            Value<String?> marq = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              StocksCompanion.insert(
            ref: ref,
            daty: daty,
            lib: lib,
            numachats: numachats,
            nfact: nfact,
            refart: refart,
            qe: qe,
            entres: entres,
            qs: qs,
            pus: pus,
            sortie: sortie,
            stocksu1: stocksu1,
            numventes: numventes,
            ue: ue,
            us: us,
            stocksu2: stocksu2,
            stocksu3: stocksu3,
            depots: depots,
            cmup: cmup,
            clt: clt,
            frns: frns,
            verification: verification,
            stkdep: stkdep,
            marq: marq,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$StocksTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $StocksTable,
    Stock,
    $$StocksTableFilterComposer,
    $$StocksTableOrderingComposer,
    $$StocksTableAnnotationComposer,
    $$StocksTableCreateCompanionBuilder,
    $$StocksTableUpdateCompanionBuilder,
    (Stock, BaseReferences<_$AppDatabase, $StocksTable, Stock>),
    Stock,
    PrefetchHooks Function()>;
typedef $$AutrescompteTableCreateCompanionBuilder = AutrescompteCompanion
    Function({
  required String ref,
  Value<DateTime?> daty,
  Value<String?> lib,
  Value<String?> code,
  Value<String?> compte,
  Value<double?> entres,
  Value<double?> sortie,
  Value<double?> solde,
  Value<int> rowid,
});
typedef $$AutrescompteTableUpdateCompanionBuilder = AutrescompteCompanion
    Function({
  Value<String> ref,
  Value<DateTime?> daty,
  Value<String?> lib,
  Value<String?> code,
  Value<String?> compte,
  Value<double?> entres,
  Value<double?> sortie,
  Value<double?> solde,
  Value<int> rowid,
});

class $$AutrescompteTableFilterComposer
    extends Composer<_$AppDatabase, $AutrescompteTable> {
  $$AutrescompteTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get ref => $composableBuilder(
      column: $table.ref, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get lib => $composableBuilder(
      column: $table.lib, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get compte => $composableBuilder(
      column: $table.compte, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get entres => $composableBuilder(
      column: $table.entres, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get sortie => $composableBuilder(
      column: $table.sortie, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get solde => $composableBuilder(
      column: $table.solde, builder: (column) => ColumnFilters(column));
}

class $$AutrescompteTableOrderingComposer
    extends Composer<_$AppDatabase, $AutrescompteTable> {
  $$AutrescompteTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get ref => $composableBuilder(
      column: $table.ref, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get lib => $composableBuilder(
      column: $table.lib, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get compte => $composableBuilder(
      column: $table.compte, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get entres => $composableBuilder(
      column: $table.entres, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get sortie => $composableBuilder(
      column: $table.sortie, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get solde => $composableBuilder(
      column: $table.solde, builder: (column) => ColumnOrderings(column));
}

class $$AutrescompteTableAnnotationComposer
    extends Composer<_$AppDatabase, $AutrescompteTable> {
  $$AutrescompteTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get ref =>
      $composableBuilder(column: $table.ref, builder: (column) => column);

  GeneratedColumn<DateTime> get daty =>
      $composableBuilder(column: $table.daty, builder: (column) => column);

  GeneratedColumn<String> get lib =>
      $composableBuilder(column: $table.lib, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get compte =>
      $composableBuilder(column: $table.compte, builder: (column) => column);

  GeneratedColumn<double> get entres =>
      $composableBuilder(column: $table.entres, builder: (column) => column);

  GeneratedColumn<double> get sortie =>
      $composableBuilder(column: $table.sortie, builder: (column) => column);

  GeneratedColumn<double> get solde =>
      $composableBuilder(column: $table.solde, builder: (column) => column);
}

class $$AutrescompteTableTableManager extends RootTableManager<
    _$AppDatabase,
    $AutrescompteTable,
    AutrescompteData,
    $$AutrescompteTableFilterComposer,
    $$AutrescompteTableOrderingComposer,
    $$AutrescompteTableAnnotationComposer,
    $$AutrescompteTableCreateCompanionBuilder,
    $$AutrescompteTableUpdateCompanionBuilder,
    (
      AutrescompteData,
      BaseReferences<_$AppDatabase, $AutrescompteTable, AutrescompteData>
    ),
    AutrescompteData,
    PrefetchHooks Function()> {
  $$AutrescompteTableTableManager(_$AppDatabase db, $AutrescompteTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$AutrescompteTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$AutrescompteTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$AutrescompteTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> ref = const Value.absent(),
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> lib = const Value.absent(),
            Value<String?> code = const Value.absent(),
            Value<String?> compte = const Value.absent(),
            Value<double?> entres = const Value.absent(),
            Value<double?> sortie = const Value.absent(),
            Value<double?> solde = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              AutrescompteCompanion(
            ref: ref,
            daty: daty,
            lib: lib,
            code: code,
            compte: compte,
            entres: entres,
            sortie: sortie,
            solde: solde,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String ref,
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> lib = const Value.absent(),
            Value<String?> code = const Value.absent(),
            Value<String?> compte = const Value.absent(),
            Value<double?> entres = const Value.absent(),
            Value<double?> sortie = const Value.absent(),
            Value<double?> solde = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              AutrescompteCompanion.insert(
            ref: ref,
            daty: daty,
            lib: lib,
            code: code,
            compte: compte,
            entres: entres,
            sortie: sortie,
            solde: solde,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$AutrescompteTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $AutrescompteTable,
    AutrescompteData,
    $$AutrescompteTableFilterComposer,
    $$AutrescompteTableOrderingComposer,
    $$AutrescompteTableAnnotationComposer,
    $$AutrescompteTableCreateCompanionBuilder,
    $$AutrescompteTableUpdateCompanionBuilder,
    (
      AutrescompteData,
      BaseReferences<_$AppDatabase, $AutrescompteTable, AutrescompteData>
    ),
    AutrescompteData,
    PrefetchHooks Function()>;
typedef $$BanqueTableCreateCompanionBuilder = BanqueCompanion Function({
  required String ref,
  Value<DateTime?> daty,
  Value<String?> lib,
  Value<double?> debit,
  Value<double?> credit,
  Value<double?> soldes,
  Value<String?> code,
  Value<String?> type,
  Value<String?> clt,
  Value<String?> frns,
  Value<String?> verification,
  Value<String?> comptes,
  Value<int> rowid,
});
typedef $$BanqueTableUpdateCompanionBuilder = BanqueCompanion Function({
  Value<String> ref,
  Value<DateTime?> daty,
  Value<String?> lib,
  Value<double?> debit,
  Value<double?> credit,
  Value<double?> soldes,
  Value<String?> code,
  Value<String?> type,
  Value<String?> clt,
  Value<String?> frns,
  Value<String?> verification,
  Value<String?> comptes,
  Value<int> rowid,
});

class $$BanqueTableFilterComposer
    extends Composer<_$AppDatabase, $BanqueTable> {
  $$BanqueTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get ref => $composableBuilder(
      column: $table.ref, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get lib => $composableBuilder(
      column: $table.lib, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get debit => $composableBuilder(
      column: $table.debit, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get credit => $composableBuilder(
      column: $table.credit, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get soldes => $composableBuilder(
      column: $table.soldes, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get clt => $composableBuilder(
      column: $table.clt, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get frns => $composableBuilder(
      column: $table.frns, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get verification => $composableBuilder(
      column: $table.verification, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get comptes => $composableBuilder(
      column: $table.comptes, builder: (column) => ColumnFilters(column));
}

class $$BanqueTableOrderingComposer
    extends Composer<_$AppDatabase, $BanqueTable> {
  $$BanqueTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get ref => $composableBuilder(
      column: $table.ref, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get lib => $composableBuilder(
      column: $table.lib, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get debit => $composableBuilder(
      column: $table.debit, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get credit => $composableBuilder(
      column: $table.credit, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get soldes => $composableBuilder(
      column: $table.soldes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get clt => $composableBuilder(
      column: $table.clt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get frns => $composableBuilder(
      column: $table.frns, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get verification => $composableBuilder(
      column: $table.verification,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get comptes => $composableBuilder(
      column: $table.comptes, builder: (column) => ColumnOrderings(column));
}

class $$BanqueTableAnnotationComposer
    extends Composer<_$AppDatabase, $BanqueTable> {
  $$BanqueTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get ref =>
      $composableBuilder(column: $table.ref, builder: (column) => column);

  GeneratedColumn<DateTime> get daty =>
      $composableBuilder(column: $table.daty, builder: (column) => column);

  GeneratedColumn<String> get lib =>
      $composableBuilder(column: $table.lib, builder: (column) => column);

  GeneratedColumn<double> get debit =>
      $composableBuilder(column: $table.debit, builder: (column) => column);

  GeneratedColumn<double> get credit =>
      $composableBuilder(column: $table.credit, builder: (column) => column);

  GeneratedColumn<double> get soldes =>
      $composableBuilder(column: $table.soldes, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  GeneratedColumn<String> get clt =>
      $composableBuilder(column: $table.clt, builder: (column) => column);

  GeneratedColumn<String> get frns =>
      $composableBuilder(column: $table.frns, builder: (column) => column);

  GeneratedColumn<String> get verification => $composableBuilder(
      column: $table.verification, builder: (column) => column);

  GeneratedColumn<String> get comptes =>
      $composableBuilder(column: $table.comptes, builder: (column) => column);
}

class $$BanqueTableTableManager extends RootTableManager<
    _$AppDatabase,
    $BanqueTable,
    BanqueData,
    $$BanqueTableFilterComposer,
    $$BanqueTableOrderingComposer,
    $$BanqueTableAnnotationComposer,
    $$BanqueTableCreateCompanionBuilder,
    $$BanqueTableUpdateCompanionBuilder,
    (BanqueData, BaseReferences<_$AppDatabase, $BanqueTable, BanqueData>),
    BanqueData,
    PrefetchHooks Function()> {
  $$BanqueTableTableManager(_$AppDatabase db, $BanqueTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BanqueTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BanqueTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BanqueTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> ref = const Value.absent(),
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> lib = const Value.absent(),
            Value<double?> debit = const Value.absent(),
            Value<double?> credit = const Value.absent(),
            Value<double?> soldes = const Value.absent(),
            Value<String?> code = const Value.absent(),
            Value<String?> type = const Value.absent(),
            Value<String?> clt = const Value.absent(),
            Value<String?> frns = const Value.absent(),
            Value<String?> verification = const Value.absent(),
            Value<String?> comptes = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              BanqueCompanion(
            ref: ref,
            daty: daty,
            lib: lib,
            debit: debit,
            credit: credit,
            soldes: soldes,
            code: code,
            type: type,
            clt: clt,
            frns: frns,
            verification: verification,
            comptes: comptes,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String ref,
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> lib = const Value.absent(),
            Value<double?> debit = const Value.absent(),
            Value<double?> credit = const Value.absent(),
            Value<double?> soldes = const Value.absent(),
            Value<String?> code = const Value.absent(),
            Value<String?> type = const Value.absent(),
            Value<String?> clt = const Value.absent(),
            Value<String?> frns = const Value.absent(),
            Value<String?> verification = const Value.absent(),
            Value<String?> comptes = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              BanqueCompanion.insert(
            ref: ref,
            daty: daty,
            lib: lib,
            debit: debit,
            credit: credit,
            soldes: soldes,
            code: code,
            type: type,
            clt: clt,
            frns: frns,
            verification: verification,
            comptes: comptes,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$BanqueTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $BanqueTable,
    BanqueData,
    $$BanqueTableFilterComposer,
    $$BanqueTableOrderingComposer,
    $$BanqueTableAnnotationComposer,
    $$BanqueTableCreateCompanionBuilder,
    $$BanqueTableUpdateCompanionBuilder,
    (BanqueData, BaseReferences<_$AppDatabase, $BanqueTable, BanqueData>),
    BanqueData,
    PrefetchHooks Function()>;
typedef $$BlcltTableCreateCompanionBuilder = BlcltCompanion Function({
  Value<int> num,
  Value<String?> numventes,
  Value<String?> nfact,
  Value<DateTime?> daty,
  Value<String?> clt,
  Value<String?> ecrptancebi,
  Value<double?> montant,
  Value<String?> mp,
  Value<String?> libpaiement,
  Value<DateTime?> echeancepaiement,
  Value<double?> rap,
  Value<String?> com,
  Value<String?> verification,
});
typedef $$BlcltTableUpdateCompanionBuilder = BlcltCompanion Function({
  Value<int> num,
  Value<String?> numventes,
  Value<String?> nfact,
  Value<DateTime?> daty,
  Value<String?> clt,
  Value<String?> ecrptancebi,
  Value<double?> montant,
  Value<String?> mp,
  Value<String?> libpaiement,
  Value<DateTime?> echeancepaiement,
  Value<double?> rap,
  Value<String?> com,
  Value<String?> verification,
});

class $$BlcltTableFilterComposer extends Composer<_$AppDatabase, $BlcltTable> {
  $$BlcltTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get num => $composableBuilder(
      column: $table.num, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get numventes => $composableBuilder(
      column: $table.numventes, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nfact => $composableBuilder(
      column: $table.nfact, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get clt => $composableBuilder(
      column: $table.clt, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get ecrptancebi => $composableBuilder(
      column: $table.ecrptancebi, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get montant => $composableBuilder(
      column: $table.montant, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get mp => $composableBuilder(
      column: $table.mp, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get libpaiement => $composableBuilder(
      column: $table.libpaiement, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get echeancepaiement => $composableBuilder(
      column: $table.echeancepaiement,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get rap => $composableBuilder(
      column: $table.rap, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get com => $composableBuilder(
      column: $table.com, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get verification => $composableBuilder(
      column: $table.verification, builder: (column) => ColumnFilters(column));
}

class $$BlcltTableOrderingComposer
    extends Composer<_$AppDatabase, $BlcltTable> {
  $$BlcltTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get num => $composableBuilder(
      column: $table.num, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get numventes => $composableBuilder(
      column: $table.numventes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nfact => $composableBuilder(
      column: $table.nfact, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get clt => $composableBuilder(
      column: $table.clt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get ecrptancebi => $composableBuilder(
      column: $table.ecrptancebi, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get montant => $composableBuilder(
      column: $table.montant, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get mp => $composableBuilder(
      column: $table.mp, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get libpaiement => $composableBuilder(
      column: $table.libpaiement, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get echeancepaiement => $composableBuilder(
      column: $table.echeancepaiement,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get rap => $composableBuilder(
      column: $table.rap, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get com => $composableBuilder(
      column: $table.com, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get verification => $composableBuilder(
      column: $table.verification,
      builder: (column) => ColumnOrderings(column));
}

class $$BlcltTableAnnotationComposer
    extends Composer<_$AppDatabase, $BlcltTable> {
  $$BlcltTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get num =>
      $composableBuilder(column: $table.num, builder: (column) => column);

  GeneratedColumn<String> get numventes =>
      $composableBuilder(column: $table.numventes, builder: (column) => column);

  GeneratedColumn<String> get nfact =>
      $composableBuilder(column: $table.nfact, builder: (column) => column);

  GeneratedColumn<DateTime> get daty =>
      $composableBuilder(column: $table.daty, builder: (column) => column);

  GeneratedColumn<String> get clt =>
      $composableBuilder(column: $table.clt, builder: (column) => column);

  GeneratedColumn<String> get ecrptancebi => $composableBuilder(
      column: $table.ecrptancebi, builder: (column) => column);

  GeneratedColumn<double> get montant =>
      $composableBuilder(column: $table.montant, builder: (column) => column);

  GeneratedColumn<String> get mp =>
      $composableBuilder(column: $table.mp, builder: (column) => column);

  GeneratedColumn<String> get libpaiement => $composableBuilder(
      column: $table.libpaiement, builder: (column) => column);

  GeneratedColumn<DateTime> get echeancepaiement => $composableBuilder(
      column: $table.echeancepaiement, builder: (column) => column);

  GeneratedColumn<double> get rap =>
      $composableBuilder(column: $table.rap, builder: (column) => column);

  GeneratedColumn<String> get com =>
      $composableBuilder(column: $table.com, builder: (column) => column);

  GeneratedColumn<String> get verification => $composableBuilder(
      column: $table.verification, builder: (column) => column);
}

class $$BlcltTableTableManager extends RootTableManager<
    _$AppDatabase,
    $BlcltTable,
    BlcltData,
    $$BlcltTableFilterComposer,
    $$BlcltTableOrderingComposer,
    $$BlcltTableAnnotationComposer,
    $$BlcltTableCreateCompanionBuilder,
    $$BlcltTableUpdateCompanionBuilder,
    (BlcltData, BaseReferences<_$AppDatabase, $BlcltTable, BlcltData>),
    BlcltData,
    PrefetchHooks Function()> {
  $$BlcltTableTableManager(_$AppDatabase db, $BlcltTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BlcltTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BlcltTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BlcltTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> num = const Value.absent(),
            Value<String?> numventes = const Value.absent(),
            Value<String?> nfact = const Value.absent(),
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> clt = const Value.absent(),
            Value<String?> ecrptancebi = const Value.absent(),
            Value<double?> montant = const Value.absent(),
            Value<String?> mp = const Value.absent(),
            Value<String?> libpaiement = const Value.absent(),
            Value<DateTime?> echeancepaiement = const Value.absent(),
            Value<double?> rap = const Value.absent(),
            Value<String?> com = const Value.absent(),
            Value<String?> verification = const Value.absent(),
          }) =>
              BlcltCompanion(
            num: num,
            numventes: numventes,
            nfact: nfact,
            daty: daty,
            clt: clt,
            ecrptancebi: ecrptancebi,
            montant: montant,
            mp: mp,
            libpaiement: libpaiement,
            echeancepaiement: echeancepaiement,
            rap: rap,
            com: com,
            verification: verification,
          ),
          createCompanionCallback: ({
            Value<int> num = const Value.absent(),
            Value<String?> numventes = const Value.absent(),
            Value<String?> nfact = const Value.absent(),
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> clt = const Value.absent(),
            Value<String?> ecrptancebi = const Value.absent(),
            Value<double?> montant = const Value.absent(),
            Value<String?> mp = const Value.absent(),
            Value<String?> libpaiement = const Value.absent(),
            Value<DateTime?> echeancepaiement = const Value.absent(),
            Value<double?> rap = const Value.absent(),
            Value<String?> com = const Value.absent(),
            Value<String?> verification = const Value.absent(),
          }) =>
              BlcltCompanion.insert(
            num: num,
            numventes: numventes,
            nfact: nfact,
            daty: daty,
            clt: clt,
            ecrptancebi: ecrptancebi,
            montant: montant,
            mp: mp,
            libpaiement: libpaiement,
            echeancepaiement: echeancepaiement,
            rap: rap,
            com: com,
            verification: verification,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$BlcltTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $BlcltTable,
    BlcltData,
    $$BlcltTableFilterComposer,
    $$BlcltTableOrderingComposer,
    $$BlcltTableAnnotationComposer,
    $$BlcltTableCreateCompanionBuilder,
    $$BlcltTableUpdateCompanionBuilder,
    (BlcltData, BaseReferences<_$AppDatabase, $BlcltTable, BlcltData>),
    BlcltData,
    PrefetchHooks Function()>;
typedef $$BqTableCreateCompanionBuilder = BqCompanion Function({
  required String code,
  Value<String?> intitule,
  Value<String?> nCompte,
  Value<double?> soldes,
  Value<int> rowid,
});
typedef $$BqTableUpdateCompanionBuilder = BqCompanion Function({
  Value<String> code,
  Value<String?> intitule,
  Value<String?> nCompte,
  Value<double?> soldes,
  Value<int> rowid,
});

class $$BqTableFilterComposer extends Composer<_$AppDatabase, $BqTable> {
  $$BqTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get intitule => $composableBuilder(
      column: $table.intitule, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nCompte => $composableBuilder(
      column: $table.nCompte, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get soldes => $composableBuilder(
      column: $table.soldes, builder: (column) => ColumnFilters(column));
}

class $$BqTableOrderingComposer extends Composer<_$AppDatabase, $BqTable> {
  $$BqTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get intitule => $composableBuilder(
      column: $table.intitule, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nCompte => $composableBuilder(
      column: $table.nCompte, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get soldes => $composableBuilder(
      column: $table.soldes, builder: (column) => ColumnOrderings(column));
}

class $$BqTableAnnotationComposer extends Composer<_$AppDatabase, $BqTable> {
  $$BqTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get intitule =>
      $composableBuilder(column: $table.intitule, builder: (column) => column);

  GeneratedColumn<String> get nCompte =>
      $composableBuilder(column: $table.nCompte, builder: (column) => column);

  GeneratedColumn<double> get soldes =>
      $composableBuilder(column: $table.soldes, builder: (column) => column);
}

class $$BqTableTableManager extends RootTableManager<
    _$AppDatabase,
    $BqTable,
    BqData,
    $$BqTableFilterComposer,
    $$BqTableOrderingComposer,
    $$BqTableAnnotationComposer,
    $$BqTableCreateCompanionBuilder,
    $$BqTableUpdateCompanionBuilder,
    (BqData, BaseReferences<_$AppDatabase, $BqTable, BqData>),
    BqData,
    PrefetchHooks Function()> {
  $$BqTableTableManager(_$AppDatabase db, $BqTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BqTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BqTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BqTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> code = const Value.absent(),
            Value<String?> intitule = const Value.absent(),
            Value<String?> nCompte = const Value.absent(),
            Value<double?> soldes = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              BqCompanion(
            code: code,
            intitule: intitule,
            nCompte: nCompte,
            soldes: soldes,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String code,
            Value<String?> intitule = const Value.absent(),
            Value<String?> nCompte = const Value.absent(),
            Value<double?> soldes = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              BqCompanion.insert(
            code: code,
            intitule: intitule,
            nCompte: nCompte,
            soldes: soldes,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$BqTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $BqTable,
    BqData,
    $$BqTableFilterComposer,
    $$BqTableOrderingComposer,
    $$BqTableAnnotationComposer,
    $$BqTableCreateCompanionBuilder,
    $$BqTableUpdateCompanionBuilder,
    (BqData, BaseReferences<_$AppDatabase, $BqTable, BqData>),
    BqData,
    PrefetchHooks Function()>;
typedef $$CaTableCreateCompanionBuilder = CaCompanion Function({
  required String code,
  Value<String?> intitule,
  Value<String?> compte,
  Value<double?> soldes,
  Value<double?> soldesa,
  Value<int> rowid,
});
typedef $$CaTableUpdateCompanionBuilder = CaCompanion Function({
  Value<String> code,
  Value<String?> intitule,
  Value<String?> compte,
  Value<double?> soldes,
  Value<double?> soldesa,
  Value<int> rowid,
});

class $$CaTableFilterComposer extends Composer<_$AppDatabase, $CaTable> {
  $$CaTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get intitule => $composableBuilder(
      column: $table.intitule, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get compte => $composableBuilder(
      column: $table.compte, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get soldes => $composableBuilder(
      column: $table.soldes, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get soldesa => $composableBuilder(
      column: $table.soldesa, builder: (column) => ColumnFilters(column));
}

class $$CaTableOrderingComposer extends Composer<_$AppDatabase, $CaTable> {
  $$CaTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get intitule => $composableBuilder(
      column: $table.intitule, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get compte => $composableBuilder(
      column: $table.compte, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get soldes => $composableBuilder(
      column: $table.soldes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get soldesa => $composableBuilder(
      column: $table.soldesa, builder: (column) => ColumnOrderings(column));
}

class $$CaTableAnnotationComposer extends Composer<_$AppDatabase, $CaTable> {
  $$CaTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get intitule =>
      $composableBuilder(column: $table.intitule, builder: (column) => column);

  GeneratedColumn<String> get compte =>
      $composableBuilder(column: $table.compte, builder: (column) => column);

  GeneratedColumn<double> get soldes =>
      $composableBuilder(column: $table.soldes, builder: (column) => column);

  GeneratedColumn<double> get soldesa =>
      $composableBuilder(column: $table.soldesa, builder: (column) => column);
}

class $$CaTableTableManager extends RootTableManager<
    _$AppDatabase,
    $CaTable,
    CaData,
    $$CaTableFilterComposer,
    $$CaTableOrderingComposer,
    $$CaTableAnnotationComposer,
    $$CaTableCreateCompanionBuilder,
    $$CaTableUpdateCompanionBuilder,
    (CaData, BaseReferences<_$AppDatabase, $CaTable, CaData>),
    CaData,
    PrefetchHooks Function()> {
  $$CaTableTableManager(_$AppDatabase db, $CaTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CaTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CaTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CaTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> code = const Value.absent(),
            Value<String?> intitule = const Value.absent(),
            Value<String?> compte = const Value.absent(),
            Value<double?> soldes = const Value.absent(),
            Value<double?> soldesa = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              CaCompanion(
            code: code,
            intitule: intitule,
            compte: compte,
            soldes: soldes,
            soldesa: soldesa,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String code,
            Value<String?> intitule = const Value.absent(),
            Value<String?> compte = const Value.absent(),
            Value<double?> soldes = const Value.absent(),
            Value<double?> soldesa = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              CaCompanion.insert(
            code: code,
            intitule: intitule,
            compte: compte,
            soldes: soldes,
            soldesa: soldesa,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$CaTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $CaTable,
    CaData,
    $$CaTableFilterComposer,
    $$CaTableOrderingComposer,
    $$CaTableAnnotationComposer,
    $$CaTableCreateCompanionBuilder,
    $$CaTableUpdateCompanionBuilder,
    (CaData, BaseReferences<_$AppDatabase, $CaTable, CaData>),
    CaData,
    PrefetchHooks Function()>;
typedef $$CaisseTableCreateCompanionBuilder = CaisseCompanion Function({
  required String ref,
  Value<DateTime?> daty,
  Value<String?> lib,
  Value<double?> debit,
  Value<double?> credit,
  Value<double?> soldes,
  Value<String?> type,
  Value<String?> clt,
  Value<String?> frns,
  Value<String?> verification,
  Value<String?> comptes,
  Value<int> rowid,
});
typedef $$CaisseTableUpdateCompanionBuilder = CaisseCompanion Function({
  Value<String> ref,
  Value<DateTime?> daty,
  Value<String?> lib,
  Value<double?> debit,
  Value<double?> credit,
  Value<double?> soldes,
  Value<String?> type,
  Value<String?> clt,
  Value<String?> frns,
  Value<String?> verification,
  Value<String?> comptes,
  Value<int> rowid,
});

class $$CaisseTableFilterComposer
    extends Composer<_$AppDatabase, $CaisseTable> {
  $$CaisseTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get ref => $composableBuilder(
      column: $table.ref, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get lib => $composableBuilder(
      column: $table.lib, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get debit => $composableBuilder(
      column: $table.debit, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get credit => $composableBuilder(
      column: $table.credit, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get soldes => $composableBuilder(
      column: $table.soldes, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get clt => $composableBuilder(
      column: $table.clt, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get frns => $composableBuilder(
      column: $table.frns, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get verification => $composableBuilder(
      column: $table.verification, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get comptes => $composableBuilder(
      column: $table.comptes, builder: (column) => ColumnFilters(column));
}

class $$CaisseTableOrderingComposer
    extends Composer<_$AppDatabase, $CaisseTable> {
  $$CaisseTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get ref => $composableBuilder(
      column: $table.ref, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get lib => $composableBuilder(
      column: $table.lib, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get debit => $composableBuilder(
      column: $table.debit, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get credit => $composableBuilder(
      column: $table.credit, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get soldes => $composableBuilder(
      column: $table.soldes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get clt => $composableBuilder(
      column: $table.clt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get frns => $composableBuilder(
      column: $table.frns, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get verification => $composableBuilder(
      column: $table.verification,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get comptes => $composableBuilder(
      column: $table.comptes, builder: (column) => ColumnOrderings(column));
}

class $$CaisseTableAnnotationComposer
    extends Composer<_$AppDatabase, $CaisseTable> {
  $$CaisseTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get ref =>
      $composableBuilder(column: $table.ref, builder: (column) => column);

  GeneratedColumn<DateTime> get daty =>
      $composableBuilder(column: $table.daty, builder: (column) => column);

  GeneratedColumn<String> get lib =>
      $composableBuilder(column: $table.lib, builder: (column) => column);

  GeneratedColumn<double> get debit =>
      $composableBuilder(column: $table.debit, builder: (column) => column);

  GeneratedColumn<double> get credit =>
      $composableBuilder(column: $table.credit, builder: (column) => column);

  GeneratedColumn<double> get soldes =>
      $composableBuilder(column: $table.soldes, builder: (column) => column);

  GeneratedColumn<String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  GeneratedColumn<String> get clt =>
      $composableBuilder(column: $table.clt, builder: (column) => column);

  GeneratedColumn<String> get frns =>
      $composableBuilder(column: $table.frns, builder: (column) => column);

  GeneratedColumn<String> get verification => $composableBuilder(
      column: $table.verification, builder: (column) => column);

  GeneratedColumn<String> get comptes =>
      $composableBuilder(column: $table.comptes, builder: (column) => column);
}

class $$CaisseTableTableManager extends RootTableManager<
    _$AppDatabase,
    $CaisseTable,
    CaisseData,
    $$CaisseTableFilterComposer,
    $$CaisseTableOrderingComposer,
    $$CaisseTableAnnotationComposer,
    $$CaisseTableCreateCompanionBuilder,
    $$CaisseTableUpdateCompanionBuilder,
    (CaisseData, BaseReferences<_$AppDatabase, $CaisseTable, CaisseData>),
    CaisseData,
    PrefetchHooks Function()> {
  $$CaisseTableTableManager(_$AppDatabase db, $CaisseTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CaisseTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CaisseTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CaisseTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> ref = const Value.absent(),
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> lib = const Value.absent(),
            Value<double?> debit = const Value.absent(),
            Value<double?> credit = const Value.absent(),
            Value<double?> soldes = const Value.absent(),
            Value<String?> type = const Value.absent(),
            Value<String?> clt = const Value.absent(),
            Value<String?> frns = const Value.absent(),
            Value<String?> verification = const Value.absent(),
            Value<String?> comptes = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              CaisseCompanion(
            ref: ref,
            daty: daty,
            lib: lib,
            debit: debit,
            credit: credit,
            soldes: soldes,
            type: type,
            clt: clt,
            frns: frns,
            verification: verification,
            comptes: comptes,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String ref,
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> lib = const Value.absent(),
            Value<double?> debit = const Value.absent(),
            Value<double?> credit = const Value.absent(),
            Value<double?> soldes = const Value.absent(),
            Value<String?> type = const Value.absent(),
            Value<String?> clt = const Value.absent(),
            Value<String?> frns = const Value.absent(),
            Value<String?> verification = const Value.absent(),
            Value<String?> comptes = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              CaisseCompanion.insert(
            ref: ref,
            daty: daty,
            lib: lib,
            debit: debit,
            credit: credit,
            soldes: soldes,
            type: type,
            clt: clt,
            frns: frns,
            verification: verification,
            comptes: comptes,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$CaisseTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $CaisseTable,
    CaisseData,
    $$CaisseTableFilterComposer,
    $$CaisseTableOrderingComposer,
    $$CaisseTableAnnotationComposer,
    $$CaisseTableCreateCompanionBuilder,
    $$CaisseTableUpdateCompanionBuilder,
    (CaisseData, BaseReferences<_$AppDatabase, $CaisseTable, CaisseData>),
    CaisseData,
    PrefetchHooks Function()>;
typedef $$ChequierTableCreateCompanionBuilder = ChequierCompanion Function({
  Value<int?> a,
  Value<int?> nop,
  Value<String?> ncheq,
  Value<String?> tire,
  Value<String?> bqtire,
  Value<double?> montant,
  Value<DateTime?> datechq,
  Value<DateTime?> daterecep,
  Value<String?> action,
  Value<String?> nonaction,
  Value<String?> numventes,
  Value<String?> verification,
  Value<int> rowid,
});
typedef $$ChequierTableUpdateCompanionBuilder = ChequierCompanion Function({
  Value<int?> a,
  Value<int?> nop,
  Value<String?> ncheq,
  Value<String?> tire,
  Value<String?> bqtire,
  Value<double?> montant,
  Value<DateTime?> datechq,
  Value<DateTime?> daterecep,
  Value<String?> action,
  Value<String?> nonaction,
  Value<String?> numventes,
  Value<String?> verification,
  Value<int> rowid,
});

class $$ChequierTableFilterComposer
    extends Composer<_$AppDatabase, $ChequierTable> {
  $$ChequierTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get a => $composableBuilder(
      column: $table.a, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get nop => $composableBuilder(
      column: $table.nop, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get ncheq => $composableBuilder(
      column: $table.ncheq, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get tire => $composableBuilder(
      column: $table.tire, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get bqtire => $composableBuilder(
      column: $table.bqtire, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get montant => $composableBuilder(
      column: $table.montant, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get datechq => $composableBuilder(
      column: $table.datechq, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get daterecep => $composableBuilder(
      column: $table.daterecep, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get action => $composableBuilder(
      column: $table.action, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nonaction => $composableBuilder(
      column: $table.nonaction, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get numventes => $composableBuilder(
      column: $table.numventes, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get verification => $composableBuilder(
      column: $table.verification, builder: (column) => ColumnFilters(column));
}

class $$ChequierTableOrderingComposer
    extends Composer<_$AppDatabase, $ChequierTable> {
  $$ChequierTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get a => $composableBuilder(
      column: $table.a, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get nop => $composableBuilder(
      column: $table.nop, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get ncheq => $composableBuilder(
      column: $table.ncheq, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get tire => $composableBuilder(
      column: $table.tire, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get bqtire => $composableBuilder(
      column: $table.bqtire, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get montant => $composableBuilder(
      column: $table.montant, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get datechq => $composableBuilder(
      column: $table.datechq, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get daterecep => $composableBuilder(
      column: $table.daterecep, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get action => $composableBuilder(
      column: $table.action, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nonaction => $composableBuilder(
      column: $table.nonaction, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get numventes => $composableBuilder(
      column: $table.numventes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get verification => $composableBuilder(
      column: $table.verification,
      builder: (column) => ColumnOrderings(column));
}

class $$ChequierTableAnnotationComposer
    extends Composer<_$AppDatabase, $ChequierTable> {
  $$ChequierTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get a =>
      $composableBuilder(column: $table.a, builder: (column) => column);

  GeneratedColumn<int> get nop =>
      $composableBuilder(column: $table.nop, builder: (column) => column);

  GeneratedColumn<String> get ncheq =>
      $composableBuilder(column: $table.ncheq, builder: (column) => column);

  GeneratedColumn<String> get tire =>
      $composableBuilder(column: $table.tire, builder: (column) => column);

  GeneratedColumn<String> get bqtire =>
      $composableBuilder(column: $table.bqtire, builder: (column) => column);

  GeneratedColumn<double> get montant =>
      $composableBuilder(column: $table.montant, builder: (column) => column);

  GeneratedColumn<DateTime> get datechq =>
      $composableBuilder(column: $table.datechq, builder: (column) => column);

  GeneratedColumn<DateTime> get daterecep =>
      $composableBuilder(column: $table.daterecep, builder: (column) => column);

  GeneratedColumn<String> get action =>
      $composableBuilder(column: $table.action, builder: (column) => column);

  GeneratedColumn<String> get nonaction =>
      $composableBuilder(column: $table.nonaction, builder: (column) => column);

  GeneratedColumn<String> get numventes =>
      $composableBuilder(column: $table.numventes, builder: (column) => column);

  GeneratedColumn<String> get verification => $composableBuilder(
      column: $table.verification, builder: (column) => column);
}

class $$ChequierTableTableManager extends RootTableManager<
    _$AppDatabase,
    $ChequierTable,
    ChequierData,
    $$ChequierTableFilterComposer,
    $$ChequierTableOrderingComposer,
    $$ChequierTableAnnotationComposer,
    $$ChequierTableCreateCompanionBuilder,
    $$ChequierTableUpdateCompanionBuilder,
    (ChequierData, BaseReferences<_$AppDatabase, $ChequierTable, ChequierData>),
    ChequierData,
    PrefetchHooks Function()> {
  $$ChequierTableTableManager(_$AppDatabase db, $ChequierTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ChequierTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ChequierTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ChequierTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int?> a = const Value.absent(),
            Value<int?> nop = const Value.absent(),
            Value<String?> ncheq = const Value.absent(),
            Value<String?> tire = const Value.absent(),
            Value<String?> bqtire = const Value.absent(),
            Value<double?> montant = const Value.absent(),
            Value<DateTime?> datechq = const Value.absent(),
            Value<DateTime?> daterecep = const Value.absent(),
            Value<String?> action = const Value.absent(),
            Value<String?> nonaction = const Value.absent(),
            Value<String?> numventes = const Value.absent(),
            Value<String?> verification = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ChequierCompanion(
            a: a,
            nop: nop,
            ncheq: ncheq,
            tire: tire,
            bqtire: bqtire,
            montant: montant,
            datechq: datechq,
            daterecep: daterecep,
            action: action,
            nonaction: nonaction,
            numventes: numventes,
            verification: verification,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            Value<int?> a = const Value.absent(),
            Value<int?> nop = const Value.absent(),
            Value<String?> ncheq = const Value.absent(),
            Value<String?> tire = const Value.absent(),
            Value<String?> bqtire = const Value.absent(),
            Value<double?> montant = const Value.absent(),
            Value<DateTime?> datechq = const Value.absent(),
            Value<DateTime?> daterecep = const Value.absent(),
            Value<String?> action = const Value.absent(),
            Value<String?> nonaction = const Value.absent(),
            Value<String?> numventes = const Value.absent(),
            Value<String?> verification = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ChequierCompanion.insert(
            a: a,
            nop: nop,
            ncheq: ncheq,
            tire: tire,
            bqtire: bqtire,
            montant: montant,
            datechq: datechq,
            daterecep: daterecep,
            action: action,
            nonaction: nonaction,
            numventes: numventes,
            verification: verification,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$ChequierTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $ChequierTable,
    ChequierData,
    $$ChequierTableFilterComposer,
    $$ChequierTableOrderingComposer,
    $$ChequierTableAnnotationComposer,
    $$ChequierTableCreateCompanionBuilder,
    $$ChequierTableUpdateCompanionBuilder,
    (ChequierData, BaseReferences<_$AppDatabase, $ChequierTable, ChequierData>),
    ChequierData,
    PrefetchHooks Function()>;
typedef $$CltiTableCreateCompanionBuilder = CltiCompanion Function({
  required String rsoc,
  Value<double?> soldes,
  Value<double?> soldes1,
  Value<int?> zanaka,
  Value<int> rowid,
});
typedef $$CltiTableUpdateCompanionBuilder = CltiCompanion Function({
  Value<String> rsoc,
  Value<double?> soldes,
  Value<double?> soldes1,
  Value<int?> zanaka,
  Value<int> rowid,
});

class $$CltiTableFilterComposer extends Composer<_$AppDatabase, $CltiTable> {
  $$CltiTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get rsoc => $composableBuilder(
      column: $table.rsoc, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get soldes => $composableBuilder(
      column: $table.soldes, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get soldes1 => $composableBuilder(
      column: $table.soldes1, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get zanaka => $composableBuilder(
      column: $table.zanaka, builder: (column) => ColumnFilters(column));
}

class $$CltiTableOrderingComposer extends Composer<_$AppDatabase, $CltiTable> {
  $$CltiTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get rsoc => $composableBuilder(
      column: $table.rsoc, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get soldes => $composableBuilder(
      column: $table.soldes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get soldes1 => $composableBuilder(
      column: $table.soldes1, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get zanaka => $composableBuilder(
      column: $table.zanaka, builder: (column) => ColumnOrderings(column));
}

class $$CltiTableAnnotationComposer
    extends Composer<_$AppDatabase, $CltiTable> {
  $$CltiTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get rsoc =>
      $composableBuilder(column: $table.rsoc, builder: (column) => column);

  GeneratedColumn<double> get soldes =>
      $composableBuilder(column: $table.soldes, builder: (column) => column);

  GeneratedColumn<double> get soldes1 =>
      $composableBuilder(column: $table.soldes1, builder: (column) => column);

  GeneratedColumn<int> get zanaka =>
      $composableBuilder(column: $table.zanaka, builder: (column) => column);
}

class $$CltiTableTableManager extends RootTableManager<
    _$AppDatabase,
    $CltiTable,
    CltiData,
    $$CltiTableFilterComposer,
    $$CltiTableOrderingComposer,
    $$CltiTableAnnotationComposer,
    $$CltiTableCreateCompanionBuilder,
    $$CltiTableUpdateCompanionBuilder,
    (CltiData, BaseReferences<_$AppDatabase, $CltiTable, CltiData>),
    CltiData,
    PrefetchHooks Function()> {
  $$CltiTableTableManager(_$AppDatabase db, $CltiTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CltiTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CltiTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CltiTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> rsoc = const Value.absent(),
            Value<double?> soldes = const Value.absent(),
            Value<double?> soldes1 = const Value.absent(),
            Value<int?> zanaka = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              CltiCompanion(
            rsoc: rsoc,
            soldes: soldes,
            soldes1: soldes1,
            zanaka: zanaka,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String rsoc,
            Value<double?> soldes = const Value.absent(),
            Value<double?> soldes1 = const Value.absent(),
            Value<int?> zanaka = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              CltiCompanion.insert(
            rsoc: rsoc,
            soldes: soldes,
            soldes1: soldes1,
            zanaka: zanaka,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$CltiTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $CltiTable,
    CltiData,
    $$CltiTableFilterComposer,
    $$CltiTableOrderingComposer,
    $$CltiTableAnnotationComposer,
    $$CltiTableCreateCompanionBuilder,
    $$CltiTableUpdateCompanionBuilder,
    (CltiData, BaseReferences<_$AppDatabase, $CltiTable, CltiData>),
    CltiData,
    PrefetchHooks Function()>;
typedef $$ComptecltTableCreateCompanionBuilder = ComptecltCompanion Function({
  required String ref,
  Value<DateTime?> daty,
  Value<String?> lib,
  Value<String?> numventes,
  Value<String?> nfact,
  Value<String?> refart,
  Value<double?> qs,
  Value<double?> pus,
  Value<double?> entres,
  Value<double?> sorties,
  Value<double?> solde,
  Value<String?> clt,
  Value<String?> verification,
  Value<int> rowid,
});
typedef $$ComptecltTableUpdateCompanionBuilder = ComptecltCompanion Function({
  Value<String> ref,
  Value<DateTime?> daty,
  Value<String?> lib,
  Value<String?> numventes,
  Value<String?> nfact,
  Value<String?> refart,
  Value<double?> qs,
  Value<double?> pus,
  Value<double?> entres,
  Value<double?> sorties,
  Value<double?> solde,
  Value<String?> clt,
  Value<String?> verification,
  Value<int> rowid,
});

class $$ComptecltTableFilterComposer
    extends Composer<_$AppDatabase, $ComptecltTable> {
  $$ComptecltTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get ref => $composableBuilder(
      column: $table.ref, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get lib => $composableBuilder(
      column: $table.lib, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get numventes => $composableBuilder(
      column: $table.numventes, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nfact => $composableBuilder(
      column: $table.nfact, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get refart => $composableBuilder(
      column: $table.refart, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get qs => $composableBuilder(
      column: $table.qs, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get pus => $composableBuilder(
      column: $table.pus, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get entres => $composableBuilder(
      column: $table.entres, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get sorties => $composableBuilder(
      column: $table.sorties, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get solde => $composableBuilder(
      column: $table.solde, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get clt => $composableBuilder(
      column: $table.clt, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get verification => $composableBuilder(
      column: $table.verification, builder: (column) => ColumnFilters(column));
}

class $$ComptecltTableOrderingComposer
    extends Composer<_$AppDatabase, $ComptecltTable> {
  $$ComptecltTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get ref => $composableBuilder(
      column: $table.ref, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get lib => $composableBuilder(
      column: $table.lib, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get numventes => $composableBuilder(
      column: $table.numventes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nfact => $composableBuilder(
      column: $table.nfact, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get refart => $composableBuilder(
      column: $table.refart, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get qs => $composableBuilder(
      column: $table.qs, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get pus => $composableBuilder(
      column: $table.pus, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get entres => $composableBuilder(
      column: $table.entres, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get sorties => $composableBuilder(
      column: $table.sorties, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get solde => $composableBuilder(
      column: $table.solde, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get clt => $composableBuilder(
      column: $table.clt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get verification => $composableBuilder(
      column: $table.verification,
      builder: (column) => ColumnOrderings(column));
}

class $$ComptecltTableAnnotationComposer
    extends Composer<_$AppDatabase, $ComptecltTable> {
  $$ComptecltTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get ref =>
      $composableBuilder(column: $table.ref, builder: (column) => column);

  GeneratedColumn<DateTime> get daty =>
      $composableBuilder(column: $table.daty, builder: (column) => column);

  GeneratedColumn<String> get lib =>
      $composableBuilder(column: $table.lib, builder: (column) => column);

  GeneratedColumn<String> get numventes =>
      $composableBuilder(column: $table.numventes, builder: (column) => column);

  GeneratedColumn<String> get nfact =>
      $composableBuilder(column: $table.nfact, builder: (column) => column);

  GeneratedColumn<String> get refart =>
      $composableBuilder(column: $table.refart, builder: (column) => column);

  GeneratedColumn<double> get qs =>
      $composableBuilder(column: $table.qs, builder: (column) => column);

  GeneratedColumn<double> get pus =>
      $composableBuilder(column: $table.pus, builder: (column) => column);

  GeneratedColumn<double> get entres =>
      $composableBuilder(column: $table.entres, builder: (column) => column);

  GeneratedColumn<double> get sorties =>
      $composableBuilder(column: $table.sorties, builder: (column) => column);

  GeneratedColumn<double> get solde =>
      $composableBuilder(column: $table.solde, builder: (column) => column);

  GeneratedColumn<String> get clt =>
      $composableBuilder(column: $table.clt, builder: (column) => column);

  GeneratedColumn<String> get verification => $composableBuilder(
      column: $table.verification, builder: (column) => column);
}

class $$ComptecltTableTableManager extends RootTableManager<
    _$AppDatabase,
    $ComptecltTable,
    ComptecltData,
    $$ComptecltTableFilterComposer,
    $$ComptecltTableOrderingComposer,
    $$ComptecltTableAnnotationComposer,
    $$ComptecltTableCreateCompanionBuilder,
    $$ComptecltTableUpdateCompanionBuilder,
    (
      ComptecltData,
      BaseReferences<_$AppDatabase, $ComptecltTable, ComptecltData>
    ),
    ComptecltData,
    PrefetchHooks Function()> {
  $$ComptecltTableTableManager(_$AppDatabase db, $ComptecltTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ComptecltTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ComptecltTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ComptecltTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> ref = const Value.absent(),
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> lib = const Value.absent(),
            Value<String?> numventes = const Value.absent(),
            Value<String?> nfact = const Value.absent(),
            Value<String?> refart = const Value.absent(),
            Value<double?> qs = const Value.absent(),
            Value<double?> pus = const Value.absent(),
            Value<double?> entres = const Value.absent(),
            Value<double?> sorties = const Value.absent(),
            Value<double?> solde = const Value.absent(),
            Value<String?> clt = const Value.absent(),
            Value<String?> verification = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ComptecltCompanion(
            ref: ref,
            daty: daty,
            lib: lib,
            numventes: numventes,
            nfact: nfact,
            refart: refart,
            qs: qs,
            pus: pus,
            entres: entres,
            sorties: sorties,
            solde: solde,
            clt: clt,
            verification: verification,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String ref,
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> lib = const Value.absent(),
            Value<String?> numventes = const Value.absent(),
            Value<String?> nfact = const Value.absent(),
            Value<String?> refart = const Value.absent(),
            Value<double?> qs = const Value.absent(),
            Value<double?> pus = const Value.absent(),
            Value<double?> entres = const Value.absent(),
            Value<double?> sorties = const Value.absent(),
            Value<double?> solde = const Value.absent(),
            Value<String?> clt = const Value.absent(),
            Value<String?> verification = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ComptecltCompanion.insert(
            ref: ref,
            daty: daty,
            lib: lib,
            numventes: numventes,
            nfact: nfact,
            refart: refart,
            qs: qs,
            pus: pus,
            entres: entres,
            sorties: sorties,
            solde: solde,
            clt: clt,
            verification: verification,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$ComptecltTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $ComptecltTable,
    ComptecltData,
    $$ComptecltTableFilterComposer,
    $$ComptecltTableOrderingComposer,
    $$ComptecltTableAnnotationComposer,
    $$ComptecltTableCreateCompanionBuilder,
    $$ComptecltTableUpdateCompanionBuilder,
    (
      ComptecltData,
      BaseReferences<_$AppDatabase, $ComptecltTable, ComptecltData>
    ),
    ComptecltData,
    PrefetchHooks Function()>;
typedef $$ComptecomTableCreateCompanionBuilder = ComptecomCompanion Function({
  required String ref,
  Value<DateTime?> daty,
  Value<String?> lib,
  Value<String?> numventes,
  Value<String?> nfact,
  Value<double?> entres,
  Value<double?> sorties,
  Value<double?> solde,
  Value<String?> com,
  Value<String?> verification,
  Value<double?> montant,
  Value<int> rowid,
});
typedef $$ComptecomTableUpdateCompanionBuilder = ComptecomCompanion Function({
  Value<String> ref,
  Value<DateTime?> daty,
  Value<String?> lib,
  Value<String?> numventes,
  Value<String?> nfact,
  Value<double?> entres,
  Value<double?> sorties,
  Value<double?> solde,
  Value<String?> com,
  Value<String?> verification,
  Value<double?> montant,
  Value<int> rowid,
});

class $$ComptecomTableFilterComposer
    extends Composer<_$AppDatabase, $ComptecomTable> {
  $$ComptecomTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get ref => $composableBuilder(
      column: $table.ref, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get lib => $composableBuilder(
      column: $table.lib, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get numventes => $composableBuilder(
      column: $table.numventes, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nfact => $composableBuilder(
      column: $table.nfact, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get entres => $composableBuilder(
      column: $table.entres, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get sorties => $composableBuilder(
      column: $table.sorties, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get solde => $composableBuilder(
      column: $table.solde, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get com => $composableBuilder(
      column: $table.com, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get verification => $composableBuilder(
      column: $table.verification, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get montant => $composableBuilder(
      column: $table.montant, builder: (column) => ColumnFilters(column));
}

class $$ComptecomTableOrderingComposer
    extends Composer<_$AppDatabase, $ComptecomTable> {
  $$ComptecomTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get ref => $composableBuilder(
      column: $table.ref, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get lib => $composableBuilder(
      column: $table.lib, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get numventes => $composableBuilder(
      column: $table.numventes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nfact => $composableBuilder(
      column: $table.nfact, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get entres => $composableBuilder(
      column: $table.entres, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get sorties => $composableBuilder(
      column: $table.sorties, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get solde => $composableBuilder(
      column: $table.solde, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get com => $composableBuilder(
      column: $table.com, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get verification => $composableBuilder(
      column: $table.verification,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get montant => $composableBuilder(
      column: $table.montant, builder: (column) => ColumnOrderings(column));
}

class $$ComptecomTableAnnotationComposer
    extends Composer<_$AppDatabase, $ComptecomTable> {
  $$ComptecomTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get ref =>
      $composableBuilder(column: $table.ref, builder: (column) => column);

  GeneratedColumn<DateTime> get daty =>
      $composableBuilder(column: $table.daty, builder: (column) => column);

  GeneratedColumn<String> get lib =>
      $composableBuilder(column: $table.lib, builder: (column) => column);

  GeneratedColumn<String> get numventes =>
      $composableBuilder(column: $table.numventes, builder: (column) => column);

  GeneratedColumn<String> get nfact =>
      $composableBuilder(column: $table.nfact, builder: (column) => column);

  GeneratedColumn<double> get entres =>
      $composableBuilder(column: $table.entres, builder: (column) => column);

  GeneratedColumn<double> get sorties =>
      $composableBuilder(column: $table.sorties, builder: (column) => column);

  GeneratedColumn<double> get solde =>
      $composableBuilder(column: $table.solde, builder: (column) => column);

  GeneratedColumn<String> get com =>
      $composableBuilder(column: $table.com, builder: (column) => column);

  GeneratedColumn<String> get verification => $composableBuilder(
      column: $table.verification, builder: (column) => column);

  GeneratedColumn<double> get montant =>
      $composableBuilder(column: $table.montant, builder: (column) => column);
}

class $$ComptecomTableTableManager extends RootTableManager<
    _$AppDatabase,
    $ComptecomTable,
    ComptecomData,
    $$ComptecomTableFilterComposer,
    $$ComptecomTableOrderingComposer,
    $$ComptecomTableAnnotationComposer,
    $$ComptecomTableCreateCompanionBuilder,
    $$ComptecomTableUpdateCompanionBuilder,
    (
      ComptecomData,
      BaseReferences<_$AppDatabase, $ComptecomTable, ComptecomData>
    ),
    ComptecomData,
    PrefetchHooks Function()> {
  $$ComptecomTableTableManager(_$AppDatabase db, $ComptecomTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ComptecomTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ComptecomTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ComptecomTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> ref = const Value.absent(),
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> lib = const Value.absent(),
            Value<String?> numventes = const Value.absent(),
            Value<String?> nfact = const Value.absent(),
            Value<double?> entres = const Value.absent(),
            Value<double?> sorties = const Value.absent(),
            Value<double?> solde = const Value.absent(),
            Value<String?> com = const Value.absent(),
            Value<String?> verification = const Value.absent(),
            Value<double?> montant = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ComptecomCompanion(
            ref: ref,
            daty: daty,
            lib: lib,
            numventes: numventes,
            nfact: nfact,
            entres: entres,
            sorties: sorties,
            solde: solde,
            com: com,
            verification: verification,
            montant: montant,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String ref,
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> lib = const Value.absent(),
            Value<String?> numventes = const Value.absent(),
            Value<String?> nfact = const Value.absent(),
            Value<double?> entres = const Value.absent(),
            Value<double?> sorties = const Value.absent(),
            Value<double?> solde = const Value.absent(),
            Value<String?> com = const Value.absent(),
            Value<String?> verification = const Value.absent(),
            Value<double?> montant = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ComptecomCompanion.insert(
            ref: ref,
            daty: daty,
            lib: lib,
            numventes: numventes,
            nfact: nfact,
            entres: entres,
            sorties: sorties,
            solde: solde,
            com: com,
            verification: verification,
            montant: montant,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$ComptecomTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $ComptecomTable,
    ComptecomData,
    $$ComptecomTableFilterComposer,
    $$ComptecomTableOrderingComposer,
    $$ComptecomTableAnnotationComposer,
    $$ComptecomTableCreateCompanionBuilder,
    $$ComptecomTableUpdateCompanionBuilder,
    (
      ComptecomData,
      BaseReferences<_$AppDatabase, $ComptecomTable, ComptecomData>
    ),
    ComptecomData,
    PrefetchHooks Function()>;
typedef $$ComptefrnsTableCreateCompanionBuilder = ComptefrnsCompanion Function({
  required String ref,
  Value<DateTime?> daty,
  Value<String?> lib,
  Value<String?> numachats,
  Value<String?> nfact,
  Value<String?> refart,
  Value<double?> qe,
  Value<double?> pu,
  Value<double?> entres,
  Value<double?> sortie,
  Value<double?> solde,
  Value<String?> frns,
  Value<String?> verification,
  Value<int> rowid,
});
typedef $$ComptefrnsTableUpdateCompanionBuilder = ComptefrnsCompanion Function({
  Value<String> ref,
  Value<DateTime?> daty,
  Value<String?> lib,
  Value<String?> numachats,
  Value<String?> nfact,
  Value<String?> refart,
  Value<double?> qe,
  Value<double?> pu,
  Value<double?> entres,
  Value<double?> sortie,
  Value<double?> solde,
  Value<String?> frns,
  Value<String?> verification,
  Value<int> rowid,
});

class $$ComptefrnsTableFilterComposer
    extends Composer<_$AppDatabase, $ComptefrnsTable> {
  $$ComptefrnsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get ref => $composableBuilder(
      column: $table.ref, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get lib => $composableBuilder(
      column: $table.lib, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get numachats => $composableBuilder(
      column: $table.numachats, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nfact => $composableBuilder(
      column: $table.nfact, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get refart => $composableBuilder(
      column: $table.refart, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get qe => $composableBuilder(
      column: $table.qe, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get pu => $composableBuilder(
      column: $table.pu, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get entres => $composableBuilder(
      column: $table.entres, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get sortie => $composableBuilder(
      column: $table.sortie, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get solde => $composableBuilder(
      column: $table.solde, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get frns => $composableBuilder(
      column: $table.frns, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get verification => $composableBuilder(
      column: $table.verification, builder: (column) => ColumnFilters(column));
}

class $$ComptefrnsTableOrderingComposer
    extends Composer<_$AppDatabase, $ComptefrnsTable> {
  $$ComptefrnsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get ref => $composableBuilder(
      column: $table.ref, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get lib => $composableBuilder(
      column: $table.lib, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get numachats => $composableBuilder(
      column: $table.numachats, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nfact => $composableBuilder(
      column: $table.nfact, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get refart => $composableBuilder(
      column: $table.refart, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get qe => $composableBuilder(
      column: $table.qe, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get pu => $composableBuilder(
      column: $table.pu, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get entres => $composableBuilder(
      column: $table.entres, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get sortie => $composableBuilder(
      column: $table.sortie, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get solde => $composableBuilder(
      column: $table.solde, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get frns => $composableBuilder(
      column: $table.frns, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get verification => $composableBuilder(
      column: $table.verification,
      builder: (column) => ColumnOrderings(column));
}

class $$ComptefrnsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ComptefrnsTable> {
  $$ComptefrnsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get ref =>
      $composableBuilder(column: $table.ref, builder: (column) => column);

  GeneratedColumn<DateTime> get daty =>
      $composableBuilder(column: $table.daty, builder: (column) => column);

  GeneratedColumn<String> get lib =>
      $composableBuilder(column: $table.lib, builder: (column) => column);

  GeneratedColumn<String> get numachats =>
      $composableBuilder(column: $table.numachats, builder: (column) => column);

  GeneratedColumn<String> get nfact =>
      $composableBuilder(column: $table.nfact, builder: (column) => column);

  GeneratedColumn<String> get refart =>
      $composableBuilder(column: $table.refart, builder: (column) => column);

  GeneratedColumn<double> get qe =>
      $composableBuilder(column: $table.qe, builder: (column) => column);

  GeneratedColumn<double> get pu =>
      $composableBuilder(column: $table.pu, builder: (column) => column);

  GeneratedColumn<double> get entres =>
      $composableBuilder(column: $table.entres, builder: (column) => column);

  GeneratedColumn<double> get sortie =>
      $composableBuilder(column: $table.sortie, builder: (column) => column);

  GeneratedColumn<double> get solde =>
      $composableBuilder(column: $table.solde, builder: (column) => column);

  GeneratedColumn<String> get frns =>
      $composableBuilder(column: $table.frns, builder: (column) => column);

  GeneratedColumn<String> get verification => $composableBuilder(
      column: $table.verification, builder: (column) => column);
}

class $$ComptefrnsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $ComptefrnsTable,
    Comptefrn,
    $$ComptefrnsTableFilterComposer,
    $$ComptefrnsTableOrderingComposer,
    $$ComptefrnsTableAnnotationComposer,
    $$ComptefrnsTableCreateCompanionBuilder,
    $$ComptefrnsTableUpdateCompanionBuilder,
    (Comptefrn, BaseReferences<_$AppDatabase, $ComptefrnsTable, Comptefrn>),
    Comptefrn,
    PrefetchHooks Function()> {
  $$ComptefrnsTableTableManager(_$AppDatabase db, $ComptefrnsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ComptefrnsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ComptefrnsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ComptefrnsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> ref = const Value.absent(),
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> lib = const Value.absent(),
            Value<String?> numachats = const Value.absent(),
            Value<String?> nfact = const Value.absent(),
            Value<String?> refart = const Value.absent(),
            Value<double?> qe = const Value.absent(),
            Value<double?> pu = const Value.absent(),
            Value<double?> entres = const Value.absent(),
            Value<double?> sortie = const Value.absent(),
            Value<double?> solde = const Value.absent(),
            Value<String?> frns = const Value.absent(),
            Value<String?> verification = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ComptefrnsCompanion(
            ref: ref,
            daty: daty,
            lib: lib,
            numachats: numachats,
            nfact: nfact,
            refart: refart,
            qe: qe,
            pu: pu,
            entres: entres,
            sortie: sortie,
            solde: solde,
            frns: frns,
            verification: verification,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String ref,
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> lib = const Value.absent(),
            Value<String?> numachats = const Value.absent(),
            Value<String?> nfact = const Value.absent(),
            Value<String?> refart = const Value.absent(),
            Value<double?> qe = const Value.absent(),
            Value<double?> pu = const Value.absent(),
            Value<double?> entres = const Value.absent(),
            Value<double?> sortie = const Value.absent(),
            Value<double?> solde = const Value.absent(),
            Value<String?> frns = const Value.absent(),
            Value<String?> verification = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ComptefrnsCompanion.insert(
            ref: ref,
            daty: daty,
            lib: lib,
            numachats: numachats,
            nfact: nfact,
            refart: refart,
            qe: qe,
            pu: pu,
            entres: entres,
            sortie: sortie,
            solde: solde,
            frns: frns,
            verification: verification,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$ComptefrnsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $ComptefrnsTable,
    Comptefrn,
    $$ComptefrnsTableFilterComposer,
    $$ComptefrnsTableOrderingComposer,
    $$ComptefrnsTableAnnotationComposer,
    $$ComptefrnsTableCreateCompanionBuilder,
    $$ComptefrnsTableUpdateCompanionBuilder,
    (Comptefrn, BaseReferences<_$AppDatabase, $ComptefrnsTable, Comptefrn>),
    Comptefrn,
    PrefetchHooks Function()>;
typedef $$DepartTableCreateCompanionBuilder = DepartCompanion Function({
  required String designation,
  Value<String?> depots,
  Value<double?> stocksu1,
  Value<double?> stocksu2,
  Value<double?> stocksu3,
  Value<int> rowid,
});
typedef $$DepartTableUpdateCompanionBuilder = DepartCompanion Function({
  Value<String> designation,
  Value<String?> depots,
  Value<double?> stocksu1,
  Value<double?> stocksu2,
  Value<double?> stocksu3,
  Value<int> rowid,
});

class $$DepartTableFilterComposer
    extends Composer<_$AppDatabase, $DepartTable> {
  $$DepartTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get designation => $composableBuilder(
      column: $table.designation, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get depots => $composableBuilder(
      column: $table.depots, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get stocksu1 => $composableBuilder(
      column: $table.stocksu1, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get stocksu2 => $composableBuilder(
      column: $table.stocksu2, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get stocksu3 => $composableBuilder(
      column: $table.stocksu3, builder: (column) => ColumnFilters(column));
}

class $$DepartTableOrderingComposer
    extends Composer<_$AppDatabase, $DepartTable> {
  $$DepartTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get designation => $composableBuilder(
      column: $table.designation, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get depots => $composableBuilder(
      column: $table.depots, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get stocksu1 => $composableBuilder(
      column: $table.stocksu1, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get stocksu2 => $composableBuilder(
      column: $table.stocksu2, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get stocksu3 => $composableBuilder(
      column: $table.stocksu3, builder: (column) => ColumnOrderings(column));
}

class $$DepartTableAnnotationComposer
    extends Composer<_$AppDatabase, $DepartTable> {
  $$DepartTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get designation => $composableBuilder(
      column: $table.designation, builder: (column) => column);

  GeneratedColumn<String> get depots =>
      $composableBuilder(column: $table.depots, builder: (column) => column);

  GeneratedColumn<double> get stocksu1 =>
      $composableBuilder(column: $table.stocksu1, builder: (column) => column);

  GeneratedColumn<double> get stocksu2 =>
      $composableBuilder(column: $table.stocksu2, builder: (column) => column);

  GeneratedColumn<double> get stocksu3 =>
      $composableBuilder(column: $table.stocksu3, builder: (column) => column);
}

class $$DepartTableTableManager extends RootTableManager<
    _$AppDatabase,
    $DepartTable,
    DepartData,
    $$DepartTableFilterComposer,
    $$DepartTableOrderingComposer,
    $$DepartTableAnnotationComposer,
    $$DepartTableCreateCompanionBuilder,
    $$DepartTableUpdateCompanionBuilder,
    (DepartData, BaseReferences<_$AppDatabase, $DepartTable, DepartData>),
    DepartData,
    PrefetchHooks Function()> {
  $$DepartTableTableManager(_$AppDatabase db, $DepartTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$DepartTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$DepartTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$DepartTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> designation = const Value.absent(),
            Value<String?> depots = const Value.absent(),
            Value<double?> stocksu1 = const Value.absent(),
            Value<double?> stocksu2 = const Value.absent(),
            Value<double?> stocksu3 = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              DepartCompanion(
            designation: designation,
            depots: depots,
            stocksu1: stocksu1,
            stocksu2: stocksu2,
            stocksu3: stocksu3,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String designation,
            Value<String?> depots = const Value.absent(),
            Value<double?> stocksu1 = const Value.absent(),
            Value<double?> stocksu2 = const Value.absent(),
            Value<double?> stocksu3 = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              DepartCompanion.insert(
            designation: designation,
            depots: depots,
            stocksu1: stocksu1,
            stocksu2: stocksu2,
            stocksu3: stocksu3,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$DepartTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $DepartTable,
    DepartData,
    $$DepartTableFilterComposer,
    $$DepartTableOrderingComposer,
    $$DepartTableAnnotationComposer,
    $$DepartTableCreateCompanionBuilder,
    $$DepartTableUpdateCompanionBuilder,
    (DepartData, BaseReferences<_$AppDatabase, $DepartTable, DepartData>),
    DepartData,
    PrefetchHooks Function()>;
typedef $$DetachatsTableCreateCompanionBuilder = DetachatsCompanion Function({
  Value<int> num,
  Value<String?> numachats,
  Value<String?> designation,
  Value<String?> unites,
  Value<String?> depots,
  Value<double?> q,
  Value<double?> pu,
  Value<DateTime?> daty,
  Value<String?> emb,
  Value<String?> transp,
  Value<double?> qe,
});
typedef $$DetachatsTableUpdateCompanionBuilder = DetachatsCompanion Function({
  Value<int> num,
  Value<String?> numachats,
  Value<String?> designation,
  Value<String?> unites,
  Value<String?> depots,
  Value<double?> q,
  Value<double?> pu,
  Value<DateTime?> daty,
  Value<String?> emb,
  Value<String?> transp,
  Value<double?> qe,
});

class $$DetachatsTableFilterComposer
    extends Composer<_$AppDatabase, $DetachatsTable> {
  $$DetachatsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get num => $composableBuilder(
      column: $table.num, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get numachats => $composableBuilder(
      column: $table.numachats, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get designation => $composableBuilder(
      column: $table.designation, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get unites => $composableBuilder(
      column: $table.unites, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get depots => $composableBuilder(
      column: $table.depots, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get q => $composableBuilder(
      column: $table.q, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get pu => $composableBuilder(
      column: $table.pu, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get emb => $composableBuilder(
      column: $table.emb, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get transp => $composableBuilder(
      column: $table.transp, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get qe => $composableBuilder(
      column: $table.qe, builder: (column) => ColumnFilters(column));
}

class $$DetachatsTableOrderingComposer
    extends Composer<_$AppDatabase, $DetachatsTable> {
  $$DetachatsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get num => $composableBuilder(
      column: $table.num, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get numachats => $composableBuilder(
      column: $table.numachats, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get designation => $composableBuilder(
      column: $table.designation, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get unites => $composableBuilder(
      column: $table.unites, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get depots => $composableBuilder(
      column: $table.depots, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get q => $composableBuilder(
      column: $table.q, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get pu => $composableBuilder(
      column: $table.pu, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get emb => $composableBuilder(
      column: $table.emb, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get transp => $composableBuilder(
      column: $table.transp, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get qe => $composableBuilder(
      column: $table.qe, builder: (column) => ColumnOrderings(column));
}

class $$DetachatsTableAnnotationComposer
    extends Composer<_$AppDatabase, $DetachatsTable> {
  $$DetachatsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get num =>
      $composableBuilder(column: $table.num, builder: (column) => column);

  GeneratedColumn<String> get numachats =>
      $composableBuilder(column: $table.numachats, builder: (column) => column);

  GeneratedColumn<String> get designation => $composableBuilder(
      column: $table.designation, builder: (column) => column);

  GeneratedColumn<String> get unites =>
      $composableBuilder(column: $table.unites, builder: (column) => column);

  GeneratedColumn<String> get depots =>
      $composableBuilder(column: $table.depots, builder: (column) => column);

  GeneratedColumn<double> get q =>
      $composableBuilder(column: $table.q, builder: (column) => column);

  GeneratedColumn<double> get pu =>
      $composableBuilder(column: $table.pu, builder: (column) => column);

  GeneratedColumn<DateTime> get daty =>
      $composableBuilder(column: $table.daty, builder: (column) => column);

  GeneratedColumn<String> get emb =>
      $composableBuilder(column: $table.emb, builder: (column) => column);

  GeneratedColumn<String> get transp =>
      $composableBuilder(column: $table.transp, builder: (column) => column);

  GeneratedColumn<double> get qe =>
      $composableBuilder(column: $table.qe, builder: (column) => column);
}

class $$DetachatsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $DetachatsTable,
    Detachat,
    $$DetachatsTableFilterComposer,
    $$DetachatsTableOrderingComposer,
    $$DetachatsTableAnnotationComposer,
    $$DetachatsTableCreateCompanionBuilder,
    $$DetachatsTableUpdateCompanionBuilder,
    (Detachat, BaseReferences<_$AppDatabase, $DetachatsTable, Detachat>),
    Detachat,
    PrefetchHooks Function()> {
  $$DetachatsTableTableManager(_$AppDatabase db, $DetachatsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$DetachatsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$DetachatsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$DetachatsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> num = const Value.absent(),
            Value<String?> numachats = const Value.absent(),
            Value<String?> designation = const Value.absent(),
            Value<String?> unites = const Value.absent(),
            Value<String?> depots = const Value.absent(),
            Value<double?> q = const Value.absent(),
            Value<double?> pu = const Value.absent(),
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> emb = const Value.absent(),
            Value<String?> transp = const Value.absent(),
            Value<double?> qe = const Value.absent(),
          }) =>
              DetachatsCompanion(
            num: num,
            numachats: numachats,
            designation: designation,
            unites: unites,
            depots: depots,
            q: q,
            pu: pu,
            daty: daty,
            emb: emb,
            transp: transp,
            qe: qe,
          ),
          createCompanionCallback: ({
            Value<int> num = const Value.absent(),
            Value<String?> numachats = const Value.absent(),
            Value<String?> designation = const Value.absent(),
            Value<String?> unites = const Value.absent(),
            Value<String?> depots = const Value.absent(),
            Value<double?> q = const Value.absent(),
            Value<double?> pu = const Value.absent(),
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> emb = const Value.absent(),
            Value<String?> transp = const Value.absent(),
            Value<double?> qe = const Value.absent(),
          }) =>
              DetachatsCompanion.insert(
            num: num,
            numachats: numachats,
            designation: designation,
            unites: unites,
            depots: depots,
            q: q,
            pu: pu,
            daty: daty,
            emb: emb,
            transp: transp,
            qe: qe,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$DetachatsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $DetachatsTable,
    Detachat,
    $$DetachatsTableFilterComposer,
    $$DetachatsTableOrderingComposer,
    $$DetachatsTableAnnotationComposer,
    $$DetachatsTableCreateCompanionBuilder,
    $$DetachatsTableUpdateCompanionBuilder,
    (Detachat, BaseReferences<_$AppDatabase, $DetachatsTable, Detachat>),
    Detachat,
    PrefetchHooks Function()>;
typedef $$DetprodTableCreateCompanionBuilder = DetprodCompanion Function({
  Value<int> num,
  Value<String?> numaprod,
  Value<String?> designation,
  Value<String?> unites,
  Value<String?> depots,
  Value<double?> q,
  Value<double?> pu,
  Value<DateTime?> daty,
});
typedef $$DetprodTableUpdateCompanionBuilder = DetprodCompanion Function({
  Value<int> num,
  Value<String?> numaprod,
  Value<String?> designation,
  Value<String?> unites,
  Value<String?> depots,
  Value<double?> q,
  Value<double?> pu,
  Value<DateTime?> daty,
});

class $$DetprodTableFilterComposer
    extends Composer<_$AppDatabase, $DetprodTable> {
  $$DetprodTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get num => $composableBuilder(
      column: $table.num, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get numaprod => $composableBuilder(
      column: $table.numaprod, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get designation => $composableBuilder(
      column: $table.designation, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get unites => $composableBuilder(
      column: $table.unites, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get depots => $composableBuilder(
      column: $table.depots, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get q => $composableBuilder(
      column: $table.q, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get pu => $composableBuilder(
      column: $table.pu, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnFilters(column));
}

class $$DetprodTableOrderingComposer
    extends Composer<_$AppDatabase, $DetprodTable> {
  $$DetprodTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get num => $composableBuilder(
      column: $table.num, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get numaprod => $composableBuilder(
      column: $table.numaprod, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get designation => $composableBuilder(
      column: $table.designation, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get unites => $composableBuilder(
      column: $table.unites, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get depots => $composableBuilder(
      column: $table.depots, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get q => $composableBuilder(
      column: $table.q, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get pu => $composableBuilder(
      column: $table.pu, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnOrderings(column));
}

class $$DetprodTableAnnotationComposer
    extends Composer<_$AppDatabase, $DetprodTable> {
  $$DetprodTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get num =>
      $composableBuilder(column: $table.num, builder: (column) => column);

  GeneratedColumn<String> get numaprod =>
      $composableBuilder(column: $table.numaprod, builder: (column) => column);

  GeneratedColumn<String> get designation => $composableBuilder(
      column: $table.designation, builder: (column) => column);

  GeneratedColumn<String> get unites =>
      $composableBuilder(column: $table.unites, builder: (column) => column);

  GeneratedColumn<String> get depots =>
      $composableBuilder(column: $table.depots, builder: (column) => column);

  GeneratedColumn<double> get q =>
      $composableBuilder(column: $table.q, builder: (column) => column);

  GeneratedColumn<double> get pu =>
      $composableBuilder(column: $table.pu, builder: (column) => column);

  GeneratedColumn<DateTime> get daty =>
      $composableBuilder(column: $table.daty, builder: (column) => column);
}

class $$DetprodTableTableManager extends RootTableManager<
    _$AppDatabase,
    $DetprodTable,
    DetprodData,
    $$DetprodTableFilterComposer,
    $$DetprodTableOrderingComposer,
    $$DetprodTableAnnotationComposer,
    $$DetprodTableCreateCompanionBuilder,
    $$DetprodTableUpdateCompanionBuilder,
    (DetprodData, BaseReferences<_$AppDatabase, $DetprodTable, DetprodData>),
    DetprodData,
    PrefetchHooks Function()> {
  $$DetprodTableTableManager(_$AppDatabase db, $DetprodTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$DetprodTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$DetprodTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$DetprodTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> num = const Value.absent(),
            Value<String?> numaprod = const Value.absent(),
            Value<String?> designation = const Value.absent(),
            Value<String?> unites = const Value.absent(),
            Value<String?> depots = const Value.absent(),
            Value<double?> q = const Value.absent(),
            Value<double?> pu = const Value.absent(),
            Value<DateTime?> daty = const Value.absent(),
          }) =>
              DetprodCompanion(
            num: num,
            numaprod: numaprod,
            designation: designation,
            unites: unites,
            depots: depots,
            q: q,
            pu: pu,
            daty: daty,
          ),
          createCompanionCallback: ({
            Value<int> num = const Value.absent(),
            Value<String?> numaprod = const Value.absent(),
            Value<String?> designation = const Value.absent(),
            Value<String?> unites = const Value.absent(),
            Value<String?> depots = const Value.absent(),
            Value<double?> q = const Value.absent(),
            Value<double?> pu = const Value.absent(),
            Value<DateTime?> daty = const Value.absent(),
          }) =>
              DetprodCompanion.insert(
            num: num,
            numaprod: numaprod,
            designation: designation,
            unites: unites,
            depots: depots,
            q: q,
            pu: pu,
            daty: daty,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$DetprodTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $DetprodTable,
    DetprodData,
    $$DetprodTableFilterComposer,
    $$DetprodTableOrderingComposer,
    $$DetprodTableAnnotationComposer,
    $$DetprodTableCreateCompanionBuilder,
    $$DetprodTableUpdateCompanionBuilder,
    (DetprodData, BaseReferences<_$AppDatabase, $DetprodTable, DetprodData>),
    DetprodData,
    PrefetchHooks Function()>;
typedef $$DettransfTableCreateCompanionBuilder = DettransfCompanion Function({
  Value<int> num,
  Value<String?> numtransf,
  Value<String?> designation,
  Value<String?> unites,
  Value<double?> q,
});
typedef $$DettransfTableUpdateCompanionBuilder = DettransfCompanion Function({
  Value<int> num,
  Value<String?> numtransf,
  Value<String?> designation,
  Value<String?> unites,
  Value<double?> q,
});

class $$DettransfTableFilterComposer
    extends Composer<_$AppDatabase, $DettransfTable> {
  $$DettransfTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get num => $composableBuilder(
      column: $table.num, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get numtransf => $composableBuilder(
      column: $table.numtransf, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get designation => $composableBuilder(
      column: $table.designation, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get unites => $composableBuilder(
      column: $table.unites, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get q => $composableBuilder(
      column: $table.q, builder: (column) => ColumnFilters(column));
}

class $$DettransfTableOrderingComposer
    extends Composer<_$AppDatabase, $DettransfTable> {
  $$DettransfTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get num => $composableBuilder(
      column: $table.num, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get numtransf => $composableBuilder(
      column: $table.numtransf, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get designation => $composableBuilder(
      column: $table.designation, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get unites => $composableBuilder(
      column: $table.unites, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get q => $composableBuilder(
      column: $table.q, builder: (column) => ColumnOrderings(column));
}

class $$DettransfTableAnnotationComposer
    extends Composer<_$AppDatabase, $DettransfTable> {
  $$DettransfTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get num =>
      $composableBuilder(column: $table.num, builder: (column) => column);

  GeneratedColumn<String> get numtransf =>
      $composableBuilder(column: $table.numtransf, builder: (column) => column);

  GeneratedColumn<String> get designation => $composableBuilder(
      column: $table.designation, builder: (column) => column);

  GeneratedColumn<String> get unites =>
      $composableBuilder(column: $table.unites, builder: (column) => column);

  GeneratedColumn<double> get q =>
      $composableBuilder(column: $table.q, builder: (column) => column);
}

class $$DettransfTableTableManager extends RootTableManager<
    _$AppDatabase,
    $DettransfTable,
    DettransfData,
    $$DettransfTableFilterComposer,
    $$DettransfTableOrderingComposer,
    $$DettransfTableAnnotationComposer,
    $$DettransfTableCreateCompanionBuilder,
    $$DettransfTableUpdateCompanionBuilder,
    (
      DettransfData,
      BaseReferences<_$AppDatabase, $DettransfTable, DettransfData>
    ),
    DettransfData,
    PrefetchHooks Function()> {
  $$DettransfTableTableManager(_$AppDatabase db, $DettransfTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$DettransfTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$DettransfTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$DettransfTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> num = const Value.absent(),
            Value<String?> numtransf = const Value.absent(),
            Value<String?> designation = const Value.absent(),
            Value<String?> unites = const Value.absent(),
            Value<double?> q = const Value.absent(),
          }) =>
              DettransfCompanion(
            num: num,
            numtransf: numtransf,
            designation: designation,
            unites: unites,
            q: q,
          ),
          createCompanionCallback: ({
            Value<int> num = const Value.absent(),
            Value<String?> numtransf = const Value.absent(),
            Value<String?> designation = const Value.absent(),
            Value<String?> unites = const Value.absent(),
            Value<double?> q = const Value.absent(),
          }) =>
              DettransfCompanion.insert(
            num: num,
            numtransf: numtransf,
            designation: designation,
            unites: unites,
            q: q,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$DettransfTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $DettransfTable,
    DettransfData,
    $$DettransfTableFilterComposer,
    $$DettransfTableOrderingComposer,
    $$DettransfTableAnnotationComposer,
    $$DettransfTableCreateCompanionBuilder,
    $$DettransfTableUpdateCompanionBuilder,
    (
      DettransfData,
      BaseReferences<_$AppDatabase, $DettransfTable, DettransfData>
    ),
    DettransfData,
    PrefetchHooks Function()>;
typedef $$DetventesTableCreateCompanionBuilder = DetventesCompanion Function({
  Value<int> num,
  Value<String?> numventes,
  Value<String?> designation,
  Value<String?> unites,
  Value<String?> depots,
  Value<double?> q,
  Value<double?> pu,
  Value<DateTime?> daty,
  Value<String?> emb,
  Value<String?> transp,
  Value<double?> qe,
});
typedef $$DetventesTableUpdateCompanionBuilder = DetventesCompanion Function({
  Value<int> num,
  Value<String?> numventes,
  Value<String?> designation,
  Value<String?> unites,
  Value<String?> depots,
  Value<double?> q,
  Value<double?> pu,
  Value<DateTime?> daty,
  Value<String?> emb,
  Value<String?> transp,
  Value<double?> qe,
});

class $$DetventesTableFilterComposer
    extends Composer<_$AppDatabase, $DetventesTable> {
  $$DetventesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get num => $composableBuilder(
      column: $table.num, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get numventes => $composableBuilder(
      column: $table.numventes, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get designation => $composableBuilder(
      column: $table.designation, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get unites => $composableBuilder(
      column: $table.unites, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get depots => $composableBuilder(
      column: $table.depots, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get q => $composableBuilder(
      column: $table.q, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get pu => $composableBuilder(
      column: $table.pu, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get emb => $composableBuilder(
      column: $table.emb, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get transp => $composableBuilder(
      column: $table.transp, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get qe => $composableBuilder(
      column: $table.qe, builder: (column) => ColumnFilters(column));
}

class $$DetventesTableOrderingComposer
    extends Composer<_$AppDatabase, $DetventesTable> {
  $$DetventesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get num => $composableBuilder(
      column: $table.num, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get numventes => $composableBuilder(
      column: $table.numventes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get designation => $composableBuilder(
      column: $table.designation, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get unites => $composableBuilder(
      column: $table.unites, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get depots => $composableBuilder(
      column: $table.depots, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get q => $composableBuilder(
      column: $table.q, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get pu => $composableBuilder(
      column: $table.pu, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get emb => $composableBuilder(
      column: $table.emb, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get transp => $composableBuilder(
      column: $table.transp, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get qe => $composableBuilder(
      column: $table.qe, builder: (column) => ColumnOrderings(column));
}

class $$DetventesTableAnnotationComposer
    extends Composer<_$AppDatabase, $DetventesTable> {
  $$DetventesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get num =>
      $composableBuilder(column: $table.num, builder: (column) => column);

  GeneratedColumn<String> get numventes =>
      $composableBuilder(column: $table.numventes, builder: (column) => column);

  GeneratedColumn<String> get designation => $composableBuilder(
      column: $table.designation, builder: (column) => column);

  GeneratedColumn<String> get unites =>
      $composableBuilder(column: $table.unites, builder: (column) => column);

  GeneratedColumn<String> get depots =>
      $composableBuilder(column: $table.depots, builder: (column) => column);

  GeneratedColumn<double> get q =>
      $composableBuilder(column: $table.q, builder: (column) => column);

  GeneratedColumn<double> get pu =>
      $composableBuilder(column: $table.pu, builder: (column) => column);

  GeneratedColumn<DateTime> get daty =>
      $composableBuilder(column: $table.daty, builder: (column) => column);

  GeneratedColumn<String> get emb =>
      $composableBuilder(column: $table.emb, builder: (column) => column);

  GeneratedColumn<String> get transp =>
      $composableBuilder(column: $table.transp, builder: (column) => column);

  GeneratedColumn<double> get qe =>
      $composableBuilder(column: $table.qe, builder: (column) => column);
}

class $$DetventesTableTableManager extends RootTableManager<
    _$AppDatabase,
    $DetventesTable,
    Detvente,
    $$DetventesTableFilterComposer,
    $$DetventesTableOrderingComposer,
    $$DetventesTableAnnotationComposer,
    $$DetventesTableCreateCompanionBuilder,
    $$DetventesTableUpdateCompanionBuilder,
    (Detvente, BaseReferences<_$AppDatabase, $DetventesTable, Detvente>),
    Detvente,
    PrefetchHooks Function()> {
  $$DetventesTableTableManager(_$AppDatabase db, $DetventesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$DetventesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$DetventesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$DetventesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> num = const Value.absent(),
            Value<String?> numventes = const Value.absent(),
            Value<String?> designation = const Value.absent(),
            Value<String?> unites = const Value.absent(),
            Value<String?> depots = const Value.absent(),
            Value<double?> q = const Value.absent(),
            Value<double?> pu = const Value.absent(),
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> emb = const Value.absent(),
            Value<String?> transp = const Value.absent(),
            Value<double?> qe = const Value.absent(),
          }) =>
              DetventesCompanion(
            num: num,
            numventes: numventes,
            designation: designation,
            unites: unites,
            depots: depots,
            q: q,
            pu: pu,
            daty: daty,
            emb: emb,
            transp: transp,
            qe: qe,
          ),
          createCompanionCallback: ({
            Value<int> num = const Value.absent(),
            Value<String?> numventes = const Value.absent(),
            Value<String?> designation = const Value.absent(),
            Value<String?> unites = const Value.absent(),
            Value<String?> depots = const Value.absent(),
            Value<double?> q = const Value.absent(),
            Value<double?> pu = const Value.absent(),
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> emb = const Value.absent(),
            Value<String?> transp = const Value.absent(),
            Value<double?> qe = const Value.absent(),
          }) =>
              DetventesCompanion.insert(
            num: num,
            numventes: numventes,
            designation: designation,
            unites: unites,
            depots: depots,
            q: q,
            pu: pu,
            daty: daty,
            emb: emb,
            transp: transp,
            qe: qe,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$DetventesTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $DetventesTable,
    Detvente,
    $$DetventesTableFilterComposer,
    $$DetventesTableOrderingComposer,
    $$DetventesTableAnnotationComposer,
    $$DetventesTableCreateCompanionBuilder,
    $$DetventesTableUpdateCompanionBuilder,
    (Detvente, BaseReferences<_$AppDatabase, $DetventesTable, Detvente>),
    Detvente,
    PrefetchHooks Function()>;
typedef $$EffetsTableCreateCompanionBuilder = EffetsCompanion Function({
  Value<int?> a,
  Value<int?> nop,
  Value<String?> ncheq,
  Value<String?> tire,
  Value<String?> bqtire,
  Value<double?> montant,
  Value<DateTime?> datechq,
  Value<DateTime?> daterecep,
  Value<String?> action,
  Value<String?> nonaction,
  Value<String?> numventes,
  Value<String?> verification,
  Value<int> rowid,
});
typedef $$EffetsTableUpdateCompanionBuilder = EffetsCompanion Function({
  Value<int?> a,
  Value<int?> nop,
  Value<String?> ncheq,
  Value<String?> tire,
  Value<String?> bqtire,
  Value<double?> montant,
  Value<DateTime?> datechq,
  Value<DateTime?> daterecep,
  Value<String?> action,
  Value<String?> nonaction,
  Value<String?> numventes,
  Value<String?> verification,
  Value<int> rowid,
});

class $$EffetsTableFilterComposer
    extends Composer<_$AppDatabase, $EffetsTable> {
  $$EffetsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get a => $composableBuilder(
      column: $table.a, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get nop => $composableBuilder(
      column: $table.nop, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get ncheq => $composableBuilder(
      column: $table.ncheq, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get tire => $composableBuilder(
      column: $table.tire, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get bqtire => $composableBuilder(
      column: $table.bqtire, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get montant => $composableBuilder(
      column: $table.montant, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get datechq => $composableBuilder(
      column: $table.datechq, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get daterecep => $composableBuilder(
      column: $table.daterecep, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get action => $composableBuilder(
      column: $table.action, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nonaction => $composableBuilder(
      column: $table.nonaction, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get numventes => $composableBuilder(
      column: $table.numventes, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get verification => $composableBuilder(
      column: $table.verification, builder: (column) => ColumnFilters(column));
}

class $$EffetsTableOrderingComposer
    extends Composer<_$AppDatabase, $EffetsTable> {
  $$EffetsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get a => $composableBuilder(
      column: $table.a, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get nop => $composableBuilder(
      column: $table.nop, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get ncheq => $composableBuilder(
      column: $table.ncheq, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get tire => $composableBuilder(
      column: $table.tire, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get bqtire => $composableBuilder(
      column: $table.bqtire, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get montant => $composableBuilder(
      column: $table.montant, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get datechq => $composableBuilder(
      column: $table.datechq, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get daterecep => $composableBuilder(
      column: $table.daterecep, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get action => $composableBuilder(
      column: $table.action, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nonaction => $composableBuilder(
      column: $table.nonaction, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get numventes => $composableBuilder(
      column: $table.numventes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get verification => $composableBuilder(
      column: $table.verification,
      builder: (column) => ColumnOrderings(column));
}

class $$EffetsTableAnnotationComposer
    extends Composer<_$AppDatabase, $EffetsTable> {
  $$EffetsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get a =>
      $composableBuilder(column: $table.a, builder: (column) => column);

  GeneratedColumn<int> get nop =>
      $composableBuilder(column: $table.nop, builder: (column) => column);

  GeneratedColumn<String> get ncheq =>
      $composableBuilder(column: $table.ncheq, builder: (column) => column);

  GeneratedColumn<String> get tire =>
      $composableBuilder(column: $table.tire, builder: (column) => column);

  GeneratedColumn<String> get bqtire =>
      $composableBuilder(column: $table.bqtire, builder: (column) => column);

  GeneratedColumn<double> get montant =>
      $composableBuilder(column: $table.montant, builder: (column) => column);

  GeneratedColumn<DateTime> get datechq =>
      $composableBuilder(column: $table.datechq, builder: (column) => column);

  GeneratedColumn<DateTime> get daterecep =>
      $composableBuilder(column: $table.daterecep, builder: (column) => column);

  GeneratedColumn<String> get action =>
      $composableBuilder(column: $table.action, builder: (column) => column);

  GeneratedColumn<String> get nonaction =>
      $composableBuilder(column: $table.nonaction, builder: (column) => column);

  GeneratedColumn<String> get numventes =>
      $composableBuilder(column: $table.numventes, builder: (column) => column);

  GeneratedColumn<String> get verification => $composableBuilder(
      column: $table.verification, builder: (column) => column);
}

class $$EffetsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $EffetsTable,
    Effet,
    $$EffetsTableFilterComposer,
    $$EffetsTableOrderingComposer,
    $$EffetsTableAnnotationComposer,
    $$EffetsTableCreateCompanionBuilder,
    $$EffetsTableUpdateCompanionBuilder,
    (Effet, BaseReferences<_$AppDatabase, $EffetsTable, Effet>),
    Effet,
    PrefetchHooks Function()> {
  $$EffetsTableTableManager(_$AppDatabase db, $EffetsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$EffetsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$EffetsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$EffetsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int?> a = const Value.absent(),
            Value<int?> nop = const Value.absent(),
            Value<String?> ncheq = const Value.absent(),
            Value<String?> tire = const Value.absent(),
            Value<String?> bqtire = const Value.absent(),
            Value<double?> montant = const Value.absent(),
            Value<DateTime?> datechq = const Value.absent(),
            Value<DateTime?> daterecep = const Value.absent(),
            Value<String?> action = const Value.absent(),
            Value<String?> nonaction = const Value.absent(),
            Value<String?> numventes = const Value.absent(),
            Value<String?> verification = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              EffetsCompanion(
            a: a,
            nop: nop,
            ncheq: ncheq,
            tire: tire,
            bqtire: bqtire,
            montant: montant,
            datechq: datechq,
            daterecep: daterecep,
            action: action,
            nonaction: nonaction,
            numventes: numventes,
            verification: verification,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            Value<int?> a = const Value.absent(),
            Value<int?> nop = const Value.absent(),
            Value<String?> ncheq = const Value.absent(),
            Value<String?> tire = const Value.absent(),
            Value<String?> bqtire = const Value.absent(),
            Value<double?> montant = const Value.absent(),
            Value<DateTime?> datechq = const Value.absent(),
            Value<DateTime?> daterecep = const Value.absent(),
            Value<String?> action = const Value.absent(),
            Value<String?> nonaction = const Value.absent(),
            Value<String?> numventes = const Value.absent(),
            Value<String?> verification = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              EffetsCompanion.insert(
            a: a,
            nop: nop,
            ncheq: ncheq,
            tire: tire,
            bqtire: bqtire,
            montant: montant,
            datechq: datechq,
            daterecep: daterecep,
            action: action,
            nonaction: nonaction,
            numventes: numventes,
            verification: verification,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$EffetsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $EffetsTable,
    Effet,
    $$EffetsTableFilterComposer,
    $$EffetsTableOrderingComposer,
    $$EffetsTableAnnotationComposer,
    $$EffetsTableCreateCompanionBuilder,
    $$EffetsTableUpdateCompanionBuilder,
    (Effet, BaseReferences<_$AppDatabase, $EffetsTable, Effet>),
    Effet,
    PrefetchHooks Function()>;
typedef $$EmbTableCreateCompanionBuilder = EmbCompanion Function({
  required String designation,
  Value<double?> vo,
  Value<String?> action,
  Value<String?> categorie,
  Value<double?> amt,
  Value<DateTime?> daty,
  Value<String?> description,
  Value<double?> taux,
  Value<int> rowid,
});
typedef $$EmbTableUpdateCompanionBuilder = EmbCompanion Function({
  Value<String> designation,
  Value<double?> vo,
  Value<String?> action,
  Value<String?> categorie,
  Value<double?> amt,
  Value<DateTime?> daty,
  Value<String?> description,
  Value<double?> taux,
  Value<int> rowid,
});

class $$EmbTableFilterComposer extends Composer<_$AppDatabase, $EmbTable> {
  $$EmbTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get designation => $composableBuilder(
      column: $table.designation, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get vo => $composableBuilder(
      column: $table.vo, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get action => $composableBuilder(
      column: $table.action, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get categorie => $composableBuilder(
      column: $table.categorie, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get amt => $composableBuilder(
      column: $table.amt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get taux => $composableBuilder(
      column: $table.taux, builder: (column) => ColumnFilters(column));
}

class $$EmbTableOrderingComposer extends Composer<_$AppDatabase, $EmbTable> {
  $$EmbTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get designation => $composableBuilder(
      column: $table.designation, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get vo => $composableBuilder(
      column: $table.vo, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get action => $composableBuilder(
      column: $table.action, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get categorie => $composableBuilder(
      column: $table.categorie, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get amt => $composableBuilder(
      column: $table.amt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get taux => $composableBuilder(
      column: $table.taux, builder: (column) => ColumnOrderings(column));
}

class $$EmbTableAnnotationComposer extends Composer<_$AppDatabase, $EmbTable> {
  $$EmbTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get designation => $composableBuilder(
      column: $table.designation, builder: (column) => column);

  GeneratedColumn<double> get vo =>
      $composableBuilder(column: $table.vo, builder: (column) => column);

  GeneratedColumn<String> get action =>
      $composableBuilder(column: $table.action, builder: (column) => column);

  GeneratedColumn<String> get categorie =>
      $composableBuilder(column: $table.categorie, builder: (column) => column);

  GeneratedColumn<double> get amt =>
      $composableBuilder(column: $table.amt, builder: (column) => column);

  GeneratedColumn<DateTime> get daty =>
      $composableBuilder(column: $table.daty, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => column);

  GeneratedColumn<double> get taux =>
      $composableBuilder(column: $table.taux, builder: (column) => column);
}

class $$EmbTableTableManager extends RootTableManager<
    _$AppDatabase,
    $EmbTable,
    EmbData,
    $$EmbTableFilterComposer,
    $$EmbTableOrderingComposer,
    $$EmbTableAnnotationComposer,
    $$EmbTableCreateCompanionBuilder,
    $$EmbTableUpdateCompanionBuilder,
    (EmbData, BaseReferences<_$AppDatabase, $EmbTable, EmbData>),
    EmbData,
    PrefetchHooks Function()> {
  $$EmbTableTableManager(_$AppDatabase db, $EmbTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$EmbTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$EmbTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$EmbTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> designation = const Value.absent(),
            Value<double?> vo = const Value.absent(),
            Value<String?> action = const Value.absent(),
            Value<String?> categorie = const Value.absent(),
            Value<double?> amt = const Value.absent(),
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> description = const Value.absent(),
            Value<double?> taux = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              EmbCompanion(
            designation: designation,
            vo: vo,
            action: action,
            categorie: categorie,
            amt: amt,
            daty: daty,
            description: description,
            taux: taux,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String designation,
            Value<double?> vo = const Value.absent(),
            Value<String?> action = const Value.absent(),
            Value<String?> categorie = const Value.absent(),
            Value<double?> amt = const Value.absent(),
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> description = const Value.absent(),
            Value<double?> taux = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              EmbCompanion.insert(
            designation: designation,
            vo: vo,
            action: action,
            categorie: categorie,
            amt: amt,
            daty: daty,
            description: description,
            taux: taux,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$EmbTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $EmbTable,
    EmbData,
    $$EmbTableFilterComposer,
    $$EmbTableOrderingComposer,
    $$EmbTableAnnotationComposer,
    $$EmbTableCreateCompanionBuilder,
    $$EmbTableUpdateCompanionBuilder,
    (EmbData, BaseReferences<_$AppDatabase, $EmbTable, EmbData>),
    EmbData,
    PrefetchHooks Function()>;
typedef $$EmblcltTableCreateCompanionBuilder = EmblcltCompanion Function({
  Value<int> num,
  Value<String?> numventes,
  Value<String?> nfact,
  Value<DateTime?> daty,
  Value<String?> clt,
  Value<String?> emb,
  Value<double?> q,
  Value<String?> verification,
});
typedef $$EmblcltTableUpdateCompanionBuilder = EmblcltCompanion Function({
  Value<int> num,
  Value<String?> numventes,
  Value<String?> nfact,
  Value<DateTime?> daty,
  Value<String?> clt,
  Value<String?> emb,
  Value<double?> q,
  Value<String?> verification,
});

class $$EmblcltTableFilterComposer
    extends Composer<_$AppDatabase, $EmblcltTable> {
  $$EmblcltTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get num => $composableBuilder(
      column: $table.num, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get numventes => $composableBuilder(
      column: $table.numventes, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nfact => $composableBuilder(
      column: $table.nfact, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get clt => $composableBuilder(
      column: $table.clt, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get emb => $composableBuilder(
      column: $table.emb, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get q => $composableBuilder(
      column: $table.q, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get verification => $composableBuilder(
      column: $table.verification, builder: (column) => ColumnFilters(column));
}

class $$EmblcltTableOrderingComposer
    extends Composer<_$AppDatabase, $EmblcltTable> {
  $$EmblcltTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get num => $composableBuilder(
      column: $table.num, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get numventes => $composableBuilder(
      column: $table.numventes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nfact => $composableBuilder(
      column: $table.nfact, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get clt => $composableBuilder(
      column: $table.clt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get emb => $composableBuilder(
      column: $table.emb, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get q => $composableBuilder(
      column: $table.q, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get verification => $composableBuilder(
      column: $table.verification,
      builder: (column) => ColumnOrderings(column));
}

class $$EmblcltTableAnnotationComposer
    extends Composer<_$AppDatabase, $EmblcltTable> {
  $$EmblcltTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get num =>
      $composableBuilder(column: $table.num, builder: (column) => column);

  GeneratedColumn<String> get numventes =>
      $composableBuilder(column: $table.numventes, builder: (column) => column);

  GeneratedColumn<String> get nfact =>
      $composableBuilder(column: $table.nfact, builder: (column) => column);

  GeneratedColumn<DateTime> get daty =>
      $composableBuilder(column: $table.daty, builder: (column) => column);

  GeneratedColumn<String> get clt =>
      $composableBuilder(column: $table.clt, builder: (column) => column);

  GeneratedColumn<String> get emb =>
      $composableBuilder(column: $table.emb, builder: (column) => column);

  GeneratedColumn<double> get q =>
      $composableBuilder(column: $table.q, builder: (column) => column);

  GeneratedColumn<String> get verification => $composableBuilder(
      column: $table.verification, builder: (column) => column);
}

class $$EmblcltTableTableManager extends RootTableManager<
    _$AppDatabase,
    $EmblcltTable,
    EmblcltData,
    $$EmblcltTableFilterComposer,
    $$EmblcltTableOrderingComposer,
    $$EmblcltTableAnnotationComposer,
    $$EmblcltTableCreateCompanionBuilder,
    $$EmblcltTableUpdateCompanionBuilder,
    (EmblcltData, BaseReferences<_$AppDatabase, $EmblcltTable, EmblcltData>),
    EmblcltData,
    PrefetchHooks Function()> {
  $$EmblcltTableTableManager(_$AppDatabase db, $EmblcltTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$EmblcltTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$EmblcltTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$EmblcltTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> num = const Value.absent(),
            Value<String?> numventes = const Value.absent(),
            Value<String?> nfact = const Value.absent(),
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> clt = const Value.absent(),
            Value<String?> emb = const Value.absent(),
            Value<double?> q = const Value.absent(),
            Value<String?> verification = const Value.absent(),
          }) =>
              EmblcltCompanion(
            num: num,
            numventes: numventes,
            nfact: nfact,
            daty: daty,
            clt: clt,
            emb: emb,
            q: q,
            verification: verification,
          ),
          createCompanionCallback: ({
            Value<int> num = const Value.absent(),
            Value<String?> numventes = const Value.absent(),
            Value<String?> nfact = const Value.absent(),
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> clt = const Value.absent(),
            Value<String?> emb = const Value.absent(),
            Value<double?> q = const Value.absent(),
            Value<String?> verification = const Value.absent(),
          }) =>
              EmblcltCompanion.insert(
            num: num,
            numventes: numventes,
            nfact: nfact,
            daty: daty,
            clt: clt,
            emb: emb,
            q: q,
            verification: verification,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$EmblcltTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $EmblcltTable,
    EmblcltData,
    $$EmblcltTableFilterComposer,
    $$EmblcltTableOrderingComposer,
    $$EmblcltTableAnnotationComposer,
    $$EmblcltTableCreateCompanionBuilder,
    $$EmblcltTableUpdateCompanionBuilder,
    (EmblcltData, BaseReferences<_$AppDatabase, $EmblcltTable, EmblcltData>),
    EmblcltData,
    PrefetchHooks Function()>;
typedef $$FstocksTableCreateCompanionBuilder = FstocksCompanion Function({
  required String ref,
  Value<String?> art,
  Value<double?> qe,
  Value<double?> qs,
  Value<double?> qst,
  Value<String?> ue,
  Value<int> rowid,
});
typedef $$FstocksTableUpdateCompanionBuilder = FstocksCompanion Function({
  Value<String> ref,
  Value<String?> art,
  Value<double?> qe,
  Value<double?> qs,
  Value<double?> qst,
  Value<String?> ue,
  Value<int> rowid,
});

class $$FstocksTableFilterComposer
    extends Composer<_$AppDatabase, $FstocksTable> {
  $$FstocksTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get ref => $composableBuilder(
      column: $table.ref, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get art => $composableBuilder(
      column: $table.art, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get qe => $composableBuilder(
      column: $table.qe, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get qs => $composableBuilder(
      column: $table.qs, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get qst => $composableBuilder(
      column: $table.qst, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get ue => $composableBuilder(
      column: $table.ue, builder: (column) => ColumnFilters(column));
}

class $$FstocksTableOrderingComposer
    extends Composer<_$AppDatabase, $FstocksTable> {
  $$FstocksTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get ref => $composableBuilder(
      column: $table.ref, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get art => $composableBuilder(
      column: $table.art, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get qe => $composableBuilder(
      column: $table.qe, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get qs => $composableBuilder(
      column: $table.qs, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get qst => $composableBuilder(
      column: $table.qst, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get ue => $composableBuilder(
      column: $table.ue, builder: (column) => ColumnOrderings(column));
}

class $$FstocksTableAnnotationComposer
    extends Composer<_$AppDatabase, $FstocksTable> {
  $$FstocksTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get ref =>
      $composableBuilder(column: $table.ref, builder: (column) => column);

  GeneratedColumn<String> get art =>
      $composableBuilder(column: $table.art, builder: (column) => column);

  GeneratedColumn<double> get qe =>
      $composableBuilder(column: $table.qe, builder: (column) => column);

  GeneratedColumn<double> get qs =>
      $composableBuilder(column: $table.qs, builder: (column) => column);

  GeneratedColumn<double> get qst =>
      $composableBuilder(column: $table.qst, builder: (column) => column);

  GeneratedColumn<String> get ue =>
      $composableBuilder(column: $table.ue, builder: (column) => column);
}

class $$FstocksTableTableManager extends RootTableManager<
    _$AppDatabase,
    $FstocksTable,
    Fstock,
    $$FstocksTableFilterComposer,
    $$FstocksTableOrderingComposer,
    $$FstocksTableAnnotationComposer,
    $$FstocksTableCreateCompanionBuilder,
    $$FstocksTableUpdateCompanionBuilder,
    (Fstock, BaseReferences<_$AppDatabase, $FstocksTable, Fstock>),
    Fstock,
    PrefetchHooks Function()> {
  $$FstocksTableTableManager(_$AppDatabase db, $FstocksTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$FstocksTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$FstocksTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$FstocksTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> ref = const Value.absent(),
            Value<String?> art = const Value.absent(),
            Value<double?> qe = const Value.absent(),
            Value<double?> qs = const Value.absent(),
            Value<double?> qst = const Value.absent(),
            Value<String?> ue = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              FstocksCompanion(
            ref: ref,
            art: art,
            qe: qe,
            qs: qs,
            qst: qst,
            ue: ue,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String ref,
            Value<String?> art = const Value.absent(),
            Value<double?> qe = const Value.absent(),
            Value<double?> qs = const Value.absent(),
            Value<double?> qst = const Value.absent(),
            Value<String?> ue = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              FstocksCompanion.insert(
            ref: ref,
            art: art,
            qe: qe,
            qs: qs,
            qst: qst,
            ue: ue,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$FstocksTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $FstocksTable,
    Fstock,
    $$FstocksTableFilterComposer,
    $$FstocksTableOrderingComposer,
    $$FstocksTableAnnotationComposer,
    $$FstocksTableCreateCompanionBuilder,
    $$FstocksTableUpdateCompanionBuilder,
    (Fstock, BaseReferences<_$AppDatabase, $FstocksTable, Fstock>),
    Fstock,
    PrefetchHooks Function()>;
typedef $$MpTableCreateCompanionBuilder = MpCompanion Function({
  required String mp,
  Value<int> rowid,
});
typedef $$MpTableUpdateCompanionBuilder = MpCompanion Function({
  Value<String> mp,
  Value<int> rowid,
});

class $$MpTableFilterComposer extends Composer<_$AppDatabase, $MpTable> {
  $$MpTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get mp => $composableBuilder(
      column: $table.mp, builder: (column) => ColumnFilters(column));
}

class $$MpTableOrderingComposer extends Composer<_$AppDatabase, $MpTable> {
  $$MpTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get mp => $composableBuilder(
      column: $table.mp, builder: (column) => ColumnOrderings(column));
}

class $$MpTableAnnotationComposer extends Composer<_$AppDatabase, $MpTable> {
  $$MpTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get mp =>
      $composableBuilder(column: $table.mp, builder: (column) => column);
}

class $$MpTableTableManager extends RootTableManager<
    _$AppDatabase,
    $MpTable,
    MpData,
    $$MpTableFilterComposer,
    $$MpTableOrderingComposer,
    $$MpTableAnnotationComposer,
    $$MpTableCreateCompanionBuilder,
    $$MpTableUpdateCompanionBuilder,
    (MpData, BaseReferences<_$AppDatabase, $MpTable, MpData>),
    MpData,
    PrefetchHooks Function()> {
  $$MpTableTableManager(_$AppDatabase db, $MpTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$MpTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$MpTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$MpTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> mp = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              MpCompanion(
            mp: mp,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String mp,
            Value<int> rowid = const Value.absent(),
          }) =>
              MpCompanion.insert(
            mp: mp,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$MpTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $MpTable,
    MpData,
    $$MpTableFilterComposer,
    $$MpTableOrderingComposer,
    $$MpTableAnnotationComposer,
    $$MpTableCreateCompanionBuilder,
    $$MpTableUpdateCompanionBuilder,
    (MpData, BaseReferences<_$AppDatabase, $MpTable, MpData>),
    MpData,
    PrefetchHooks Function()>;
typedef $$ProdTableCreateCompanionBuilder = ProdCompanion Function({
  Value<int> num,
  Value<String?> numaprod,
  Value<String?> obs,
  Value<DateTime?> socDaty,
  Value<String?> produits,
  Value<String?> depot,
  Value<String?> cte,
  Value<double?> totalttc,
  Value<double?> cmup,
  Value<String?> verification,
  Value<String?> type,
  Value<String?> unite,
  Value<String?> contre,
});
typedef $$ProdTableUpdateCompanionBuilder = ProdCompanion Function({
  Value<int> num,
  Value<String?> numaprod,
  Value<String?> obs,
  Value<DateTime?> socDaty,
  Value<String?> produits,
  Value<String?> depot,
  Value<String?> cte,
  Value<double?> totalttc,
  Value<double?> cmup,
  Value<String?> verification,
  Value<String?> type,
  Value<String?> unite,
  Value<String?> contre,
});

class $$ProdTableFilterComposer extends Composer<_$AppDatabase, $ProdTable> {
  $$ProdTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get num => $composableBuilder(
      column: $table.num, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get numaprod => $composableBuilder(
      column: $table.numaprod, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get obs => $composableBuilder(
      column: $table.obs, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get socDaty => $composableBuilder(
      column: $table.socDaty, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get produits => $composableBuilder(
      column: $table.produits, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get depot => $composableBuilder(
      column: $table.depot, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get cte => $composableBuilder(
      column: $table.cte, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get totalttc => $composableBuilder(
      column: $table.totalttc, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get cmup => $composableBuilder(
      column: $table.cmup, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get verification => $composableBuilder(
      column: $table.verification, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get unite => $composableBuilder(
      column: $table.unite, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get contre => $composableBuilder(
      column: $table.contre, builder: (column) => ColumnFilters(column));
}

class $$ProdTableOrderingComposer extends Composer<_$AppDatabase, $ProdTable> {
  $$ProdTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get num => $composableBuilder(
      column: $table.num, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get numaprod => $composableBuilder(
      column: $table.numaprod, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get obs => $composableBuilder(
      column: $table.obs, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get socDaty => $composableBuilder(
      column: $table.socDaty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get produits => $composableBuilder(
      column: $table.produits, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get depot => $composableBuilder(
      column: $table.depot, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get cte => $composableBuilder(
      column: $table.cte, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get totalttc => $composableBuilder(
      column: $table.totalttc, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get cmup => $composableBuilder(
      column: $table.cmup, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get verification => $composableBuilder(
      column: $table.verification,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get unite => $composableBuilder(
      column: $table.unite, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get contre => $composableBuilder(
      column: $table.contre, builder: (column) => ColumnOrderings(column));
}

class $$ProdTableAnnotationComposer
    extends Composer<_$AppDatabase, $ProdTable> {
  $$ProdTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get num =>
      $composableBuilder(column: $table.num, builder: (column) => column);

  GeneratedColumn<String> get numaprod =>
      $composableBuilder(column: $table.numaprod, builder: (column) => column);

  GeneratedColumn<String> get obs =>
      $composableBuilder(column: $table.obs, builder: (column) => column);

  GeneratedColumn<DateTime> get socDaty =>
      $composableBuilder(column: $table.socDaty, builder: (column) => column);

  GeneratedColumn<String> get produits =>
      $composableBuilder(column: $table.produits, builder: (column) => column);

  GeneratedColumn<String> get depot =>
      $composableBuilder(column: $table.depot, builder: (column) => column);

  GeneratedColumn<String> get cte =>
      $composableBuilder(column: $table.cte, builder: (column) => column);

  GeneratedColumn<double> get totalttc =>
      $composableBuilder(column: $table.totalttc, builder: (column) => column);

  GeneratedColumn<double> get cmup =>
      $composableBuilder(column: $table.cmup, builder: (column) => column);

  GeneratedColumn<String> get verification => $composableBuilder(
      column: $table.verification, builder: (column) => column);

  GeneratedColumn<String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  GeneratedColumn<String> get unite =>
      $composableBuilder(column: $table.unite, builder: (column) => column);

  GeneratedColumn<String> get contre =>
      $composableBuilder(column: $table.contre, builder: (column) => column);
}

class $$ProdTableTableManager extends RootTableManager<
    _$AppDatabase,
    $ProdTable,
    ProdData,
    $$ProdTableFilterComposer,
    $$ProdTableOrderingComposer,
    $$ProdTableAnnotationComposer,
    $$ProdTableCreateCompanionBuilder,
    $$ProdTableUpdateCompanionBuilder,
    (ProdData, BaseReferences<_$AppDatabase, $ProdTable, ProdData>),
    ProdData,
    PrefetchHooks Function()> {
  $$ProdTableTableManager(_$AppDatabase db, $ProdTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ProdTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ProdTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ProdTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> num = const Value.absent(),
            Value<String?> numaprod = const Value.absent(),
            Value<String?> obs = const Value.absent(),
            Value<DateTime?> socDaty = const Value.absent(),
            Value<String?> produits = const Value.absent(),
            Value<String?> depot = const Value.absent(),
            Value<String?> cte = const Value.absent(),
            Value<double?> totalttc = const Value.absent(),
            Value<double?> cmup = const Value.absent(),
            Value<String?> verification = const Value.absent(),
            Value<String?> type = const Value.absent(),
            Value<String?> unite = const Value.absent(),
            Value<String?> contre = const Value.absent(),
          }) =>
              ProdCompanion(
            num: num,
            numaprod: numaprod,
            obs: obs,
            socDaty: socDaty,
            produits: produits,
            depot: depot,
            cte: cte,
            totalttc: totalttc,
            cmup: cmup,
            verification: verification,
            type: type,
            unite: unite,
            contre: contre,
          ),
          createCompanionCallback: ({
            Value<int> num = const Value.absent(),
            Value<String?> numaprod = const Value.absent(),
            Value<String?> obs = const Value.absent(),
            Value<DateTime?> socDaty = const Value.absent(),
            Value<String?> produits = const Value.absent(),
            Value<String?> depot = const Value.absent(),
            Value<String?> cte = const Value.absent(),
            Value<double?> totalttc = const Value.absent(),
            Value<double?> cmup = const Value.absent(),
            Value<String?> verification = const Value.absent(),
            Value<String?> type = const Value.absent(),
            Value<String?> unite = const Value.absent(),
            Value<String?> contre = const Value.absent(),
          }) =>
              ProdCompanion.insert(
            num: num,
            numaprod: numaprod,
            obs: obs,
            socDaty: socDaty,
            produits: produits,
            depot: depot,
            cte: cte,
            totalttc: totalttc,
            cmup: cmup,
            verification: verification,
            type: type,
            unite: unite,
            contre: contre,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$ProdTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $ProdTable,
    ProdData,
    $$ProdTableFilterComposer,
    $$ProdTableOrderingComposer,
    $$ProdTableAnnotationComposer,
    $$ProdTableCreateCompanionBuilder,
    $$ProdTableUpdateCompanionBuilder,
    (ProdData, BaseReferences<_$AppDatabase, $ProdTable, ProdData>),
    ProdData,
    PrefetchHooks Function()>;
typedef $$PvTableCreateCompanionBuilder = PvCompanion Function({
  required String designation,
  Value<String?> categorie,
  Value<double?> pvu1,
  Value<double?> pvu2,
  Value<double?> pvu3,
  Value<int> rowid,
});
typedef $$PvTableUpdateCompanionBuilder = PvCompanion Function({
  Value<String> designation,
  Value<String?> categorie,
  Value<double?> pvu1,
  Value<double?> pvu2,
  Value<double?> pvu3,
  Value<int> rowid,
});

class $$PvTableFilterComposer extends Composer<_$AppDatabase, $PvTable> {
  $$PvTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get designation => $composableBuilder(
      column: $table.designation, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get categorie => $composableBuilder(
      column: $table.categorie, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get pvu1 => $composableBuilder(
      column: $table.pvu1, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get pvu2 => $composableBuilder(
      column: $table.pvu2, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get pvu3 => $composableBuilder(
      column: $table.pvu3, builder: (column) => ColumnFilters(column));
}

class $$PvTableOrderingComposer extends Composer<_$AppDatabase, $PvTable> {
  $$PvTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get designation => $composableBuilder(
      column: $table.designation, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get categorie => $composableBuilder(
      column: $table.categorie, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get pvu1 => $composableBuilder(
      column: $table.pvu1, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get pvu2 => $composableBuilder(
      column: $table.pvu2, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get pvu3 => $composableBuilder(
      column: $table.pvu3, builder: (column) => ColumnOrderings(column));
}

class $$PvTableAnnotationComposer extends Composer<_$AppDatabase, $PvTable> {
  $$PvTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get designation => $composableBuilder(
      column: $table.designation, builder: (column) => column);

  GeneratedColumn<String> get categorie =>
      $composableBuilder(column: $table.categorie, builder: (column) => column);

  GeneratedColumn<double> get pvu1 =>
      $composableBuilder(column: $table.pvu1, builder: (column) => column);

  GeneratedColumn<double> get pvu2 =>
      $composableBuilder(column: $table.pvu2, builder: (column) => column);

  GeneratedColumn<double> get pvu3 =>
      $composableBuilder(column: $table.pvu3, builder: (column) => column);
}

class $$PvTableTableManager extends RootTableManager<
    _$AppDatabase,
    $PvTable,
    PvData,
    $$PvTableFilterComposer,
    $$PvTableOrderingComposer,
    $$PvTableAnnotationComposer,
    $$PvTableCreateCompanionBuilder,
    $$PvTableUpdateCompanionBuilder,
    (PvData, BaseReferences<_$AppDatabase, $PvTable, PvData>),
    PvData,
    PrefetchHooks Function()> {
  $$PvTableTableManager(_$AppDatabase db, $PvTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PvTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PvTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PvTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> designation = const Value.absent(),
            Value<String?> categorie = const Value.absent(),
            Value<double?> pvu1 = const Value.absent(),
            Value<double?> pvu2 = const Value.absent(),
            Value<double?> pvu3 = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              PvCompanion(
            designation: designation,
            categorie: categorie,
            pvu1: pvu1,
            pvu2: pvu2,
            pvu3: pvu3,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String designation,
            Value<String?> categorie = const Value.absent(),
            Value<double?> pvu1 = const Value.absent(),
            Value<double?> pvu2 = const Value.absent(),
            Value<double?> pvu3 = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              PvCompanion.insert(
            designation: designation,
            categorie: categorie,
            pvu1: pvu1,
            pvu2: pvu2,
            pvu3: pvu3,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$PvTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $PvTable,
    PvData,
    $$PvTableFilterComposer,
    $$PvTableOrderingComposer,
    $$PvTableAnnotationComposer,
    $$PvTableCreateCompanionBuilder,
    $$PvTableUpdateCompanionBuilder,
    (PvData, BaseReferences<_$AppDatabase, $PvTable, PvData>),
    PvData,
    PrefetchHooks Function()>;
typedef $$RetachatsTableCreateCompanionBuilder = RetachatsCompanion Function({
  Value<int> num,
  Value<String?> numachats,
  Value<String?> nfact,
  Value<DateTime?> daty,
  Value<String?> frns,
  Value<String?> modepai,
  Value<DateTime?> echeance,
  Value<double?> totalnt,
  Value<double?> totalttc,
  Value<double?> tva,
  Value<String?> contre,
  Value<String?> bq,
  Value<String?> verification,
  Value<String?> type,
  Value<String?> numachats1,
});
typedef $$RetachatsTableUpdateCompanionBuilder = RetachatsCompanion Function({
  Value<int> num,
  Value<String?> numachats,
  Value<String?> nfact,
  Value<DateTime?> daty,
  Value<String?> frns,
  Value<String?> modepai,
  Value<DateTime?> echeance,
  Value<double?> totalnt,
  Value<double?> totalttc,
  Value<double?> tva,
  Value<String?> contre,
  Value<String?> bq,
  Value<String?> verification,
  Value<String?> type,
  Value<String?> numachats1,
});

class $$RetachatsTableFilterComposer
    extends Composer<_$AppDatabase, $RetachatsTable> {
  $$RetachatsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get num => $composableBuilder(
      column: $table.num, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get numachats => $composableBuilder(
      column: $table.numachats, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nfact => $composableBuilder(
      column: $table.nfact, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get frns => $composableBuilder(
      column: $table.frns, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get modepai => $composableBuilder(
      column: $table.modepai, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get echeance => $composableBuilder(
      column: $table.echeance, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get totalnt => $composableBuilder(
      column: $table.totalnt, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get totalttc => $composableBuilder(
      column: $table.totalttc, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get tva => $composableBuilder(
      column: $table.tva, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get contre => $composableBuilder(
      column: $table.contre, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get bq => $composableBuilder(
      column: $table.bq, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get verification => $composableBuilder(
      column: $table.verification, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get numachats1 => $composableBuilder(
      column: $table.numachats1, builder: (column) => ColumnFilters(column));
}

class $$RetachatsTableOrderingComposer
    extends Composer<_$AppDatabase, $RetachatsTable> {
  $$RetachatsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get num => $composableBuilder(
      column: $table.num, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get numachats => $composableBuilder(
      column: $table.numachats, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nfact => $composableBuilder(
      column: $table.nfact, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get frns => $composableBuilder(
      column: $table.frns, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get modepai => $composableBuilder(
      column: $table.modepai, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get echeance => $composableBuilder(
      column: $table.echeance, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get totalnt => $composableBuilder(
      column: $table.totalnt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get totalttc => $composableBuilder(
      column: $table.totalttc, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get tva => $composableBuilder(
      column: $table.tva, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get contre => $composableBuilder(
      column: $table.contre, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get bq => $composableBuilder(
      column: $table.bq, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get verification => $composableBuilder(
      column: $table.verification,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get numachats1 => $composableBuilder(
      column: $table.numachats1, builder: (column) => ColumnOrderings(column));
}

class $$RetachatsTableAnnotationComposer
    extends Composer<_$AppDatabase, $RetachatsTable> {
  $$RetachatsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get num =>
      $composableBuilder(column: $table.num, builder: (column) => column);

  GeneratedColumn<String> get numachats =>
      $composableBuilder(column: $table.numachats, builder: (column) => column);

  GeneratedColumn<String> get nfact =>
      $composableBuilder(column: $table.nfact, builder: (column) => column);

  GeneratedColumn<DateTime> get daty =>
      $composableBuilder(column: $table.daty, builder: (column) => column);

  GeneratedColumn<String> get frns =>
      $composableBuilder(column: $table.frns, builder: (column) => column);

  GeneratedColumn<String> get modepai =>
      $composableBuilder(column: $table.modepai, builder: (column) => column);

  GeneratedColumn<DateTime> get echeance =>
      $composableBuilder(column: $table.echeance, builder: (column) => column);

  GeneratedColumn<double> get totalnt =>
      $composableBuilder(column: $table.totalnt, builder: (column) => column);

  GeneratedColumn<double> get totalttc =>
      $composableBuilder(column: $table.totalttc, builder: (column) => column);

  GeneratedColumn<double> get tva =>
      $composableBuilder(column: $table.tva, builder: (column) => column);

  GeneratedColumn<String> get contre =>
      $composableBuilder(column: $table.contre, builder: (column) => column);

  GeneratedColumn<String> get bq =>
      $composableBuilder(column: $table.bq, builder: (column) => column);

  GeneratedColumn<String> get verification => $composableBuilder(
      column: $table.verification, builder: (column) => column);

  GeneratedColumn<String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  GeneratedColumn<String> get numachats1 => $composableBuilder(
      column: $table.numachats1, builder: (column) => column);
}

class $$RetachatsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $RetachatsTable,
    Retachat,
    $$RetachatsTableFilterComposer,
    $$RetachatsTableOrderingComposer,
    $$RetachatsTableAnnotationComposer,
    $$RetachatsTableCreateCompanionBuilder,
    $$RetachatsTableUpdateCompanionBuilder,
    (Retachat, BaseReferences<_$AppDatabase, $RetachatsTable, Retachat>),
    Retachat,
    PrefetchHooks Function()> {
  $$RetachatsTableTableManager(_$AppDatabase db, $RetachatsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$RetachatsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$RetachatsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$RetachatsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> num = const Value.absent(),
            Value<String?> numachats = const Value.absent(),
            Value<String?> nfact = const Value.absent(),
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> frns = const Value.absent(),
            Value<String?> modepai = const Value.absent(),
            Value<DateTime?> echeance = const Value.absent(),
            Value<double?> totalnt = const Value.absent(),
            Value<double?> totalttc = const Value.absent(),
            Value<double?> tva = const Value.absent(),
            Value<String?> contre = const Value.absent(),
            Value<String?> bq = const Value.absent(),
            Value<String?> verification = const Value.absent(),
            Value<String?> type = const Value.absent(),
            Value<String?> numachats1 = const Value.absent(),
          }) =>
              RetachatsCompanion(
            num: num,
            numachats: numachats,
            nfact: nfact,
            daty: daty,
            frns: frns,
            modepai: modepai,
            echeance: echeance,
            totalnt: totalnt,
            totalttc: totalttc,
            tva: tva,
            contre: contre,
            bq: bq,
            verification: verification,
            type: type,
            numachats1: numachats1,
          ),
          createCompanionCallback: ({
            Value<int> num = const Value.absent(),
            Value<String?> numachats = const Value.absent(),
            Value<String?> nfact = const Value.absent(),
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> frns = const Value.absent(),
            Value<String?> modepai = const Value.absent(),
            Value<DateTime?> echeance = const Value.absent(),
            Value<double?> totalnt = const Value.absent(),
            Value<double?> totalttc = const Value.absent(),
            Value<double?> tva = const Value.absent(),
            Value<String?> contre = const Value.absent(),
            Value<String?> bq = const Value.absent(),
            Value<String?> verification = const Value.absent(),
            Value<String?> type = const Value.absent(),
            Value<String?> numachats1 = const Value.absent(),
          }) =>
              RetachatsCompanion.insert(
            num: num,
            numachats: numachats,
            nfact: nfact,
            daty: daty,
            frns: frns,
            modepai: modepai,
            echeance: echeance,
            totalnt: totalnt,
            totalttc: totalttc,
            tva: tva,
            contre: contre,
            bq: bq,
            verification: verification,
            type: type,
            numachats1: numachats1,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$RetachatsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $RetachatsTable,
    Retachat,
    $$RetachatsTableFilterComposer,
    $$RetachatsTableOrderingComposer,
    $$RetachatsTableAnnotationComposer,
    $$RetachatsTableCreateCompanionBuilder,
    $$RetachatsTableUpdateCompanionBuilder,
    (Retachat, BaseReferences<_$AppDatabase, $RetachatsTable, Retachat>),
    Retachat,
    PrefetchHooks Function()>;
typedef $$RetdetachatsTableCreateCompanionBuilder = RetdetachatsCompanion
    Function({
  Value<int> num,
  Value<String?> numachats,
  Value<String?> designation,
  Value<String?> unite,
  Value<String?> depots,
  Value<double?> q,
  Value<double?> pu,
});
typedef $$RetdetachatsTableUpdateCompanionBuilder = RetdetachatsCompanion
    Function({
  Value<int> num,
  Value<String?> numachats,
  Value<String?> designation,
  Value<String?> unite,
  Value<String?> depots,
  Value<double?> q,
  Value<double?> pu,
});

class $$RetdetachatsTableFilterComposer
    extends Composer<_$AppDatabase, $RetdetachatsTable> {
  $$RetdetachatsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get num => $composableBuilder(
      column: $table.num, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get numachats => $composableBuilder(
      column: $table.numachats, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get designation => $composableBuilder(
      column: $table.designation, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get unite => $composableBuilder(
      column: $table.unite, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get depots => $composableBuilder(
      column: $table.depots, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get q => $composableBuilder(
      column: $table.q, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get pu => $composableBuilder(
      column: $table.pu, builder: (column) => ColumnFilters(column));
}

class $$RetdetachatsTableOrderingComposer
    extends Composer<_$AppDatabase, $RetdetachatsTable> {
  $$RetdetachatsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get num => $composableBuilder(
      column: $table.num, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get numachats => $composableBuilder(
      column: $table.numachats, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get designation => $composableBuilder(
      column: $table.designation, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get unite => $composableBuilder(
      column: $table.unite, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get depots => $composableBuilder(
      column: $table.depots, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get q => $composableBuilder(
      column: $table.q, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get pu => $composableBuilder(
      column: $table.pu, builder: (column) => ColumnOrderings(column));
}

class $$RetdetachatsTableAnnotationComposer
    extends Composer<_$AppDatabase, $RetdetachatsTable> {
  $$RetdetachatsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get num =>
      $composableBuilder(column: $table.num, builder: (column) => column);

  GeneratedColumn<String> get numachats =>
      $composableBuilder(column: $table.numachats, builder: (column) => column);

  GeneratedColumn<String> get designation => $composableBuilder(
      column: $table.designation, builder: (column) => column);

  GeneratedColumn<String> get unite =>
      $composableBuilder(column: $table.unite, builder: (column) => column);

  GeneratedColumn<String> get depots =>
      $composableBuilder(column: $table.depots, builder: (column) => column);

  GeneratedColumn<double> get q =>
      $composableBuilder(column: $table.q, builder: (column) => column);

  GeneratedColumn<double> get pu =>
      $composableBuilder(column: $table.pu, builder: (column) => column);
}

class $$RetdetachatsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $RetdetachatsTable,
    Retdetachat,
    $$RetdetachatsTableFilterComposer,
    $$RetdetachatsTableOrderingComposer,
    $$RetdetachatsTableAnnotationComposer,
    $$RetdetachatsTableCreateCompanionBuilder,
    $$RetdetachatsTableUpdateCompanionBuilder,
    (
      Retdetachat,
      BaseReferences<_$AppDatabase, $RetdetachatsTable, Retdetachat>
    ),
    Retdetachat,
    PrefetchHooks Function()> {
  $$RetdetachatsTableTableManager(_$AppDatabase db, $RetdetachatsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$RetdetachatsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$RetdetachatsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$RetdetachatsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> num = const Value.absent(),
            Value<String?> numachats = const Value.absent(),
            Value<String?> designation = const Value.absent(),
            Value<String?> unite = const Value.absent(),
            Value<String?> depots = const Value.absent(),
            Value<double?> q = const Value.absent(),
            Value<double?> pu = const Value.absent(),
          }) =>
              RetdetachatsCompanion(
            num: num,
            numachats: numachats,
            designation: designation,
            unite: unite,
            depots: depots,
            q: q,
            pu: pu,
          ),
          createCompanionCallback: ({
            Value<int> num = const Value.absent(),
            Value<String?> numachats = const Value.absent(),
            Value<String?> designation = const Value.absent(),
            Value<String?> unite = const Value.absent(),
            Value<String?> depots = const Value.absent(),
            Value<double?> q = const Value.absent(),
            Value<double?> pu = const Value.absent(),
          }) =>
              RetdetachatsCompanion.insert(
            num: num,
            numachats: numachats,
            designation: designation,
            unite: unite,
            depots: depots,
            q: q,
            pu: pu,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$RetdetachatsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $RetdetachatsTable,
    Retdetachat,
    $$RetdetachatsTableFilterComposer,
    $$RetdetachatsTableOrderingComposer,
    $$RetdetachatsTableAnnotationComposer,
    $$RetdetachatsTableCreateCompanionBuilder,
    $$RetdetachatsTableUpdateCompanionBuilder,
    (
      Retdetachat,
      BaseReferences<_$AppDatabase, $RetdetachatsTable, Retdetachat>
    ),
    Retdetachat,
    PrefetchHooks Function()>;
typedef $$RetdeventesTableCreateCompanionBuilder = RetdeventesCompanion
    Function({
  Value<int> num,
  Value<String?> numventes,
  Value<String?> designation,
  Value<String?> unites,
  Value<String?> depots,
  Value<double?> q,
  Value<double?> pu,
});
typedef $$RetdeventesTableUpdateCompanionBuilder = RetdeventesCompanion
    Function({
  Value<int> num,
  Value<String?> numventes,
  Value<String?> designation,
  Value<String?> unites,
  Value<String?> depots,
  Value<double?> q,
  Value<double?> pu,
});

class $$RetdeventesTableFilterComposer
    extends Composer<_$AppDatabase, $RetdeventesTable> {
  $$RetdeventesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get num => $composableBuilder(
      column: $table.num, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get numventes => $composableBuilder(
      column: $table.numventes, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get designation => $composableBuilder(
      column: $table.designation, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get unites => $composableBuilder(
      column: $table.unites, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get depots => $composableBuilder(
      column: $table.depots, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get q => $composableBuilder(
      column: $table.q, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get pu => $composableBuilder(
      column: $table.pu, builder: (column) => ColumnFilters(column));
}

class $$RetdeventesTableOrderingComposer
    extends Composer<_$AppDatabase, $RetdeventesTable> {
  $$RetdeventesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get num => $composableBuilder(
      column: $table.num, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get numventes => $composableBuilder(
      column: $table.numventes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get designation => $composableBuilder(
      column: $table.designation, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get unites => $composableBuilder(
      column: $table.unites, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get depots => $composableBuilder(
      column: $table.depots, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get q => $composableBuilder(
      column: $table.q, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get pu => $composableBuilder(
      column: $table.pu, builder: (column) => ColumnOrderings(column));
}

class $$RetdeventesTableAnnotationComposer
    extends Composer<_$AppDatabase, $RetdeventesTable> {
  $$RetdeventesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get num =>
      $composableBuilder(column: $table.num, builder: (column) => column);

  GeneratedColumn<String> get numventes =>
      $composableBuilder(column: $table.numventes, builder: (column) => column);

  GeneratedColumn<String> get designation => $composableBuilder(
      column: $table.designation, builder: (column) => column);

  GeneratedColumn<String> get unites =>
      $composableBuilder(column: $table.unites, builder: (column) => column);

  GeneratedColumn<String> get depots =>
      $composableBuilder(column: $table.depots, builder: (column) => column);

  GeneratedColumn<double> get q =>
      $composableBuilder(column: $table.q, builder: (column) => column);

  GeneratedColumn<double> get pu =>
      $composableBuilder(column: $table.pu, builder: (column) => column);
}

class $$RetdeventesTableTableManager extends RootTableManager<
    _$AppDatabase,
    $RetdeventesTable,
    Retdevente,
    $$RetdeventesTableFilterComposer,
    $$RetdeventesTableOrderingComposer,
    $$RetdeventesTableAnnotationComposer,
    $$RetdeventesTableCreateCompanionBuilder,
    $$RetdeventesTableUpdateCompanionBuilder,
    (Retdevente, BaseReferences<_$AppDatabase, $RetdeventesTable, Retdevente>),
    Retdevente,
    PrefetchHooks Function()> {
  $$RetdeventesTableTableManager(_$AppDatabase db, $RetdeventesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$RetdeventesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$RetdeventesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$RetdeventesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> num = const Value.absent(),
            Value<String?> numventes = const Value.absent(),
            Value<String?> designation = const Value.absent(),
            Value<String?> unites = const Value.absent(),
            Value<String?> depots = const Value.absent(),
            Value<double?> q = const Value.absent(),
            Value<double?> pu = const Value.absent(),
          }) =>
              RetdeventesCompanion(
            num: num,
            numventes: numventes,
            designation: designation,
            unites: unites,
            depots: depots,
            q: q,
            pu: pu,
          ),
          createCompanionCallback: ({
            Value<int> num = const Value.absent(),
            Value<String?> numventes = const Value.absent(),
            Value<String?> designation = const Value.absent(),
            Value<String?> unites = const Value.absent(),
            Value<String?> depots = const Value.absent(),
            Value<double?> q = const Value.absent(),
            Value<double?> pu = const Value.absent(),
          }) =>
              RetdeventesCompanion.insert(
            num: num,
            numventes: numventes,
            designation: designation,
            unites: unites,
            depots: depots,
            q: q,
            pu: pu,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$RetdeventesTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $RetdeventesTable,
    Retdevente,
    $$RetdeventesTableFilterComposer,
    $$RetdeventesTableOrderingComposer,
    $$RetdeventesTableAnnotationComposer,
    $$RetdeventesTableCreateCompanionBuilder,
    $$RetdeventesTableUpdateCompanionBuilder,
    (Retdevente, BaseReferences<_$AppDatabase, $RetdeventesTable, Retdevente>),
    Retdevente,
    PrefetchHooks Function()>;
typedef $$RetventesTableCreateCompanionBuilder = RetventesCompanion Function({
  Value<int> num,
  Value<String?> numventes,
  Value<String?> nfact,
  Value<DateTime?> daty,
  Value<String?> clt,
  Value<String?> modepai,
  Value<DateTime?> echeance,
  Value<double?> totalnt,
  Value<double?> totalttc,
  Value<double?> tva,
  Value<String?> contre,
  Value<double?> avance,
  Value<String?> bq,
  Value<String?> commerc,
  Value<double?> commission,
  Value<double?> remise,
  Value<String?> verification,
  Value<String?> type,
  Value<String?> numventes1,
});
typedef $$RetventesTableUpdateCompanionBuilder = RetventesCompanion Function({
  Value<int> num,
  Value<String?> numventes,
  Value<String?> nfact,
  Value<DateTime?> daty,
  Value<String?> clt,
  Value<String?> modepai,
  Value<DateTime?> echeance,
  Value<double?> totalnt,
  Value<double?> totalttc,
  Value<double?> tva,
  Value<String?> contre,
  Value<double?> avance,
  Value<String?> bq,
  Value<String?> commerc,
  Value<double?> commission,
  Value<double?> remise,
  Value<String?> verification,
  Value<String?> type,
  Value<String?> numventes1,
});

class $$RetventesTableFilterComposer
    extends Composer<_$AppDatabase, $RetventesTable> {
  $$RetventesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get num => $composableBuilder(
      column: $table.num, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get numventes => $composableBuilder(
      column: $table.numventes, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nfact => $composableBuilder(
      column: $table.nfact, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get clt => $composableBuilder(
      column: $table.clt, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get modepai => $composableBuilder(
      column: $table.modepai, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get echeance => $composableBuilder(
      column: $table.echeance, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get totalnt => $composableBuilder(
      column: $table.totalnt, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get totalttc => $composableBuilder(
      column: $table.totalttc, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get tva => $composableBuilder(
      column: $table.tva, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get contre => $composableBuilder(
      column: $table.contre, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get avance => $composableBuilder(
      column: $table.avance, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get bq => $composableBuilder(
      column: $table.bq, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get commerc => $composableBuilder(
      column: $table.commerc, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get commission => $composableBuilder(
      column: $table.commission, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get remise => $composableBuilder(
      column: $table.remise, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get verification => $composableBuilder(
      column: $table.verification, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get numventes1 => $composableBuilder(
      column: $table.numventes1, builder: (column) => ColumnFilters(column));
}

class $$RetventesTableOrderingComposer
    extends Composer<_$AppDatabase, $RetventesTable> {
  $$RetventesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get num => $composableBuilder(
      column: $table.num, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get numventes => $composableBuilder(
      column: $table.numventes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nfact => $composableBuilder(
      column: $table.nfact, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get clt => $composableBuilder(
      column: $table.clt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get modepai => $composableBuilder(
      column: $table.modepai, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get echeance => $composableBuilder(
      column: $table.echeance, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get totalnt => $composableBuilder(
      column: $table.totalnt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get totalttc => $composableBuilder(
      column: $table.totalttc, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get tva => $composableBuilder(
      column: $table.tva, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get contre => $composableBuilder(
      column: $table.contre, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get avance => $composableBuilder(
      column: $table.avance, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get bq => $composableBuilder(
      column: $table.bq, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get commerc => $composableBuilder(
      column: $table.commerc, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get commission => $composableBuilder(
      column: $table.commission, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get remise => $composableBuilder(
      column: $table.remise, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get verification => $composableBuilder(
      column: $table.verification,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get numventes1 => $composableBuilder(
      column: $table.numventes1, builder: (column) => ColumnOrderings(column));
}

class $$RetventesTableAnnotationComposer
    extends Composer<_$AppDatabase, $RetventesTable> {
  $$RetventesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get num =>
      $composableBuilder(column: $table.num, builder: (column) => column);

  GeneratedColumn<String> get numventes =>
      $composableBuilder(column: $table.numventes, builder: (column) => column);

  GeneratedColumn<String> get nfact =>
      $composableBuilder(column: $table.nfact, builder: (column) => column);

  GeneratedColumn<DateTime> get daty =>
      $composableBuilder(column: $table.daty, builder: (column) => column);

  GeneratedColumn<String> get clt =>
      $composableBuilder(column: $table.clt, builder: (column) => column);

  GeneratedColumn<String> get modepai =>
      $composableBuilder(column: $table.modepai, builder: (column) => column);

  GeneratedColumn<DateTime> get echeance =>
      $composableBuilder(column: $table.echeance, builder: (column) => column);

  GeneratedColumn<double> get totalnt =>
      $composableBuilder(column: $table.totalnt, builder: (column) => column);

  GeneratedColumn<double> get totalttc =>
      $composableBuilder(column: $table.totalttc, builder: (column) => column);

  GeneratedColumn<double> get tva =>
      $composableBuilder(column: $table.tva, builder: (column) => column);

  GeneratedColumn<String> get contre =>
      $composableBuilder(column: $table.contre, builder: (column) => column);

  GeneratedColumn<double> get avance =>
      $composableBuilder(column: $table.avance, builder: (column) => column);

  GeneratedColumn<String> get bq =>
      $composableBuilder(column: $table.bq, builder: (column) => column);

  GeneratedColumn<String> get commerc =>
      $composableBuilder(column: $table.commerc, builder: (column) => column);

  GeneratedColumn<double> get commission => $composableBuilder(
      column: $table.commission, builder: (column) => column);

  GeneratedColumn<double> get remise =>
      $composableBuilder(column: $table.remise, builder: (column) => column);

  GeneratedColumn<String> get verification => $composableBuilder(
      column: $table.verification, builder: (column) => column);

  GeneratedColumn<String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  GeneratedColumn<String> get numventes1 => $composableBuilder(
      column: $table.numventes1, builder: (column) => column);
}

class $$RetventesTableTableManager extends RootTableManager<
    _$AppDatabase,
    $RetventesTable,
    Retvente,
    $$RetventesTableFilterComposer,
    $$RetventesTableOrderingComposer,
    $$RetventesTableAnnotationComposer,
    $$RetventesTableCreateCompanionBuilder,
    $$RetventesTableUpdateCompanionBuilder,
    (Retvente, BaseReferences<_$AppDatabase, $RetventesTable, Retvente>),
    Retvente,
    PrefetchHooks Function()> {
  $$RetventesTableTableManager(_$AppDatabase db, $RetventesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$RetventesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$RetventesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$RetventesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> num = const Value.absent(),
            Value<String?> numventes = const Value.absent(),
            Value<String?> nfact = const Value.absent(),
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> clt = const Value.absent(),
            Value<String?> modepai = const Value.absent(),
            Value<DateTime?> echeance = const Value.absent(),
            Value<double?> totalnt = const Value.absent(),
            Value<double?> totalttc = const Value.absent(),
            Value<double?> tva = const Value.absent(),
            Value<String?> contre = const Value.absent(),
            Value<double?> avance = const Value.absent(),
            Value<String?> bq = const Value.absent(),
            Value<String?> commerc = const Value.absent(),
            Value<double?> commission = const Value.absent(),
            Value<double?> remise = const Value.absent(),
            Value<String?> verification = const Value.absent(),
            Value<String?> type = const Value.absent(),
            Value<String?> numventes1 = const Value.absent(),
          }) =>
              RetventesCompanion(
            num: num,
            numventes: numventes,
            nfact: nfact,
            daty: daty,
            clt: clt,
            modepai: modepai,
            echeance: echeance,
            totalnt: totalnt,
            totalttc: totalttc,
            tva: tva,
            contre: contre,
            avance: avance,
            bq: bq,
            commerc: commerc,
            commission: commission,
            remise: remise,
            verification: verification,
            type: type,
            numventes1: numventes1,
          ),
          createCompanionCallback: ({
            Value<int> num = const Value.absent(),
            Value<String?> numventes = const Value.absent(),
            Value<String?> nfact = const Value.absent(),
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> clt = const Value.absent(),
            Value<String?> modepai = const Value.absent(),
            Value<DateTime?> echeance = const Value.absent(),
            Value<double?> totalnt = const Value.absent(),
            Value<double?> totalttc = const Value.absent(),
            Value<double?> tva = const Value.absent(),
            Value<String?> contre = const Value.absent(),
            Value<double?> avance = const Value.absent(),
            Value<String?> bq = const Value.absent(),
            Value<String?> commerc = const Value.absent(),
            Value<double?> commission = const Value.absent(),
            Value<double?> remise = const Value.absent(),
            Value<String?> verification = const Value.absent(),
            Value<String?> type = const Value.absent(),
            Value<String?> numventes1 = const Value.absent(),
          }) =>
              RetventesCompanion.insert(
            num: num,
            numventes: numventes,
            nfact: nfact,
            daty: daty,
            clt: clt,
            modepai: modepai,
            echeance: echeance,
            totalnt: totalnt,
            totalttc: totalttc,
            tva: tva,
            contre: contre,
            avance: avance,
            bq: bq,
            commerc: commerc,
            commission: commission,
            remise: remise,
            verification: verification,
            type: type,
            numventes1: numventes1,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$RetventesTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $RetventesTable,
    Retvente,
    $$RetventesTableFilterComposer,
    $$RetventesTableOrderingComposer,
    $$RetventesTableAnnotationComposer,
    $$RetventesTableCreateCompanionBuilder,
    $$RetventesTableUpdateCompanionBuilder,
    (Retvente, BaseReferences<_$AppDatabase, $RetventesTable, Retvente>),
    Retvente,
    PrefetchHooks Function()>;
typedef $$SintrantTableCreateCompanionBuilder = SintrantCompanion Function({
  required String des,
  Value<double?> q,
  Value<int> rowid,
});
typedef $$SintrantTableUpdateCompanionBuilder = SintrantCompanion Function({
  Value<String> des,
  Value<double?> q,
  Value<int> rowid,
});

class $$SintrantTableFilterComposer
    extends Composer<_$AppDatabase, $SintrantTable> {
  $$SintrantTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get des => $composableBuilder(
      column: $table.des, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get q => $composableBuilder(
      column: $table.q, builder: (column) => ColumnFilters(column));
}

class $$SintrantTableOrderingComposer
    extends Composer<_$AppDatabase, $SintrantTable> {
  $$SintrantTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get des => $composableBuilder(
      column: $table.des, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get q => $composableBuilder(
      column: $table.q, builder: (column) => ColumnOrderings(column));
}

class $$SintrantTableAnnotationComposer
    extends Composer<_$AppDatabase, $SintrantTable> {
  $$SintrantTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get des =>
      $composableBuilder(column: $table.des, builder: (column) => column);

  GeneratedColumn<double> get q =>
      $composableBuilder(column: $table.q, builder: (column) => column);
}

class $$SintrantTableTableManager extends RootTableManager<
    _$AppDatabase,
    $SintrantTable,
    SintrantData,
    $$SintrantTableFilterComposer,
    $$SintrantTableOrderingComposer,
    $$SintrantTableAnnotationComposer,
    $$SintrantTableCreateCompanionBuilder,
    $$SintrantTableUpdateCompanionBuilder,
    (SintrantData, BaseReferences<_$AppDatabase, $SintrantTable, SintrantData>),
    SintrantData,
    PrefetchHooks Function()> {
  $$SintrantTableTableManager(_$AppDatabase db, $SintrantTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SintrantTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SintrantTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SintrantTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> des = const Value.absent(),
            Value<double?> q = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              SintrantCompanion(
            des: des,
            q: q,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String des,
            Value<double?> q = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              SintrantCompanion.insert(
            des: des,
            q: q,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$SintrantTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $SintrantTable,
    SintrantData,
    $$SintrantTableFilterComposer,
    $$SintrantTableOrderingComposer,
    $$SintrantTableAnnotationComposer,
    $$SintrantTableCreateCompanionBuilder,
    $$SintrantTableUpdateCompanionBuilder,
    (SintrantData, BaseReferences<_$AppDatabase, $SintrantTable, SintrantData>),
    SintrantData,
    PrefetchHooks Function()>;
typedef $$SproduitTableCreateCompanionBuilder = SproduitCompanion Function({
  required String des,
  Value<double?> q,
  Value<int> rowid,
});
typedef $$SproduitTableUpdateCompanionBuilder = SproduitCompanion Function({
  Value<String> des,
  Value<double?> q,
  Value<int> rowid,
});

class $$SproduitTableFilterComposer
    extends Composer<_$AppDatabase, $SproduitTable> {
  $$SproduitTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get des => $composableBuilder(
      column: $table.des, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get q => $composableBuilder(
      column: $table.q, builder: (column) => ColumnFilters(column));
}

class $$SproduitTableOrderingComposer
    extends Composer<_$AppDatabase, $SproduitTable> {
  $$SproduitTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get des => $composableBuilder(
      column: $table.des, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get q => $composableBuilder(
      column: $table.q, builder: (column) => ColumnOrderings(column));
}

class $$SproduitTableAnnotationComposer
    extends Composer<_$AppDatabase, $SproduitTable> {
  $$SproduitTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get des =>
      $composableBuilder(column: $table.des, builder: (column) => column);

  GeneratedColumn<double> get q =>
      $composableBuilder(column: $table.q, builder: (column) => column);
}

class $$SproduitTableTableManager extends RootTableManager<
    _$AppDatabase,
    $SproduitTable,
    SproduitData,
    $$SproduitTableFilterComposer,
    $$SproduitTableOrderingComposer,
    $$SproduitTableAnnotationComposer,
    $$SproduitTableCreateCompanionBuilder,
    $$SproduitTableUpdateCompanionBuilder,
    (SproduitData, BaseReferences<_$AppDatabase, $SproduitTable, SproduitData>),
    SproduitData,
    PrefetchHooks Function()> {
  $$SproduitTableTableManager(_$AppDatabase db, $SproduitTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SproduitTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SproduitTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SproduitTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> des = const Value.absent(),
            Value<double?> q = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              SproduitCompanion(
            des: des,
            q: q,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String des,
            Value<double?> q = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              SproduitCompanion.insert(
            des: des,
            q: q,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$SproduitTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $SproduitTable,
    SproduitData,
    $$SproduitTableFilterComposer,
    $$SproduitTableOrderingComposer,
    $$SproduitTableAnnotationComposer,
    $$SproduitTableCreateCompanionBuilder,
    $$SproduitTableUpdateCompanionBuilder,
    (SproduitData, BaseReferences<_$AppDatabase, $SproduitTable, SproduitData>),
    SproduitData,
    PrefetchHooks Function()>;
typedef $$TblunitTableCreateCompanionBuilder = TblunitCompanion Function({
  required String lib,
  Value<int> rowid,
});
typedef $$TblunitTableUpdateCompanionBuilder = TblunitCompanion Function({
  Value<String> lib,
  Value<int> rowid,
});

class $$TblunitTableFilterComposer
    extends Composer<_$AppDatabase, $TblunitTable> {
  $$TblunitTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get lib => $composableBuilder(
      column: $table.lib, builder: (column) => ColumnFilters(column));
}

class $$TblunitTableOrderingComposer
    extends Composer<_$AppDatabase, $TblunitTable> {
  $$TblunitTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get lib => $composableBuilder(
      column: $table.lib, builder: (column) => ColumnOrderings(column));
}

class $$TblunitTableAnnotationComposer
    extends Composer<_$AppDatabase, $TblunitTable> {
  $$TblunitTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get lib =>
      $composableBuilder(column: $table.lib, builder: (column) => column);
}

class $$TblunitTableTableManager extends RootTableManager<
    _$AppDatabase,
    $TblunitTable,
    TblunitData,
    $$TblunitTableFilterComposer,
    $$TblunitTableOrderingComposer,
    $$TblunitTableAnnotationComposer,
    $$TblunitTableCreateCompanionBuilder,
    $$TblunitTableUpdateCompanionBuilder,
    (TblunitData, BaseReferences<_$AppDatabase, $TblunitTable, TblunitData>),
    TblunitData,
    PrefetchHooks Function()> {
  $$TblunitTableTableManager(_$AppDatabase db, $TblunitTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$TblunitTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$TblunitTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$TblunitTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> lib = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              TblunitCompanion(
            lib: lib,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String lib,
            Value<int> rowid = const Value.absent(),
          }) =>
              TblunitCompanion.insert(
            lib: lib,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$TblunitTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $TblunitTable,
    TblunitData,
    $$TblunitTableFilterComposer,
    $$TblunitTableOrderingComposer,
    $$TblunitTableAnnotationComposer,
    $$TblunitTableCreateCompanionBuilder,
    $$TblunitTableUpdateCompanionBuilder,
    (TblunitData, BaseReferences<_$AppDatabase, $TblunitTable, TblunitData>),
    TblunitData,
    PrefetchHooks Function()>;
typedef $$TransfTableCreateCompanionBuilder = TransfCompanion Function({
  Value<int> num,
  Value<String?> numtransf,
  Value<DateTime?> daty,
  Value<String?> de,
  Value<String?> au,
  Value<String?> contre,
});
typedef $$TransfTableUpdateCompanionBuilder = TransfCompanion Function({
  Value<int> num,
  Value<String?> numtransf,
  Value<DateTime?> daty,
  Value<String?> de,
  Value<String?> au,
  Value<String?> contre,
});

class $$TransfTableFilterComposer
    extends Composer<_$AppDatabase, $TransfTable> {
  $$TransfTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get num => $composableBuilder(
      column: $table.num, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get numtransf => $composableBuilder(
      column: $table.numtransf, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get de => $composableBuilder(
      column: $table.de, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get au => $composableBuilder(
      column: $table.au, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get contre => $composableBuilder(
      column: $table.contre, builder: (column) => ColumnFilters(column));
}

class $$TransfTableOrderingComposer
    extends Composer<_$AppDatabase, $TransfTable> {
  $$TransfTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get num => $composableBuilder(
      column: $table.num, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get numtransf => $composableBuilder(
      column: $table.numtransf, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get de => $composableBuilder(
      column: $table.de, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get au => $composableBuilder(
      column: $table.au, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get contre => $composableBuilder(
      column: $table.contre, builder: (column) => ColumnOrderings(column));
}

class $$TransfTableAnnotationComposer
    extends Composer<_$AppDatabase, $TransfTable> {
  $$TransfTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get num =>
      $composableBuilder(column: $table.num, builder: (column) => column);

  GeneratedColumn<String> get numtransf =>
      $composableBuilder(column: $table.numtransf, builder: (column) => column);

  GeneratedColumn<DateTime> get daty =>
      $composableBuilder(column: $table.daty, builder: (column) => column);

  GeneratedColumn<String> get de =>
      $composableBuilder(column: $table.de, builder: (column) => column);

  GeneratedColumn<String> get au =>
      $composableBuilder(column: $table.au, builder: (column) => column);

  GeneratedColumn<String> get contre =>
      $composableBuilder(column: $table.contre, builder: (column) => column);
}

class $$TransfTableTableManager extends RootTableManager<
    _$AppDatabase,
    $TransfTable,
    TransfData,
    $$TransfTableFilterComposer,
    $$TransfTableOrderingComposer,
    $$TransfTableAnnotationComposer,
    $$TransfTableCreateCompanionBuilder,
    $$TransfTableUpdateCompanionBuilder,
    (TransfData, BaseReferences<_$AppDatabase, $TransfTable, TransfData>),
    TransfData,
    PrefetchHooks Function()> {
  $$TransfTableTableManager(_$AppDatabase db, $TransfTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$TransfTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$TransfTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$TransfTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> num = const Value.absent(),
            Value<String?> numtransf = const Value.absent(),
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> de = const Value.absent(),
            Value<String?> au = const Value.absent(),
            Value<String?> contre = const Value.absent(),
          }) =>
              TransfCompanion(
            num: num,
            numtransf: numtransf,
            daty: daty,
            de: de,
            au: au,
            contre: contre,
          ),
          createCompanionCallback: ({
            Value<int> num = const Value.absent(),
            Value<String?> numtransf = const Value.absent(),
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> de = const Value.absent(),
            Value<String?> au = const Value.absent(),
            Value<String?> contre = const Value.absent(),
          }) =>
              TransfCompanion.insert(
            num: num,
            numtransf: numtransf,
            daty: daty,
            de: de,
            au: au,
            contre: contre,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$TransfTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $TransfTable,
    TransfData,
    $$TransfTableFilterComposer,
    $$TransfTableOrderingComposer,
    $$TransfTableAnnotationComposer,
    $$TransfTableCreateCompanionBuilder,
    $$TransfTableUpdateCompanionBuilder,
    (TransfData, BaseReferences<_$AppDatabase, $TransfTable, TransfData>),
    TransfData,
    PrefetchHooks Function()>;
typedef $$TribanqueTableCreateCompanionBuilder = TribanqueCompanion Function({
  required String ref,
  Value<DateTime?> daty,
  Value<String?> lib,
  Value<double?> debit,
  Value<double?> credit,
  Value<double?> soldes,
  Value<String?> code,
  Value<int> rowid,
});
typedef $$TribanqueTableUpdateCompanionBuilder = TribanqueCompanion Function({
  Value<String> ref,
  Value<DateTime?> daty,
  Value<String?> lib,
  Value<double?> debit,
  Value<double?> credit,
  Value<double?> soldes,
  Value<String?> code,
  Value<int> rowid,
});

class $$TribanqueTableFilterComposer
    extends Composer<_$AppDatabase, $TribanqueTable> {
  $$TribanqueTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get ref => $composableBuilder(
      column: $table.ref, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get lib => $composableBuilder(
      column: $table.lib, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get debit => $composableBuilder(
      column: $table.debit, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get credit => $composableBuilder(
      column: $table.credit, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get soldes => $composableBuilder(
      column: $table.soldes, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnFilters(column));
}

class $$TribanqueTableOrderingComposer
    extends Composer<_$AppDatabase, $TribanqueTable> {
  $$TribanqueTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get ref => $composableBuilder(
      column: $table.ref, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get lib => $composableBuilder(
      column: $table.lib, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get debit => $composableBuilder(
      column: $table.debit, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get credit => $composableBuilder(
      column: $table.credit, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get soldes => $composableBuilder(
      column: $table.soldes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnOrderings(column));
}

class $$TribanqueTableAnnotationComposer
    extends Composer<_$AppDatabase, $TribanqueTable> {
  $$TribanqueTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get ref =>
      $composableBuilder(column: $table.ref, builder: (column) => column);

  GeneratedColumn<DateTime> get daty =>
      $composableBuilder(column: $table.daty, builder: (column) => column);

  GeneratedColumn<String> get lib =>
      $composableBuilder(column: $table.lib, builder: (column) => column);

  GeneratedColumn<double> get debit =>
      $composableBuilder(column: $table.debit, builder: (column) => column);

  GeneratedColumn<double> get credit =>
      $composableBuilder(column: $table.credit, builder: (column) => column);

  GeneratedColumn<double> get soldes =>
      $composableBuilder(column: $table.soldes, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);
}

class $$TribanqueTableTableManager extends RootTableManager<
    _$AppDatabase,
    $TribanqueTable,
    TribanqueData,
    $$TribanqueTableFilterComposer,
    $$TribanqueTableOrderingComposer,
    $$TribanqueTableAnnotationComposer,
    $$TribanqueTableCreateCompanionBuilder,
    $$TribanqueTableUpdateCompanionBuilder,
    (
      TribanqueData,
      BaseReferences<_$AppDatabase, $TribanqueTable, TribanqueData>
    ),
    TribanqueData,
    PrefetchHooks Function()> {
  $$TribanqueTableTableManager(_$AppDatabase db, $TribanqueTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$TribanqueTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$TribanqueTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$TribanqueTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> ref = const Value.absent(),
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> lib = const Value.absent(),
            Value<double?> debit = const Value.absent(),
            Value<double?> credit = const Value.absent(),
            Value<double?> soldes = const Value.absent(),
            Value<String?> code = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              TribanqueCompanion(
            ref: ref,
            daty: daty,
            lib: lib,
            debit: debit,
            credit: credit,
            soldes: soldes,
            code: code,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String ref,
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> lib = const Value.absent(),
            Value<double?> debit = const Value.absent(),
            Value<double?> credit = const Value.absent(),
            Value<double?> soldes = const Value.absent(),
            Value<String?> code = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              TribanqueCompanion.insert(
            ref: ref,
            daty: daty,
            lib: lib,
            debit: debit,
            credit: credit,
            soldes: soldes,
            code: code,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$TribanqueTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $TribanqueTable,
    TribanqueData,
    $$TribanqueTableFilterComposer,
    $$TribanqueTableOrderingComposer,
    $$TribanqueTableAnnotationComposer,
    $$TribanqueTableCreateCompanionBuilder,
    $$TribanqueTableUpdateCompanionBuilder,
    (
      TribanqueData,
      BaseReferences<_$AppDatabase, $TribanqueTable, TribanqueData>
    ),
    TribanqueData,
    PrefetchHooks Function()>;
typedef $$TricaisseTableCreateCompanionBuilder = TricaisseCompanion Function({
  required String ref,
  Value<DateTime?> daty,
  Value<String?> lib,
  Value<double?> debit,
  Value<double?> credit,
  Value<double?> soldes,
  Value<int> rowid,
});
typedef $$TricaisseTableUpdateCompanionBuilder = TricaisseCompanion Function({
  Value<String> ref,
  Value<DateTime?> daty,
  Value<String?> lib,
  Value<double?> debit,
  Value<double?> credit,
  Value<double?> soldes,
  Value<int> rowid,
});

class $$TricaisseTableFilterComposer
    extends Composer<_$AppDatabase, $TricaisseTable> {
  $$TricaisseTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get ref => $composableBuilder(
      column: $table.ref, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get lib => $composableBuilder(
      column: $table.lib, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get debit => $composableBuilder(
      column: $table.debit, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get credit => $composableBuilder(
      column: $table.credit, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get soldes => $composableBuilder(
      column: $table.soldes, builder: (column) => ColumnFilters(column));
}

class $$TricaisseTableOrderingComposer
    extends Composer<_$AppDatabase, $TricaisseTable> {
  $$TricaisseTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get ref => $composableBuilder(
      column: $table.ref, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get daty => $composableBuilder(
      column: $table.daty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get lib => $composableBuilder(
      column: $table.lib, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get debit => $composableBuilder(
      column: $table.debit, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get credit => $composableBuilder(
      column: $table.credit, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get soldes => $composableBuilder(
      column: $table.soldes, builder: (column) => ColumnOrderings(column));
}

class $$TricaisseTableAnnotationComposer
    extends Composer<_$AppDatabase, $TricaisseTable> {
  $$TricaisseTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get ref =>
      $composableBuilder(column: $table.ref, builder: (column) => column);

  GeneratedColumn<DateTime> get daty =>
      $composableBuilder(column: $table.daty, builder: (column) => column);

  GeneratedColumn<String> get lib =>
      $composableBuilder(column: $table.lib, builder: (column) => column);

  GeneratedColumn<double> get debit =>
      $composableBuilder(column: $table.debit, builder: (column) => column);

  GeneratedColumn<double> get credit =>
      $composableBuilder(column: $table.credit, builder: (column) => column);

  GeneratedColumn<double> get soldes =>
      $composableBuilder(column: $table.soldes, builder: (column) => column);
}

class $$TricaisseTableTableManager extends RootTableManager<
    _$AppDatabase,
    $TricaisseTable,
    TricaisseData,
    $$TricaisseTableFilterComposer,
    $$TricaisseTableOrderingComposer,
    $$TricaisseTableAnnotationComposer,
    $$TricaisseTableCreateCompanionBuilder,
    $$TricaisseTableUpdateCompanionBuilder,
    (
      TricaisseData,
      BaseReferences<_$AppDatabase, $TricaisseTable, TricaisseData>
    ),
    TricaisseData,
    PrefetchHooks Function()> {
  $$TricaisseTableTableManager(_$AppDatabase db, $TricaisseTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$TricaisseTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$TricaisseTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$TricaisseTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> ref = const Value.absent(),
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> lib = const Value.absent(),
            Value<double?> debit = const Value.absent(),
            Value<double?> credit = const Value.absent(),
            Value<double?> soldes = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              TricaisseCompanion(
            ref: ref,
            daty: daty,
            lib: lib,
            debit: debit,
            credit: credit,
            soldes: soldes,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String ref,
            Value<DateTime?> daty = const Value.absent(),
            Value<String?> lib = const Value.absent(),
            Value<double?> debit = const Value.absent(),
            Value<double?> credit = const Value.absent(),
            Value<double?> soldes = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              TricaisseCompanion.insert(
            ref: ref,
            daty: daty,
            lib: lib,
            debit: debit,
            credit: credit,
            soldes: soldes,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$TricaisseTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $TricaisseTable,
    TricaisseData,
    $$TricaisseTableFilterComposer,
    $$TricaisseTableOrderingComposer,
    $$TricaisseTableAnnotationComposer,
    $$TricaisseTableCreateCompanionBuilder,
    $$TricaisseTableUpdateCompanionBuilder,
    (
      TricaisseData,
      BaseReferences<_$AppDatabase, $TricaisseTable, TricaisseData>
    ),
    TricaisseData,
    PrefetchHooks Function()>;

class $AppDatabaseManager {
  final _$AppDatabase _db;
  $AppDatabaseManager(this._db);
  $$SocTableTableManager get soc => $$SocTableTableManager(_db, _db.soc);
  $$DepotsTableTableManager get depots =>
      $$DepotsTableTableManager(_db, _db.depots);
  $$ArticlesTableTableManager get articles =>
      $$ArticlesTableTableManager(_db, _db.articles);
  $$CltTableTableManager get clt => $$CltTableTableManager(_db, _db.clt);
  $$FrnsTableTableManager get frns => $$FrnsTableTableManager(_db, _db.frns);
  $$ComTableTableManager get com => $$ComTableTableManager(_db, _db.com);
  $$VentesTableTableManager get ventes =>
      $$VentesTableTableManager(_db, _db.ventes);
  $$AchatsTableTableManager get achats =>
      $$AchatsTableTableManager(_db, _db.achats);
  $$StocksTableTableManager get stocks =>
      $$StocksTableTableManager(_db, _db.stocks);
  $$AutrescompteTableTableManager get autrescompte =>
      $$AutrescompteTableTableManager(_db, _db.autrescompte);
  $$BanqueTableTableManager get banque =>
      $$BanqueTableTableManager(_db, _db.banque);
  $$BlcltTableTableManager get blclt =>
      $$BlcltTableTableManager(_db, _db.blclt);
  $$BqTableTableManager get bq => $$BqTableTableManager(_db, _db.bq);
  $$CaTableTableManager get ca => $$CaTableTableManager(_db, _db.ca);
  $$CaisseTableTableManager get caisse =>
      $$CaisseTableTableManager(_db, _db.caisse);
  $$ChequierTableTableManager get chequier =>
      $$ChequierTableTableManager(_db, _db.chequier);
  $$CltiTableTableManager get clti => $$CltiTableTableManager(_db, _db.clti);
  $$ComptecltTableTableManager get compteclt =>
      $$ComptecltTableTableManager(_db, _db.compteclt);
  $$ComptecomTableTableManager get comptecom =>
      $$ComptecomTableTableManager(_db, _db.comptecom);
  $$ComptefrnsTableTableManager get comptefrns =>
      $$ComptefrnsTableTableManager(_db, _db.comptefrns);
  $$DepartTableTableManager get depart =>
      $$DepartTableTableManager(_db, _db.depart);
  $$DetachatsTableTableManager get detachats =>
      $$DetachatsTableTableManager(_db, _db.detachats);
  $$DetprodTableTableManager get detprod =>
      $$DetprodTableTableManager(_db, _db.detprod);
  $$DettransfTableTableManager get dettransf =>
      $$DettransfTableTableManager(_db, _db.dettransf);
  $$DetventesTableTableManager get detventes =>
      $$DetventesTableTableManager(_db, _db.detventes);
  $$EffetsTableTableManager get effets =>
      $$EffetsTableTableManager(_db, _db.effets);
  $$EmbTableTableManager get emb => $$EmbTableTableManager(_db, _db.emb);
  $$EmblcltTableTableManager get emblclt =>
      $$EmblcltTableTableManager(_db, _db.emblclt);
  $$FstocksTableTableManager get fstocks =>
      $$FstocksTableTableManager(_db, _db.fstocks);
  $$MpTableTableManager get mp => $$MpTableTableManager(_db, _db.mp);
  $$ProdTableTableManager get prod => $$ProdTableTableManager(_db, _db.prod);
  $$PvTableTableManager get pv => $$PvTableTableManager(_db, _db.pv);
  $$RetachatsTableTableManager get retachats =>
      $$RetachatsTableTableManager(_db, _db.retachats);
  $$RetdetachatsTableTableManager get retdetachats =>
      $$RetdetachatsTableTableManager(_db, _db.retdetachats);
  $$RetdeventesTableTableManager get retdeventes =>
      $$RetdeventesTableTableManager(_db, _db.retdeventes);
  $$RetventesTableTableManager get retventes =>
      $$RetventesTableTableManager(_db, _db.retventes);
  $$SintrantTableTableManager get sintrant =>
      $$SintrantTableTableManager(_db, _db.sintrant);
  $$SproduitTableTableManager get sproduit =>
      $$SproduitTableTableManager(_db, _db.sproduit);
  $$TblunitTableTableManager get tblunit =>
      $$TblunitTableTableManager(_db, _db.tblunit);
  $$TransfTableTableManager get transf =>
      $$TransfTableTableManager(_db, _db.transf);
  $$TribanqueTableTableManager get tribanque =>
      $$TribanqueTableTableManager(_db, _db.tribanque);
  $$TricaisseTableTableManager get tricaisse =>
      $$TricaisseTableTableManager(_db, _db.tricaisse);
}
